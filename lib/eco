Advection_diffusion.c:78:    int m=E->parallel.me;
Advection_diffusion.c:80:    input_boolean("ADV",&(E->advection.ADVECTION),"on",m);
Advection_diffusion.c:81:    input_boolean("filter_temp",&(E->advection.filter_temperature),"off",m);
Advection_diffusion.c:82:    input_boolean("monitor_max_T",&(E->advection.monitor_max_T),"on",m);
Advection_diffusion.c:84:    input_int("minstep",&(E->advection.min_timesteps),"1",m);
Advection_diffusion.c:85:    input_int("maxstep",&(E->advection.max_timesteps),"1000",m);
Advection_diffusion.c:86:    input_int("maxtotstep",&(E->advection.max_total_timesteps),"1000000",m);
Advection_diffusion.c:87:    input_float("finetunedt",&(E->advection.fine_tune_dt),"0.9",m);
Advection_diffusion.c:88:    input_float("fixed_timestep",&(E->advection.fixed_timestep),"0.0",m);
Advection_diffusion.c:89:    input_float("adv_gamma",&(E->advection.gamma),"0.5",m);
Advection_diffusion.c:90:    input_int("adv_sub_iterations",&(E->advection.temp_iterations),"2,1,nomax",m);
Advection_diffusion.c:92:    input_float("inputdiffusivity",&(E->control.inputdiff),"1.0",m);
Advection_diffusion.c:103:  E->Tdot = (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:105:  for(i=1;i<=E->lmesh.nno;i++)
Advection_diffusion.c:106:    E->Tdot[i]=0.0;
Advection_diffusion.c:150:    const int dims=E->mesh.nsd;
Advection_diffusion.c:151:    const int dofs=E->mesh.dof;
Advection_diffusion.c:152:    const int nno=E->lmesh.nno;
Advection_diffusion.c:153:    const int lev=E->mesh.levmax;
Advection_diffusion.c:157:    nel=E->lmesh.nel;
Advection_diffusion.c:159:    if(E->advection.fixed_timestep != 0.0) {
Advection_diffusion.c:160:      E->advection.timestep = E->advection.fixed_timestep;
Advection_diffusion.c:171:	  uc1 += E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:172:	  uc2 += E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:173:	  uc3 += E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Advection_diffusion.c:175:	uc = fabs(uc1)/E->eco[el].size[1] + 
Advection_diffusion.c:176:       fabs(uc2)/E->eco[el].size[2] + 
Advection_diffusion.c:177:       fabs(uc3)/E->eco[el].size[3];
Advection_diffusion.c:183:  adv_timestep = E->advection.dt_reduced * adv_timestep;
Advection_diffusion.c:185:  adv_timestep = 1.0e-32 + min(E->advection.fine_tune_dt*adv_timestep,
Advection_diffusion.c:186:       E->advection.diff_timestep);
Advection_diffusion.c:188:  E->advection.timestep = global_fmin(E,adv_timestep);
Advection_diffusion.c:205:  E->advection.timesteps++;
Advection_diffusion.c:207:  DTdot = (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:210:  if(E->advection.monitor_max_T) {
Advection_diffusion.c:211:     T1 = (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:212:     Tdot1 = (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:214:     for (i=1;i<=E->lmesh.nno;i++){
Advection_diffusion.c:215:         T1[i] = E->T[i];
Advection_diffusion.c:216:         Tdot1[i] = E->Tdot[i];
Advection_diffusion.c:220:     T_interior1 = Tmaxd(E,E->T);
Advection_diffusion.c:223:  E->advection.dt_reduced = 1.0;
Advection_diffusion.c:224:  E->advection.last_sub_iterations = 1;
Advection_diffusion.c:228:    E->advection.timestep *= E->advection.dt_reduced;
Advection_diffusion.c:231:    if (E->advection.ADVECTION) {
Advection_diffusion.c:233:      predictor(E,E->T,E->Tdot);
Advection_diffusion.c:235:      for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++)   {
Advection_diffusion.c:237:        if(E->control.disptn_number != 0)
Advection_diffusion.c:241:	pg_solver(E,E->T,E->Tdot,DTdot,&(E->convection.heat_sources),E->control.inputdiff,1,E->node);
Advection_diffusion.c:242:	corrector(E,E->T,E->Tdot,DTdot);
Advection_diffusion.c:246:      if(E->advection.monitor_max_T) {
Advection_diffusion.c:248:          E->monitor.T_interior = Tmaxd(E,E->T);
Advection_diffusion.c:253:          if (E->monitor.T_interior/T_interior1 > E->monitor.T_maxvaried) {
Advection_diffusion.c:254:              if(E->parallel.me==0) {
Advection_diffusion.c:256:                          T_interior1, E->monitor.T_interior);
Advection_diffusion.c:257:                  fprintf(E->fp, "max T varied from %e to %e\n",
Advection_diffusion.c:258:                          T_interior1, E->monitor.T_interior);
Advection_diffusion.c:260:              for (i=1;i<=E->lmesh.nno;i++)   {
Advection_diffusion.c:261:                  E->T[i] = T1[i];
Advection_diffusion.c:262:                  E->Tdot[i] = Tdot1[i];
Advection_diffusion.c:265:              E->advection.dt_reduced *= 0.5;
Advection_diffusion.c:266:              E->advection.last_sub_iterations ++;
Advection_diffusion.c:271:  }  while ( iredo==1 && E->advection.last_sub_iterations <= 5);
Advection_diffusion.c:275:  if(E->advection.filter_temperature)
Advection_diffusion.c:279:  E->advection.total_timesteps++;
Advection_diffusion.c:280:  E->monitor.elapsed_time += E->advection.timestep;
Advection_diffusion.c:282:  if (E->advection.last_sub_iterations==5)
Advection_diffusion.c:283:    E->control.keep_going = 0;
Advection_diffusion.c:287:  if(E->advection.monitor_max_T) {
Advection_diffusion.c:292:  if(E->control.lith_age) {
Advection_diffusion.c:293:    if(E->parallel.me==0) fprintf(stderr,"PG_timestep_solve\n");
Advection_diffusion.c:310:  for(el=1;el<=E->lmesh.nel;el++) {
Advection_diffusion.c:311:    for(d=1;d<=E->mesh.nsd;d++) {
Advection_diffusion.c:312:      ts = E->eco[el].size[d] * E->eco[el].size[d];
Advection_diffusion.c:318:  E->advection.diff_timestep = 0.5 * diff_timestep;
Advection_diffusion.c:332:  multiplier = (1.0-E->advection.gamma) * E->advection.timestep;
Advection_diffusion.c:334:  for(node=1;node<=E->lmesh.nno;node++)  {
Advection_diffusion.c:347:  multiplier = E->advection.gamma * E->advection.timestep;
Advection_diffusion.c:349:  for(node=1;node<=E->lmesh.nno;node++) {
Advection_diffusion.c:377:    const int dims=E->mesh.nsd;
Advection_diffusion.c:378:    const int dofs=E->mesh.dof;
Advection_diffusion.c:381:    const int lev=E->mesh.levmax;
Advection_diffusion.c:383:    for(i=1;i<=E->lmesh.nno;i++)
Advection_diffusion.c:386:    for(el=1;el<=E->lmesh.nel;el++)    {
Advection_diffusion.c:391:      pg_shape_fn(E, el, &PG, &(E->gNX[el]), VV, rtf, diff);
Advection_diffusion.c:392:      element_residual(E, el, &PG, &(E->gNX[el]), &(E->gDA[el]),
Advection_diffusion.c:394:                       Q0, Eres, rtf, diff, E->sphere.cap.TB, // check cap
Advection_diffusion.c:398:        a1 = E->ien[el].node[a];
Advection_diffusion.c:404:    (E->exchange_node_d)(E,DTdot,lev);
Advection_diffusion.c:406:    for(i=1;i<=E->lmesh.nno;i++) {
Advection_diffusion.c:407:      if(!(E->node[i] & (TBX | TBY | TBZ)))
Advection_diffusion.c:408:        DTdot[i] *= E->TMass[i];   /* lumped mass matrix */
Advection_diffusion.c:432:    ienm=E->ien[el].node;
Advection_diffusion.c:439:      uc1 +=  E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:440:      uc2 +=  E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:441:      uc3 +=  E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Advection_diffusion.c:444:    uxse = fabs(uc1*E->eco[el].size[1]);
Advection_diffusion.c:445:    ueta = fabs(uc2*E->eco[el].size[2]);
Advection_diffusion.c:446:    ufai = fabs(uc3*E->eco[el].size[3]);
Advection_diffusion.c:463:        u1 += VV[1][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:464:        u2 += VV[2][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:465:        u3 += VV[3][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:473:        PG->vpt[GNVINDEX(j,i)] = E->N.vpt[GNVINDEX(j,i)] + adiff * prod1;
Advection_diffusion.c:509:    const int dims=E->mesh.nsd;
Advection_diffusion.c:510:    const int dofs=E->mesh.dof;
Advection_diffusion.c:511:    const int nno=E->lmesh.nno;
Advection_diffusion.c:512:    const int lev=E->mesh.levmax;
Advection_diffusion.c:529:      node = E->ien[el].node[j];
Advection_diffusion.c:531:      if(E->node[node] & (TBX | TBY | TBZ))
Advection_diffusion.c:537:          dT[i] += DT * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:541:          sfn = E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:549:    Q = E->control.Q0;
Advection_diffusion.c:552:    if(E->control.tracer_enriched){
Advection_diffusion.c:559:      Q *= (1.0 - E->composition.comp_el[0][el]);
Advection_diffusion.c:560:      Q += E->composition.comp_el[0][el] * E->control.Q0ER;
Advection_diffusion.c:563:    nz = ((el-1) % E->lmesh.elz) + 1;
Advection_diffusion.c:564:    rho = 0.5*(E->refstate.rho[nz] + E->refstate.rho[nz+1]);
Advection_diffusion.c:565:    cp = 0.5*(E->refstate.heat_capacity[nz] + E->refstate.heat_capacity[nz+1]);
Advection_diffusion.c:567:    if(E->control.disptn_number == 0)
Advection_diffusion.c:570:        /* E->heating_latent is actually the inverse of latent heating */
Advection_diffusion.c:571:        heating = (rho * Q - E->heating_adi[el] + E->heating_visc[el]) 
Advection_diffusion.c:572:                  * E->heating_latent[el];
Advection_diffusion.c:584:              + diff * dOmega->vpt[i] * E->heating_latent[el]
Advection_diffusion.c:606:      if (FLAGS[E->ien[el].node[1]] & FBZ) {// only check for the 1st node
Advection_diffusion.c:611:        if (FLAGS[E->ien[el].node[5]] & FBZ) {// only check for the 5th node
Advection_diffusion.c:622:                E->M.vpt[GMVINDEX(k,j)]*BC[3][E->ien[el].node[k+aid*onedvpts]];
Advection_diffusion.c:626:              E->M.vpt[GMVINDEX(a,j)] * g_1d[j].weight[dims-1] * dT[j];
Advection_diffusion.c:655:    lev=E->mesh.levmax;
Advection_diffusion.c:657:    rhocp = (double *)malloc((E->lmesh.noz+1)*sizeof(double));
Advection_diffusion.c:658:    for(i=1;i<=E->lmesh.noz;i++)
Advection_diffusion.c:659:        rhocp[i] = E->refstate.rho[i] * E->refstate.heat_capacity[i];
Advection_diffusion.c:661:    for(i=1;i<=E->lmesh.nno;i++)  {
Advection_diffusion.c:662:      nz = ((i-1) % E->lmesh.noz) + 1;
Advection_diffusion.c:666:      if(!(E->NODE[lev][i] & SKIP))
Advection_diffusion.c:667:          Tsum0 += E->T[i]*rhocp[nz];
Advection_diffusion.c:670:      if(E->T[i]<Tmin)  Tmin=E->T[i];
Advection_diffusion.c:671:      if(E->T[i]<Tmin0) E->T[i]=Tmin0;
Advection_diffusion.c:672:      if(E->T[i]>Tmax) Tmax=E->T[i];
Advection_diffusion.c:673:      if(E->T[i]>Tmax0) E->T[i]=Tmax0;
Advection_diffusion.c:678:    MPI_Allreduce(&Tmin,&Tmin1,1,MPI_DOUBLE,MPI_MIN,E->parallel.world);
Advection_diffusion.c:679:    MPI_Allreduce(&Tmax,&Tmax1,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Advection_diffusion.c:681:    for(i=1;i<=E->lmesh.nno;i++)  {
Advection_diffusion.c:682:        nz = ((i-1) % E->lmesh.noz) + 1;
Advection_diffusion.c:685:        if(E->T[i]<=fabs(2*Tmin0-Tmin1))   
Advection_diffusion.c:686:          E->T[i]=Tmin0;
Advection_diffusion.c:688:        if(E->T[i]>=(2*Tmax0-Tmax1))   
Advection_diffusion.c:689:          E->T[i]=Tmax0;
Advection_diffusion.c:692:        if (!(E->NODE[lev][i] & SKIP))  {
Advection_diffusion.c:693:          Tsum1 += E->T[i]*rhocp[nz];
Advection_diffusion.c:694:          if(E->T[i]!=Tmin0 && E->T[i]!=Tmax0) {
Advection_diffusion.c:702:    MPI_Allreduce(&TDIST,&TDIST1,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Advection_diffusion.c:704:        E->parallel.world);
Advection_diffusion.c:709:    for(i=1;i<=E->lmesh.nno;i++) {
Advection_diffusion.c:710:      if(E->T[i]!=Tmin0 && E->T[i]!=Tmax0)
Advection_diffusion.c:711:        E->T[i] +=TDIST;
Advection_diffusion.c:725:    strain_sqr = (float*) malloc((E->lmesh.nel+1)*sizeof(float));
Advection_diffusion.c:728:    temp = E->control.disptn_number / E->control.Atemp / vpts;
Advection_diffusion.c:732:    for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:735:        visc += E->EVi[(e-1)*vpts + i];
Advection_diffusion.c:749:    temp2 = E->control.disptn_number / ends;
Advection_diffusion.c:750:    for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:751:        ez = (e - 1) % E->lmesh.elz + 1;
Advection_diffusion.c:753:            * (E->refstate.thermal_expansivity[ez] +
Advection_diffusion.c:754:               E->refstate.thermal_expansivity[ez + 1])
Advection_diffusion.c:755:            * (E->refstate.rho[ez] + E->refstate.rho[ez + 1])
Advection_diffusion.c:756:            * (E->refstate.gravity[ez] + E->refstate.gravity[ez + 1]);
Advection_diffusion.c:760:            j = E->ien[e].node[i];
Advection_diffusion.c:761:            temp1 += E->sphere.cap.V[3][j] // rkk check the cap
Advection_diffusion.c:762:                * (E->T[j] + E->control.surface_temp);
Advection_diffusion.c:780:  temp0 = 2.0 * inv_width * clapeyron * E->control.disptn_number * Ra / 
Advection_diffusion.c:781:    E->control.Atemp / ends;
Advection_diffusion.c:784:  for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:785:    ez = (e - 1) % E->lmesh.elz + 1;
Advection_diffusion.c:787:        * (E->refstate.thermal_expansivity[ez] +
Advection_diffusion.c:788:           E->refstate.thermal_expansivity[ez + 1])
Advection_diffusion.c:789:        * (E->refstate.rho[ez] + E->refstate.rho[ez + 1])
Advection_diffusion.c:790:        * (E->refstate.gravity[ez] + E->refstate.gravity[ez + 1]);
Advection_diffusion.c:795:      j = E->ien[e].node[i];
Advection_diffusion.c:796:      temp = (1.0 - B[j]) * B[j] * (E->T[j] + E->control.surface_temp);
Advection_diffusion.c:797:      temp2 += temp * E->sphere.cap.V[3][j]; // rkk: check the cap
Advection_diffusion.c:815:    for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:818:    if(E->control.Ra_410 != 0.0) {
Advection_diffusion.c:820:                     E->Fas410, E->control.Ra_410,
Advection_diffusion.c:821:                     E->control.clapeyron410, E->viscosity.z410,
Advection_diffusion.c:822:                     E->control.transT410, E->control.inv_width410);
Advection_diffusion.c:825:    if(E->control.Ra_670 != 0.0) {
Advection_diffusion.c:827:                       E->Fas670, E->control.Ra_670,
Advection_diffusion.c:828:                       E->control.clapeyron670, E->viscosity.zlm,
Advection_diffusion.c:829:                       E->control.transT670, E->control.inv_width670);
Advection_diffusion.c:832:    if(E->control.Ra_cmb != 0.0) {
Advection_diffusion.c:834:                       E->Fascmb, E->control.Ra_cmb,
Advection_diffusion.c:835:                       E->control.clapeyroncmb, E->viscosity.zcmb,
Advection_diffusion.c:836:                       E->control.transTcmb, E->control.inv_widthcmb);
Advection_diffusion.c:839:    if(E->control.Ra_410 != 0 || E->control.Ra_670 != 0.0 ||
Advection_diffusion.c:840:       E->control.Ra_cmb != 0) {
Advection_diffusion.c:841:        for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:853:    for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:854:      sum += heating[e] * E->eco[e].area;
Advection_diffusion.c:857:    MPI_Allreduce(&sum, &total, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Advection_diffusion.c:870:      process_visc_heating(E, E->heating_visc);
Advection_diffusion.c:872:    process_adi_heating(E, E->heating_adi);
Advection_diffusion.c:873:    process_latent_heating(E, E->heating_latent, E->heating_adi);
Advection_diffusion.c:877:    if(psc_pass == (E->advection.temp_iterations-1)) {
Advection_diffusion.c:878:      total_visc_heating = total_heating(E, E->heating_visc);
Advection_diffusion.c:879:      total_adi_heating = total_heating(E, E->heating_adi);
Advection_diffusion.c:881:      if(E->parallel.me == 0) {
Advection_diffusion.c:882:        fprintf(E->fp, "Step: %d, Total_heating(visc, adi): %g %g\n",
Advection_diffusion.c:883:                E->monitor.solution_cycles,
Advection_diffusion.c:886:                E->monitor.solution_cycles,
Anisotropic_viscosity.c:63:  if(E->viscosity.allow_anisotropic_viscosity){
Anisotropic_viscosity.c:64:    if((E->monitor.solution_cycles == 0)&&
Anisotropic_viscosity.c:65:       (E->viscosity.anivisc_start_from_iso)&&(E->monitor.visc_iter_count == 0)){
Anisotropic_viscosity.c:279:  const int vpts = vpoints[E->mesh.nsd];
Anisotropic_viscosity.c:280:  const int ends = enodes[E->mesh.nsd];
Anisotropic_viscosity.c:283:  mgmin = E->mesh.gridmin;
Anisotropic_viscosity.c:284:  mgmax = E->mesh.gridmax;
Anisotropic_viscosity.c:286:  mgmin = E->mesh.levmin;
Anisotropic_viscosity.c:287:  mgmax = E->mesh.levmax;
Anisotropic_viscosity.c:290:    if(E->parallel.me == 0)
Anisotropic_viscosity.c:292:	      (E->viscosity.allow_anisotropic_viscosity == 1)?("orthotropic"):("transversely isotropic"));
Anisotropic_viscosity.c:293:    if(E->viscosity.anisotropic_viscosity_init)
Anisotropic_viscosity.c:298:    switch(E->viscosity.anisotropic_init){
Anisotropic_viscosity.c:303:      if(E->parallel.me == 0)fprintf(stderr,"set_anisotropic_viscosity_at_element_level: initializing isotropic viscosity\n");
Anisotropic_viscosity.c:306:	nel  = E->lmesh.NEL[i];
Anisotropic_viscosity.c:310:	      E->EVI2[i][off] = 0.0;
Anisotropic_viscosity.c:311:	      E->EVIn1[i][off] = 1.0; 
Anisotropic_viscosity.c:312:        E->EVIn2[i][off] = 0.0;
Anisotropic_viscosity.c:313:        E->EVIn3[i][off] = 0.0;
Anisotropic_viscosity.c:314:	      E->avmode[i][off] = 
Anisotropic_viscosity.c:315:          (unsigned char) E->viscosity.allow_anisotropic_viscosity;
Anisotropic_viscosity.c:321:	nel  = E->lmesh.NEL[i];
Anisotropic_viscosity.c:325:	    E->EVI2[i][off] = 0.0;
Anisotropic_viscosity.c:326:	    E->EVIn1[i][off] = 1.0; E->EVIn2[i][off] = E->EVIn3[i][off] = 0.0;
Anisotropic_viscosity.c:327:	    E->avmode[i][off] = (unsigned char)
Anisotropic_viscosity.c:328:	      E->viscosity.allow_anisotropic_viscosity;
Anisotropic_viscosity.c:341:      if(E->parallel.me == 0)fprintf(stderr,"set_anisotropic_viscosity_at_element_level: initializing random viscosity\n");
Anisotropic_viscosity.c:343:	nel  = E->lmesh.NEL[i];
Anisotropic_viscosity.c:358:	      E->EVI2[i][off] = vis2;
Anisotropic_viscosity.c:359:        E->EVIn1[i][off] = n[0]; 
Anisotropic_viscosity.c:360:        E->EVIn2[i][off] = n[1];
Anisotropic_viscosity.c:361:        E->EVIn3[i][off] = n[2];
Anisotropic_viscosity.c:362:	      E->avmode[i][off] = 
Anisotropic_viscosity.c:363:          (unsigned char)E->viscosity.allow_anisotropic_viscosity;
Anisotropic_viscosity.c:365:	      E->EVI2[i][off] = vis2;   E->EVIn1[i][off] = n[0];    E->EVIn2[i][off] = n[1];   E->EVIn3[i][off] = n[2];
Anisotropic_viscosity.c:366:	      E->avmode[i][off] = (unsigned char)E->viscosity.allow_anisotropic_viscosity;
Anisotropic_viscosity.c:379:      if(E->sphere.caps == 12)	/* global */
Anisotropic_viscosity.c:394:      if(E->viscosity.ani_vis2_factor >= 0){
Anisotropic_viscosity.c:395:	if(E->parallel.me == 0)
Anisotropic_viscosity.c:397:		  E->viscosity.ani_vis2_factor);
Anisotropic_viscosity.c:404:	sprintf(tfilename,"%s/vis2.grd",E->viscosity.anisotropic_init_dir);
Anisotropic_viscosity.c:405:	if(E->parallel.me == 0)
Anisotropic_viscosity.c:410:	if(E->sphere.caps == 12)	
Anisotropic_viscosity.c:418:				      vis2_grd,(E->parallel.me == 0),FALSE,
Anisotropic_viscosity.c:425:      if(E->viscosity.anivisc_layer >= 0)
Anisotropic_viscosity.c:427:      ani_layer = -E->viscosity.anivisc_layer;
Anisotropic_viscosity.c:431:      z_bottom = E->sphere.ro-E->viscosity.zbase_layer[ani_layer-1];
Anisotropic_viscosity.c:433:	z_top = E->sphere.ro;
Anisotropic_viscosity.c:435:	z_top = E->sphere.ro - E->viscosity.zbase_layer[ani_layer-2];
Anisotropic_viscosity.c:441:      z_bottom = E->viscosity.zbase_layer[ani_layer-1];
Anisotropic_viscosity.c:443:	z_top = E->segment.zzlayer[E->segment.zlayers-1];
Anisotropic_viscosity.c:445:	z_top = E->viscosity.zbase_layer[ani_layer-2];
Anisotropic_viscosity.c:448:	  elx = E->lmesh.ELX[i];
Anisotropic_viscosity.c:449:    elz = E->lmesh.ELZ[i];
Anisotropic_viscosity.c:450:    ely = E->lmesh.ELY[i];
Anisotropic_viscosity.c:453:	    if(E->mat[j] ==  ani_layer){
Anisotropic_viscosity.c:456:		off = E->ien[j].node[inode];
Anisotropic_viscosity.c:457:		u += E->sx[3][off];
Anisotropic_viscosity.c:459:		off = E->ien[j].node[inode];
Anisotropic_viscosity.c:460:		if(E->control.Rsphere)
Anisotropic_viscosity.c:461:		  u += E->SX[3][off];
Anisotropic_viscosity.c:463:		  u += E->X[3][off];
Anisotropic_viscosity.c:471:		vis2 = exp(log(E->viscosity.ani_vis2_factor) * (u-z_bottom)/(z_top-z_bottom));
Anisotropic_viscosity.c:472:		//fprintf(stderr,"z %g (%g/%g) vis2 %g vis2_o %g frac %g\n",u,z_top,z_bottom,vis2, E->viscosity.ani_vis2_factor,(u-z_bottom)/(z_top-z_bottom));
Anisotropic_viscosity.c:486:		    off = E->ien[el].node[inode];
Anisotropic_viscosity.c:487:		    rtp2xyz((float)E->sx[3][off],(float)E->sx[1][off],(float)E->sx[2][off],rout);
Anisotropic_viscosity.c:512:		    E->EVI2[i][off] = vis2;
Anisotropic_viscosity.c:513:		    E->EVIn1[i][off] = n[0]; 
Anisotropic_viscosity.c:514:        E->EVIn2[i][off] = n[1];
Anisotropic_viscosity.c:515:        E->EVIn3[i][off] = n[2];
Anisotropic_viscosity.c:516:		    E->avmode[i][off] = CITCOM_ANIVISC_ORTHO_MODE;
Anisotropic_viscosity.c:522:		  if(E->control.Rsphere){ /* director in r direction */
Anisotropic_viscosity.c:525:		      off = E->ien[el].node[inode];
Anisotropic_viscosity.c:526:		      rtp2xyz((float)E->SX[3][off],(float)E->SX[1][off],(float)E->SX[2][off],rout);
Anisotropic_viscosity.c:548:			off = E->ien[el].node[inode];
Anisotropic_viscosity.c:549:			rout[0] += E->X[1][off];rout[1] += E->X[2][off];
Anisotropic_viscosity.c:550:			rout[2] += E->X[3][off];
Anisotropic_viscosity.c:563:		    E->EVI2[i][off] = vis2;
Anisotropic_viscosity.c:564:		    E->EVIn1[i][off] = n[0]; E->EVIn2[i][off] = n[1];E->EVIn3[i][off] = n[2];
Anisotropic_viscosity.c:565:		    E->avmode[i][off] = CITCOM_ANIVISC_ORTHO_MODE;
Anisotropic_viscosity.c:577:		    E->EVI2[i][off] = 0;
Anisotropic_viscosity.c:578:        E->EVIn1[i][off] = 1; 
Anisotropic_viscosity.c:579:        E->EVIn2[i][off] = 0;
Anisotropic_viscosity.c:580:        E->EVIn3[i][off] = 0;
Anisotropic_viscosity.c:581:        E->avmode[i][off] = CITCOM_ANIVISC_ORTHO_MODE;
Anisotropic_viscosity.c:583:		    E->EVI2[i][off] = 0;E->EVIn1[i][off] = 1; E->EVIn2[i][off] = 0;E->EVIn3[i][off] = 0;E->avmode[i][off] = CITCOM_ANIVISC_ORTHO_MODE;
Anisotropic_viscosity.c:597:	      E->viscosity.anisotropic_init);
Anisotropic_viscosity.c:601:    E->viscosity.anisotropic_viscosity_init = TRUE;
Anisotropic_viscosity.c:604:    //if(E->parallel.me == 0)fprintf(stderr,"reassigning anisotropic viscosity, mode %i\n",E->viscosity.anisotropic_init);
Anisotropic_viscosity.c:605:    if((E->monitor.solution_cycles > 0) || (E->monitor.visc_iter_count > 0)){
Anisotropic_viscosity.c:607:      switch(E->viscosity.anisotropic_init){
Anisotropic_viscosity.c:615:	if((E->monitor.solution_cycles > 0) || (E->monitor.visc_iter_count > 0))
Anisotropic_viscosity.c:619:	if((E->monitor.solution_cycles > 0) || (E->monitor.visc_iter_count > 0))
Anisotropic_viscosity.c:635:  for(n=1;n<=E->lmesh.NNO[lev];n++)
Anisotropic_viscosity.c:642:  const int nsd=E->mesh.nsd;
Anisotropic_viscosity.c:644:  for(e=1;e<=E->lmesh.NEL[lev];e++)
Anisotropic_viscosity.c:654:  for(n=1;n<=E->lmesh.NNO[lev];n++){
Anisotropic_viscosity.c:661:  const int nsd=E->mesh.nsd;
Anisotropic_viscosity.c:663:  for(e=1;e<=E->lmesh.NEL[lev];e++)
Anisotropic_viscosity.c:797:  const int dims = E->mesh.nsd;
Anisotropic_viscosity.c:801:  const int lev = E->mesh.levmax;
Anisotropic_viscosity.c:802:  const int nel = E->lmesh.nel;
Anisotropic_viscosity.c:806:  vis2 = 1. - E->viscosity.ani_vis2_factor; /* 1-eta_w/eta_s */
Anisotropic_viscosity.c:808:  if(E->parallel.me == 0){
Anisotropic_viscosity.c:829:    if(((E->viscosity.anivisc_layer > 0)&&
Anisotropic_viscosity.c:830:        (E->mat[e] <=   E->viscosity.anivisc_layer))||
Anisotropic_viscosity.c:831:       ((E->viscosity.anivisc_layer < 0)&&
Anisotropic_viscosity.c:832:        (E->mat[e] ==  -E->viscosity.anivisc_layer))){
Anisotropic_viscosity.c:834:      //if((e-1)%E->lmesh.elz==0)
Anisotropic_viscosity.c:835:      construct_c3x3matrix_el(E,e,&E->element_Cc,&E->element_Ccx,lev,1);
Anisotropic_viscosity.c:837:        off = E->ien[e].node[i];
Anisotropic_viscosity.c:838:        VV[1][i] = E->sphere.cap.V[1][off];
Anisotropic_viscosity.c:839:        VV[2][i] = E->sphere.cap.V[2][off];
Anisotropic_viscosity.c:840:        VV[3][i] = E->sphere.cap.V[3][off];
Anisotropic_viscosity.c:843:      get_vgm_p(VV,&(E->N),&(E->GNX[lev][e]),&E->element_Cc, 
Anisotropic_viscosity.c:844:                &E->element_Ccx,rtf,E->mesh.nsd,ppts,ends,TRUE,lgrad,
Anisotropic_viscosity.c:856:        E->avmode[lev][off] = avmode;
Anisotropic_viscosity.c:857:        E->EVI2[lev][off] = vis2;
Anisotropic_viscosity.c:858:        E->EVIn1[lev][off] = n[0]; 
Anisotropic_viscosity.c:859:        E->EVIn2[lev][off] = n[1];
Anisotropic_viscosity.c:860:        E->EVIn3[lev][off] = n[2];
Anisotropic_viscosity.c:864:    if(((E->viscosity.anivisc_layer > 0)&&
Anisotropic_viscosity.c:865:	(E->mat[e] <=   E->viscosity.anivisc_layer))||
Anisotropic_viscosity.c:866:       ((E->viscosity.anivisc_layer < 0)&&
Anisotropic_viscosity.c:867:	(E->mat[e] ==  -E->viscosity.anivisc_layer))){
Anisotropic_viscosity.c:868:      if(E->control.Rsphere){	/* need rtf for spherical */
Anisotropic_viscosity.c:870:	//if((e-1)%E->lmesh.elz==0)
Anisotropic_viscosity.c:874:	off = E->ien[e].node[i];
Anisotropic_viscosity.c:875:	VV[1][i] = E->V[1][off];
Anisotropic_viscosity.c:876:	VV[2][i] = E->V[2][off];
Anisotropic_viscosity.c:877:	VV[3][i] = E->V[3][off];
Anisotropic_viscosity.c:880:      get_vgm_p(VV,&(E->N),&(E->GNX[lev][e]),&Cc, &Ccx,rtf,
Anisotropic_viscosity.c:881:		E->mesh.nsd,ppts,ends,(E->control.Rsphere),lgrad,
Anisotropic_viscosity.c:889:      if(E->control.Rsphere){
Anisotropic_viscosity.c:898:	E->avmode[lev][off] = avmode;
Anisotropic_viscosity.c:899:	E->EVI2[lev][off] = vis2;
Anisotropic_viscosity.c:900:	E->EVIn1[lev][off] = n[0]; 
Anisotropic_viscosity.c:901:	E->EVIn2[lev][off] = n[1];
Anisotropic_viscosity.c:902:	E->EVIn3[lev][off] = n[2];
BC_util.c:55:  if(dirn > E->mesh.nsd)
BC_util.c:58:  noxnoz = E->lmesh.NOX[level]*E->lmesh.NOZ[level];
BC_util.c:64:  if((row >  E->lmesh.NOZ[level])||(row < 1))
BC_util.c:69:    for(j=1;j<=E->lmesh.NOY[level];j++)
BC_util.c:70:      for(i=1;i<=E->lmesh.NOX[level];i++) {
BC_util.c:71:        node = row+(i-1)*E->lmesh.NOZ[level]+(j-1)*noxnoz;
BC_util.c:72:        E->NODE[level][node] = E->NODE[level][node] & (~ mask);
BC_util.c:76:    for(j=1;j<=E->lmesh.NOY[level];j++)
BC_util.c:77:      for(i=1;i<=E->lmesh.NOX[level];i++) {
BC_util.c:78:        node = row+(i-1)*E->lmesh.NOZ[level]+(j-1)*noxnoz;
BC_util.c:79:        E->NODE[level][node] = E->NODE[level][node] | (mask);
BC_util.c:80:        if(level == E->mesh.levmax)   /* NB */
BC_util.c:93:  if( E->num_zero_resid[level] )
BC_util.c:94:    for( i=1; i<=E->num_zero_resid[level]; i++ )
BC_util.c:95:       Res[E->zero_resid[level][i]] = 0.0;
BC_util.c:105:  if(E->control.lith_age) {
BC_util.c:124:    for(node=1;node<=E->lmesh.nno;node++)  {
BC_util.c:126:        type = (E->node[node] & (TBX | TBZ | TBY));
BC_util.c:132:            E->T[node] = E->sphere.cap.TB[1][node];
BC_util.c:135:            E->T[node] = E->sphere.cap.TB[3][node];
BC_util.c:138:            E->T[node] = E->sphere.cap.TB[2][node];
BC_util.c:141:            E->T[node] = 0.5 * (E->sphere.cap.TB[1][node] + E->sphere.cap.TB[3][node]);
BC_util.c:144:            E->T[node] = 0.5 * (E->sphere.cap.TB[1][node] + E->sphere.cap.TB[2][node]);
BC_util.c:147:            E->T[node] = 0.5 * (E->sphere.cap.TB[3][node] + E->sphere.cap.TB[2][node]);
BC_util.c:150:            E->T[node] = 0.3333333 * (E->sphere.cap.TB[1][node] + E->sphere.cap.TB[2][node] + E->sphere.cap.TB[3][node]);
BC_util.c:168:    const int nno = E->lmesh.nno;
BC_util.c:171:      if (E->node[node] & typex)
BC_util.c:172:        U[E->id[node].doff[1]] = E->sphere.cap.VB[1][node];
BC_util.c:173:      if (E->node[node] & typey)
BC_util.c:174:        U[E->id[node].doff[2]] = E->sphere.cap.VB[2][node];
BC_util.c:175:      if (E->node[node] & typez)
BC_util.c:176:        U[E->id[node].doff[3]] = E->sphere.cap.VB[3][node];
BC_util.c:200:  if(E->mesh.toplayerbc > 0){
BC_util.c:201:    for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--) {
BC_util.c:202:      noz = E->lmesh.NOZ[lv];
BC_util.c:206:        ontop = ((k==noz) && (E->parallel.me_loc[3]==E->parallel.nprocz-1))?(1):(0);
BC_util.c:207:        onbottom = ((k==1) && (E->parallel.me_loc[3]==0))?(1):(0);
BC_util.c:209:        if(E->SX[lv][3][k] >= E->mesh.toplayerbc_r){
BC_util.c:211:          if((!ontop)&&(!onbottom)&&(lv==E->mesh.gridmax))
BC_util.c:213:          if(E->mesh.topvbc != 1) {	/* free slip */
BC_util.c:214:            internal_horizontal_bc(E,E->sphere.cap.VB,k,1,0.0,VBX,0,lv);
BC_util.c:216:              internal_horizontal_bc(E,E->sphere.cap.VB,k,3,0.0,VBZ,1,lv);
BC_util.c:217:            internal_horizontal_bc(E,E->sphere.cap.VB,k,2,0.0,VBY,0,lv);
BC_util.c:218:            internal_horizontal_bc(E,E->sphere.cap.VB,k,1,E->control.VBXtopval,SBX,1,lv);
BC_util.c:220:              internal_horizontal_bc(E,E->sphere.cap.VB,k,3,0.0,SBZ,0,lv);
BC_util.c:221:            internal_horizontal_bc(E,E->sphere.cap.VB,k,2,E->control.VBYtopval,SBY,1,lv);
BC_util.c:223:            internal_horizontal_bc(E,E->sphere.cap.VB,k,1,E->control.VBXtopval,VBX,1,lv);
BC_util.c:225:              internal_horizontal_bc(E,E->sphere.cap.VB,k,3,0.0,VBZ,1,lv);
BC_util.c:226:            internal_horizontal_bc(E,E->sphere.cap.VB,k,2,E->control.VBYtopval,VBY,1,lv);
BC_util.c:227:            internal_horizontal_bc(E,E->sphere.cap.VB,k,1,0.0,SBX,0,lv);
BC_util.c:229:              internal_horizontal_bc(E,E->sphere.cap.VB,k,3,0.0,SBZ,0,lv);
BC_util.c:230:            internal_horizontal_bc(E,E->sphere.cap.VB,k,2,0.0,SBY,0,lv);
BC_util.c:237:    if(E->control.ggrd.vtop_control)
BC_util.c:241:  }else if(E->mesh.toplayerbc < 0){ 
BC_util.c:243:    for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--) {
BC_util.c:244:      noz = E->lmesh.NOZ[lv];
BC_util.c:247:      if(lv == E->mesh.gridmax)
BC_util.c:248:        k = noz + E->mesh.toplayerbc;
BC_util.c:250:        k = noz + (int)((float)E->mesh.toplayerbc / pow(2.,(float)(E->mesh.gridmax-lv)));
BC_util.c:254:      ontop = ((k==noz) && (E->parallel.me_loc[3]==E->parallel.nprocz-1))?(1):(0);
BC_util.c:255:      onbottom = ((k==1) && (E->parallel.me_loc[3]==0))?(1):(0);
BC_util.c:256:      if((!ontop)&&(!onbottom)&&(lv==E->mesh.gridmax))
BC_util.c:258:      if(E->mesh.topvbc != 1) {	/* free slip */
BC_util.c:259:        internal_horizontal_bc(E,E->sphere.cap.VB,k,1,0.0,VBX,0,lv);
BC_util.c:261:          internal_horizontal_bc(E,E->sphere.cap.VB,k,3,0.0,VBZ,1,lv);
BC_util.c:262:        internal_horizontal_bc(E,E->sphere.cap.VB,k,2,0.0,VBY,0,lv);
BC_util.c:263:        internal_horizontal_bc(E,E->sphere.cap.VB,k,1,E->control.VBXtopval,SBX,1,lv);
BC_util.c:265:          internal_horizontal_bc(E,E->sphere.cap.VB,k,3,0.0,SBZ,0,lv);
BC_util.c:266:        internal_horizontal_bc(E,E->sphere.cap.VB,k,2,E->control.VBYtopval,SBY,1,lv);
BC_util.c:268:        internal_horizontal_bc(E,E->sphere.cap.VB,k,1,E->control.VBXtopval,VBX,1,lv);
BC_util.c:270:          internal_horizontal_bc(E,E->sphere.cap.VB,k,3,0.0,VBZ,1,lv);
BC_util.c:271:        internal_horizontal_bc(E,E->sphere.cap.VB,k,2,E->control.VBYtopval,VBY,1,lv);
BC_util.c:272:        internal_horizontal_bc(E,E->sphere.cap.VB,k,1,0.0,SBX,0,lv);
BC_util.c:274:          internal_horizontal_bc(E,E->sphere.cap.VB,k,3,0.0,SBZ,0,lv);
BC_util.c:275:        internal_horizontal_bc(E,E->sphere.cap.VB,k,2,0.0,SBY,0,lv);
BC_util.c:280:    if(E->control.ggrd.vtop_control)
BC_util.c:287:	    E->parallel.me,((E->parallel.me_loc[3]==0)&&(E->parallel.nprocz!=1))?("bottom"):
BC_util.c:288:	    ((E->parallel.me_loc[3]==E->parallel.nprocz-1)?("top"):("interior")),
BC_util.c:289:	    (E->mesh.topvbc!=1)?("stress"):("velocity"),ncount);
Checkpoints.c:58:    sprintf(output_file, "%s.chkpt.%d.%d", E->control.data_file,
Checkpoints.c:59:            E->parallel.me, E->monitor.solution_cycles);
Checkpoints.c:77:    if(E->control.tracer) {
Checkpoints.c:80:        if(E->composition.on)
Checkpoints.c:97:    snprintf(output_file, 254, "%s.chkpt.%d.%d", E->control.old_P_file,
Checkpoints.c:98:             E->parallel.me, E->monitor.solution_cycles_init);
Checkpoints.c:104:    if(E->parallel.me == 0)
Checkpoints.c:110:    /* init E->mat */
Checkpoints.c:120:    if(E->control.tracer) {
Checkpoints.c:121:      if(E->trace.ic_method_for_flavors == 99){
Checkpoints.c:122:	if(E->parallel.me == 0)
Checkpoints.c:126:        if(E->composition.on)
Checkpoints.c:182:    fwrite(&(E->lmesh.nox), sizeof(int), 1, fp);
Checkpoints.c:183:    fwrite(&(E->lmesh.noy), sizeof(int), 1, fp);
Checkpoints.c:184:    fwrite(&(E->lmesh.noz), sizeof(int), 1, fp);
Checkpoints.c:185:    fwrite(&(E->parallel.nprocx), sizeof(int), 1, fp);
Checkpoints.c:186:    fwrite(&(E->parallel.nprocy), sizeof(int), 1, fp);
Checkpoints.c:187:    fwrite(&(E->parallel.nprocz), sizeof(int), 1, fp);
Checkpoints.c:188:    fwrite(&(E->sphere.caps_per_proc), sizeof(int), 1, fp);
Checkpoints.c:191:    fwrite(&(E->monitor.solution_cycles), sizeof(int), 1, fp);
Checkpoints.c:192:    fwrite(&(E->monitor.elapsed_time), sizeof(float), 1, fp);
Checkpoints.c:193:    fwrite(&(E->advection.timestep), sizeof(float), 1, fp);
Checkpoints.c:194:    fwrite(&(E->control.start_age), sizeof(float), 1, fp);
Checkpoints.c:206:    if((tmp[0] != E->lmesh.nox) ||
Checkpoints.c:207:       (tmp[1] != E->lmesh.noy) ||
Checkpoints.c:208:       (tmp[2] != E->lmesh.noz) ||
Checkpoints.c:209:       (tmp[3] != E->parallel.nprocx) ||
Checkpoints.c:210:       (tmp[4] != E->parallel.nprocy) ||
Checkpoints.c:211:       (tmp[5] != E->parallel.nprocz) ||
Checkpoints.c:212:       (tmp[6] != E->sphere.caps_per_proc)) {
Checkpoints.c:215:                E->parallel.me);
Checkpoints.c:223:    tmp[0] = fread(&(E->monitor.solution_cycles), sizeof(int), 1, fp);
Checkpoints.c:224:    tmp[0]+= fread(&(E->monitor.elapsed_time), sizeof(float), 1, fp);
Checkpoints.c:225:    tmp[0]+= fread(&(E->advection.timestep), sizeof(float), 1, fp);
Checkpoints.c:226:    tmp[0]+= fread(&(E->control.start_age), sizeof(float), 1, fp);
Checkpoints.c:230:    E->advection.timesteps = E->monitor.solution_cycles;
Checkpoints.c:239:    fwrite(&(E->trace.number_of_basic_quantities), sizeof(int), 1, fp);
Checkpoints.c:240:    fwrite(&(E->trace.number_of_extra_quantities), sizeof(int), 1, fp);
Checkpoints.c:241:    fwrite(&(E->trace.nflavors), sizeof(int), 1, fp);
Checkpoints.c:242:    fwrite(&(E->trace.ilast_tracer_count), sizeof(int), 1, fp);
Checkpoints.c:244:    fwrite(&(E->trace.ntracers), sizeof(int), 1, fp);
Checkpoints.c:249:        fwrite(E->trace.basicq[i], sizeof(double), E->trace.ntracers+1, fp);
Checkpoints.c:250:    for(i=0; i<E->trace.number_of_extra_quantities; i++)
Checkpoints.c:251:        fwrite(E->trace.extraq[i], sizeof(double), E->trace.ntracers+1, fp);
Checkpoints.c:252:    fwrite(E->trace.ielement, sizeof(int), E->trace.ntracers+1, fp);
Checkpoints.c:262:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:265:    if( itmp != E->trace.number_of_basic_quantities ) {
Checkpoints.c:267:              E->parallel.me);
Checkpoints.c:273:    if (itmp != E->trace.number_of_extra_quantities) {
Checkpoints.c:275:              E->parallel.me);
Checkpoints.c:281:    if (itmp != E->trace.nflavors) {
Checkpoints.c:283:                E->parallel.me);
Checkpoints.c:289:    E->trace.ilast_tracer_count = itmp;
Checkpoints.c:294:    E->trace.ntracers = itmp;
Checkpoints.c:298:      fread(E->trace.basicq[i], sizeof(double), E->trace.ntracers+1, fp);
Checkpoints.c:299:    for(i=0; i<E->trace.number_of_extra_quantities; i++)
Checkpoints.c:300:      fread(E->trace.extraq[i], sizeof(double), E->trace.ntracers+1, fp);
Checkpoints.c:301:    fread(E->trace.ielement, sizeof(int), E->trace.ntracers+1, fp);
Checkpoints.c:303:    /* init E->trace.ntracer_flavor */
Checkpoints.c:313:    fwrite(&(E->composition.ncomp), sizeof(int), 1, fp);
Checkpoints.c:314:    fwrite(E->composition.bulk_composition, sizeof(double),
Checkpoints.c:315:           E->composition.ncomp, fp);
Checkpoints.c:316:    fwrite(E->composition.initial_bulk_composition, sizeof(double),
Checkpoints.c:317:           E->composition.ncomp, fp);
Checkpoints.c:319:    for(i=0; i<E->composition.ncomp; i++)
Checkpoints.c:320:      fwrite(E->composition.comp_el[i], sizeof(double), E->lmesh.nel+1, fp);
Checkpoints.c:329:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:332:    if (itmp != E->composition.ncomp) {
Checkpoints.c:334:              E->parallel.me);
Checkpoints.c:339:    fread(E->composition.bulk_composition, sizeof(double),
Checkpoints.c:340:          E->composition.ncomp, fp);
Checkpoints.c:342:    fread(E->composition.initial_bulk_composition, sizeof(double),
Checkpoints.c:343:          E->composition.ncomp, fp);
Checkpoints.c:345:    for(i=0; i<E->composition.ncomp; i++)
Checkpoints.c:346:      fread(E->composition.comp_el[i], sizeof(double), E->lmesh.nel+1, fp);
Checkpoints.c:348:    /* init E->composition.comp_node */
Checkpoints.c:352:    E->trace.istat_iempty = 0;
Checkpoints.c:354:    for (i=0; i<E->composition.ncomp; i++) {
Checkpoints.c:355:        E->composition.error_fraction[i] = E->composition.bulk_composition[i]
Checkpoints.c:356:        / E->composition.initial_bulk_composition[i] - 1.0;
Checkpoints.c:364:    fwrite(E->T, sizeof(double), E->lmesh.nno+1, fp);
Checkpoints.c:365:    fwrite(E->Tdot, sizeof(double), E->lmesh.nno+1, fp);
Checkpoints.c:370:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:372:    if(fread(E->T, sizeof(double), E->lmesh.nno+1, fp)!= E->lmesh.nno+1)
Checkpoints.c:374:    if(fread(E->Tdot, sizeof(double), E->lmesh.nno+1, fp)!=E->lmesh.nno+1)
Checkpoints.c:389:    fwrite(E->P, sizeof(double), E->lmesh.npno+1, fp);
Checkpoints.c:392:    fwrite(E->U, sizeof(double), E->lmesh.neq, fp);
Checkpoints.c:401:    int lev = E->mesh.levmax;
Checkpoints.c:404:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:411:    if(fread(E->P, sizeof(double), E->lmesh.npno+1, fp) !=  E->lmesh.npno+1)
Checkpoints.c:414:    if(fread(E->U, sizeof(double), E->lmesh.neq, fp) != E->lmesh.neq)
Checkpoints.c:417:    E->monitor.vdotv = global_v_norm2(E, E->U);
Checkpoints.c:418:    E->monitor.pdotp = global_p_norm2(E, E->P);
Checkpoints.c:423:    /* init E->NP */
Checkpoints.c:424:    p_to_nodes(E, E->P, E->NP, lev);
Citcom_init.c:45:  E->control.PID = get_process_identifier();
Citcom_init.c:46:  E->parallel.world = *world;
Citcom_init.c:47:  E->parallel.nproc = nproc;
Citcom_init.c:48:  E->parallel.me = rank;
Citcom_init.c:51:          rank, nproc, E, E->control.PID); */
Citcom_init.c:53:  E->monitor.solution_cycles=0;
Citcom_init.c:54:  E->control.keep_going=1;
Citcom_init.c:56:  E->control.total_iteration_cycles=0;
Citcom_init.c:57:  E->control.total_v_solver_calls=0;
Composition_related.c:47:    int m = E->parallel.me;
Composition_related.c:48:    input_boolean("CDEPV",&(E->viscosity.CDEPV),"off",m);
Composition_related.c:49:    E->composition.icompositional_rheology = E->viscosity.CDEPV;
Composition_related.c:52:		  &(E->composition.ichemical_buoyancy),
Composition_related.c:55:    if (E->control.tracer && 
Composition_related.c:56:	(E->composition.ichemical_buoyancy || 
Composition_related.c:57:	 E->composition.icompositional_rheology)) {
Composition_related.c:62:        input_int("buoy_type",&(E->composition.ibuoy_type),"1,0,nomax",m);
Composition_related.c:63:        /* if (E->composition.ibuoy_type!=1) {
Composition_related.c:69:        if (E->composition.ibuoy_type==0)
Composition_related.c:70:            E->composition.ncomp = E->trace.nflavors;
Composition_related.c:71:        else if (E->composition.ibuoy_type==1)
Composition_related.c:72:            E->composition.ncomp = E->trace.nflavors - 1;
Composition_related.c:74:        E->composition.buoyancy_ratio = (double*) malloc(E->composition.ncomp
Composition_related.c:78:        for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:79:            E->composition.buoyancy_ratio[i] = 1.0;
Composition_related.c:81:        input_double_vector("buoyancy_ratio", E->composition.ncomp,
Composition_related.c:82:                            E->composition.buoyancy_ratio,m);
Composition_related.c:96:    //E->composition.icompositional_rheology = 0;
Composition_related.c:101:              &(E->composition.icompositional_rheology),"1,0,nomax",m);
Composition_related.c:103:    if (E->composition.icompositional_rheology==1) {
Composition_related.c:105:                     &(E->composition.compositional_rheology_prefactor),
Composition_related.c:127:    if (E->composition.ichemical_buoyancy ||
Composition_related.c:128:        E->composition.icompositional_rheology)
Composition_related.c:129:        E->composition.on = 1;
Composition_related.c:131:    if (E->composition.on) {
Composition_related.c:133:        if (E->trace.nflavors < 1) {
Composition_related.c:134:            fprintf(E->trace.fpt, "Tracer flavors must be greater than 1 to track composition\n");
Composition_related.c:138:        if (!E->composition.ichemical_buoyancy)
Composition_related.c:139:	  fprintf(E->trace.fpt,"Passive Tracers\n");
Composition_related.c:141:	  fprintf(E->trace.fpt,"Active Tracers\n");
Composition_related.c:144:        if (E->composition.ibuoy_type==1)
Composition_related.c:145:	  fprintf(E->trace.fpt,"Ratio Method\n");
Composition_related.c:146:        if (E->composition.ibuoy_type==0)
Composition_related.c:147:	  fprintf(E->trace.fpt,"Absolute Method\n");
Composition_related.c:149:        for(k=0; k<E->composition.ncomp; k++) {
Composition_related.c:150:            fprintf(E->trace.fpt,"Buoyancy Ratio: %f\n", E->composition.buoyancy_ratio[k]);
Composition_related.c:154:        if (E->composition.icompositional_rheology==0) {
Composition_related.c:155:            fprintf(E->trace.fpt,"Compositional Rheology - OFF\n");
Composition_related.c:157:        else if (E->composition.icompositional_rheology>0) {
Composition_related.c:158:            fprintf(E->trace.fpt,"Compositional Rheology - ON\n");
Composition_related.c:159:            fprintf(E->trace.fpt,"Compositional Prefactor: %f\n",
Composition_related.c:160:            E->composition.compositional_rheology_prefactor);
Composition_related.c:164:        fflush(E->trace.fpt);
Composition_related.c:177:    if (E->composition.ibuoy_type==1) {
Composition_related.c:182:    if (E->composition.ibuoy_type==0) {
Composition_related.c:186:    /* if (E->composition.ibuoy_type!=1) {
Composition_related.c:187:        fprintf(E->trace.fpt,"Error(compute...)-only ratio method now\n");
Composition_related.c:188:        fflush(E->trace.fpt);
Composition_related.c:205:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:206:        E->composition.bulk_composition = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:207:        E->composition.initial_bulk_composition = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:208:        E->composition.error_fraction = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:213:    E->Have.C = (float **)malloc((E->composition.ncomp+1)*sizeof(float*));
Composition_related.c:214:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:215:        E->Have.C[i] = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Composition_related.c:220:    if ((E->composition.comp_el=(double **)malloc((E->composition.ncomp)*sizeof(double*)))==NULL) {
Composition_related.c:221:        fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8987y\n");
Composition_related.c:222:        fflush(E->trace.fpt);
Composition_related.c:225:    if ((E->composition.comp_node=(double **)malloc((E->composition.ncomp)*sizeof(double*)))==NULL) {
Composition_related.c:226:        fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8988y\n");
Composition_related.c:227:        fflush(E->trace.fpt);
Composition_related.c:231:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:232:        if ((E->composition.comp_el[i]=(double *)malloc((E->lmesh.nel+1)*sizeof(double)))==NULL) {
Composition_related.c:233:            fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8989y\n");
Composition_related.c:234:            fflush(E->trace.fpt);
Composition_related.c:238:        if ((E->composition.comp_node[i]=(double *)malloc((E->lmesh.nno+1)*sizeof(double)))==NULL) {
Composition_related.c:239:            fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 983rk\n");
Composition_related.c:240:            fflush(E->trace.fpt);
Composition_related.c:249:    if (E->composition.ibuoy_type==1) {
Composition_related.c:254:    if (E->composition.ibuoy_type==0) {
Composition_related.c:258:    /* if (E->composition.ibuoy_type!=1) {
Composition_related.c:259:        fprintf(E->trace.fpt,"Error(compute...)-only ratio method now\n");
Composition_related.c:260:        fflush(E->trace.fpt);
Composition_related.c:279:    if (E->composition.ibuoy_type == 1) {
Composition_related.c:280:        if (E->trace.istat_iempty) {
Composition_related.c:304:    for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:306:      for (flavor=0; flavor<E->trace.nflavors; flavor++)
Composition_related.c:307:        numtracers += E->trace.ntracer_flavor[flavor][e];
Composition_related.c:314:        /* fprintf(E->trace.fpt, "No tracer in element %d!\n", e); */
Composition_related.c:317:      for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:319:        E->composition.comp_el[i][e] = 
Composition_related.c:320:          E->trace.ntracer_flavor[flavor][e] / (double)numtracers;
Composition_related.c:327:      if ((1.0*iempty/E->lmesh.nel)>0.80) {
Composition_related.c:328:          fprintf(E->trace.fpt,"WARNING(compute_elemental...)-number of tracers is REALLY LOW\n");
Composition_related.c:329:          fflush(E->trace.fpt);
Composition_related.c:330:          if (E->trace.itracer_warnings) 
Composition_related.c:335:    E->trace.istat_iempty += iempty;
Composition_related.c:364:  for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:366:    for (flavor=0; flavor<E->trace.nflavors; flavor++)
Composition_related.c:367:        numtracers += E->trace.ntracer_flavor[flavor][e];
Composition_related.c:372:      for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:373:          E->composition.comp_el[i][e] = 0.0;
Composition_related.c:379:    for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:381:      comp = E->trace.ntracer_flavor[flavor][e] / E->eco[e].area
Composition_related.c:382:              * domain_volume / E->trace.number_of_tracers;
Composition_related.c:387:      E->composition.comp_el[i][e] = min(comp,one);
Composition_related.c:401:    for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:402:      for (kk=1;kk<=E->lmesh.nno;kk++)
Composition_related.c:403:        E->composition.comp_node[i][kk]=0.0;
Composition_related.c:407:    for (nelem=1;nelem<=E->lmesh.nel;nelem++) {
Composition_related.c:413:        n = E->ien[nelem].node[nodenum];
Composition_related.c:414:        for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:415:          E->composition.comp_node[i][n] +=
Composition_related.c:416:            E->composition.comp_el[i][nelem]*
Composition_related.c:417:            E->TWW[E->mesh.levmax][nelem].node[nodenum];
Composition_related.c:422:    for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:423:      tmp = E->composition.comp_node[i];
Composition_related.c:424:      (E->exchange_node_d)(E,tmp,E->mesh.levmax);
Composition_related.c:428:    for(i=0;i<E->composition.ncomp;i++)
Composition_related.c:429:      for (kk=1;kk<=E->lmesh.nno;kk++)
Composition_related.c:430:        E->composition.comp_node[i][kk] *= E->MASS[E->mesh.levmax][kk];
Composition_related.c:444:    fprintf(E->trace.fpt,"WARNING(check_initial_composition)-number of tracers is low, %d elements contain no tracer initially\n", E->trace.istat_iempty);
Composition_related.c:446:    fprintf(E->trace.fpt,"Using neighboring elements for initial composition...\n");
Composition_related.c:449:    nghbrs[0] = E->lmesh.elz;
Composition_related.c:450:    nghbrs[1] = -E->lmesh.elz;
Composition_related.c:451:    nghbrs[2] = E->lmesh.elz * E->lmesh.elx;
Composition_related.c:452:    nghbrs[3] = -E->lmesh.elz * E->lmesh.elx;
Composition_related.c:454:    is_empty = (int *)calloc(E->lmesh.nel+1, sizeof(int));
Composition_related.c:455:    sum = (double *)malloc(E->composition.ncomp * sizeof(double));
Composition_related.c:458:    for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:460:      for (flavor=0; flavor<E->trace.nflavors; flavor++)
Composition_related.c:461:        numtracers += E->trace.ntracer_flavor[flavor][e];
Composition_related.c:468:    for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:471:        for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:477:          if((ee>0) && (ee<=E->lmesh.nel) && (!is_empty[ee])) {
Composition_related.c:479:              for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:480:                sum[i] += E->composition.comp_el[i][ee];
Composition_related.c:485:          fprintf(E->trace.fpt,"Error(fill_composition_from_neighbors)-all neighboring elements are empty\n");
Composition_related.c:486:          fflush(E->trace.fpt);
Composition_related.c:490:        for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:491:          E->composition.comp_el[i][e] = sum[i] / count;
Composition_related.c:498:    fprintf(E->trace.fpt,"Done.\n");
Composition_related.c:499:    fflush(E->trace.fpt);
Composition_related.c:515:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:517:      tmp = E->composition.comp_node[i];
Composition_related.c:522:      E->composition.bulk_composition[i] = volume;
Composition_related.c:523:      E->composition.initial_bulk_composition[i] = volume;
Composition_related.c:537:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:539:      tmp = E->composition.comp_node[i];
Composition_related.c:544:      E->composition.bulk_composition[i] = volume;
Composition_related.c:546:      E->composition.error_fraction[i] = 
Composition_related.c:547:        (volume - E->composition.initial_bulk_composition[i]) / 
Composition_related.c:548:        E->composition.initial_bulk_composition[i];
Construct_arrays.c:51:  const int dims=E->mesh.nsd;
Construct_arrays.c:54:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:56:      elx = E->lmesh.ELX[lev];
Construct_arrays.c:57:      elz = E->lmesh.ELZ[lev];
Construct_arrays.c:58:      ely = E->lmesh.ELY[lev];
Construct_arrays.c:59:      nox = E->lmesh.NOX[lev];
Construct_arrays.c:60:      noz = E->lmesh.NOZ[lev];
Construct_arrays.c:61:      noy = E->lmesh.NOY[lev];
Construct_arrays.c:62:      nel=E->lmesh.NEL[lev];
Construct_arrays.c:63:      nno=E->lmesh.NNO[lev];
Construct_arrays.c:71:               E->IEN[lev][element].node[rr]= start
Construct_arrays.c:85:    for(element=1;element<=E->lmesh.nel;element++)
Construct_arrays.c:86:      if ( element%E->lmesh.elz==0) { /* top */
Construct_arrays.c:88:        E->sien[e].node[1] = E->ien[element].node[5]/E->lmesh.noz;
Construct_arrays.c:89:        E->sien[e].node[2] = E->ien[element].node[6]/E->lmesh.noz;
Construct_arrays.c:90:        E->sien[e].node[3] = E->ien[element].node[7]/E->lmesh.noz;
Construct_arrays.c:91:        E->sien[e].node[4] = E->ien[element].node[8]/E->lmesh.noz;
Construct_arrays.c:92:        E->surf_element[e] = element;
Construct_arrays.c:95:    E->lmesh.snel = e;
Construct_arrays.c:96:    for (i=1;i<=E->lmesh.nsf;i++)
Construct_arrays.c:97:      E->surf_node[i] = i*E->lmesh.noz;
Construct_arrays.c:100:  if(E->control.verbose) {
Construct_arrays.c:101:    for(e=1;e<=E->lmesh.snel;e++) {
Construct_arrays.c:102:      fprintf(E->fp_out, "sien sel=%d node=%d %d %d %d\n",
Construct_arrays.c:103:        e, E->sien[e].node[1], E->sien[e].node[2], 
Construct_arrays.c:104:        E->sien[e].node[3], E->sien[e].node[4]);
Construct_arrays.c:123:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:126:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)  {
Construct_arrays.c:129:      for(node=1;node<=E->lmesh.NNO[lev];node++)
Construct_arrays.c:131:          E->ID[lev][node].doff[doff] = eqn_count;
Construct_arrays.c:135:      E->lmesh.NEQ[lev] = eqn_count;
Construct_arrays.c:138:      for(node=1;node<=E->lmesh.NNO[lev];node++) {
Construct_arrays.c:139:        if (E->NODE[lev][node] & SKIP)
Construct_arrays.c:142:            E->parallel.Skip_id[lev][i] = E->ID[lev][node].doff[doff];
Construct_arrays.c:146:      E->parallel.Skip_neq[lev] = i;
Construct_arrays.c:149:      neq = E->lmesh.NEQ[lev] - E->parallel.Skip_neq[lev];
Construct_arrays.c:150:      MPI_Allreduce(&neq, &gneq, 1, MPI_INT, MPI_SUM, E->parallel.world);
Construct_arrays.c:151:      E->mesh.NEQ[lev] = gneq;
Construct_arrays.c:157:    E->lmesh.neq = E->lmesh.NEQ[E->mesh.levmax];
Construct_arrays.c:158:    E->mesh.neq = E->mesh.NEQ[E->mesh.levmax];
Construct_arrays.c:166:    const int nno=E->lmesh.NNO[level];
Construct_arrays.c:170:      if ( (E->NODE[level][i] & VBX) != 0 )  {
Construct_arrays.c:172:        E->zero_resid[level][j] = E->ID[level][i].doff[1];
Construct_arrays.c:174:      if ( (E->NODE[level][i] & VBY) != 0 )  {
Construct_arrays.c:176:        E->zero_resid[level][j] = E->ID[level][i].doff[2];
Construct_arrays.c:178:      if ( (E->NODE[level][i] & VBZ) != 0 )  {
Construct_arrays.c:180:        E->zero_resid[level][j] = E->ID[level][i].doff[3];
Construct_arrays.c:184:  E->num_zero_resid[level] = j;
Construct_arrays.c:197:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:214:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:219:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Construct_arrays.c:220:       neq=E->lmesh.NEQ[lev];
Construct_arrays.c:221:       nno=E->lmesh.NNO[lev];
Construct_arrays.c:222:       noxz = E->lmesh.NOX[lev]*E->lmesh.NOZ[lev];
Construct_arrays.c:223:       noz = E->lmesh.NOZ[lev];
Construct_arrays.c:224:       noy = E->lmesh.NOY[lev];
Construct_arrays.c:225:       nox = E->lmesh.NOX[lev];
Construct_arrays.c:229:       E->Node_map[lev]=(int *) malloc (matrix*sizeof(int));
Construct_arrays.c:232:         E->Node_map[lev][i] = neq;  /* neq indicates an invalid eqn # */
Construct_arrays.c:239:               E->Node_map[lev][(nn-1)*max_eqn+doff-1] = 
Construct_arrays.c:240:                 E->ID[lev][nn].doff[doff];
Construct_arrays.c:259:                       E->Node_map[lev][(nn-1)*max_eqn+ia*dims+doff-1] =
Construct_arrays.c:260:                         E->ID[lev][ja].doff[doff];
Construct_arrays.c:265:       E->Eqn_k1[lev] = 
Construct_arrays.c:267:       E->Eqn_k2[lev] = 
Construct_arrays.c:269:       E->Eqn_k3[lev] = 
Construct_arrays.c:272:       E->mesh.matrix_size[lev] = matrix;
Construct_arrays.c:274:       if(E->control.verbose) {
Construct_arrays.c:275:         fprintf(E->fp_out, "output Node_map lev=%d m=%d\n", lev, m);
Construct_arrays.c:276:         fprintf(E->fp_out, "neq=%d nno=%d max_eqn=%d matrix=%d\n", neq, nno, max_eqn, matrix);
Construct_arrays.c:278:           fprintf(E->fp_out, "%d %d\n", i, E->Node_map[lev][i]);
Construct_arrays.c:301:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:303:    const int lms=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:308:   for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--)   {
Construct_arrays.c:309:      neq=E->lmesh.NEQ[level];
Construct_arrays.c:310:      nel=E->lmesh.NEL[level];
Construct_arrays.c:311:      nno=E->lmesh.NNO[level];
Construct_arrays.c:313:        E->BI[level][i] = zero;
Construct_arrays.c:314:      for(i=0;i<E->mesh.matrix_size[level];i++) {
Construct_arrays.c:315:        E->Eqn_k1[level][i] = zero;
Construct_arrays.c:316:        E->Eqn_k2[level][i] = zero;
Construct_arrays.c:317:        E->Eqn_k3[level][i] = zero;
Construct_arrays.c:322:        if (E->control.augmented_Lagr)
Construct_arrays.c:327:	        node=E->IEN[level][element].node[i];
Construct_arrays.c:334:	       if(E->NODE[level][node] & VBX) w1=0.0;
Construct_arrays.c:335:	       if(E->NODE[level][node] & VBZ) w3=0.0;
Construct_arrays.c:336:	       if(E->NODE[level][node] & VBY) w2=0.0;
Construct_arrays.c:339:	         node1=E->IEN[level][element].node[j];
Construct_arrays.c:345:          eqn1=E->ID[level][node1].doff[1];
Construct_arrays.c:346:          eqn2=E->ID[level][node1].doff[2];
Construct_arrays.c:347:          eqn3=E->ID[level][node1].doff[3];
Construct_arrays.c:349:          if(E->NODE[level][node1] & VBX) 
Construct_arrays.c:351:          if(E->NODE[level][node1] & VBZ) 
Construct_arrays.c:353:          if(E->NODE[level][node1] & VBY) 
Construct_arrays.c:360:            if(E->Node_map[level][loc0+k] == eqn1) { 
Construct_arrays.c:369:          E->Eqn_k1[level][loc0+index] += w1*ww1*elt_K[pp*lms+qq]; /* dir 1 */
Construct_arrays.c:370:          E->Eqn_k2[level][loc0+index] += w2*ww1*elt_K[(pp+1)*lms+qq];/*dir 1*/
Construct_arrays.c:371:          E->Eqn_k3[level][loc0+index] += w3*ww1*elt_K[(pp+2)*lms+qq];/*dir 1*/
Construct_arrays.c:377:            if(E->Node_map[level][loc0+k] == eqn2) { 
Construct_arrays.c:386:          E->Eqn_k1[level][loc0+index] += w1*ww2*elt_K[pp*lms+qq+1];/*dir 1*/
Construct_arrays.c:387:          E->Eqn_k2[level][loc0+index] += w2*ww2*elt_K[(pp+1)*lms+qq+1];/*dir2*/
Construct_arrays.c:388:          E->Eqn_k3[level][loc0+index] += w3*ww2*elt_K[(pp+2)*lms+qq+1];/*dir3*/
Construct_arrays.c:394:            if(E->Node_map[level][loc0+k] == eqn3) { 
Construct_arrays.c:403:          E->Eqn_k1[level][loc0+index] += w1*ww3*elt_K[pp*lms+qq+2];/*dir 1*/
Construct_arrays.c:404:          E->Eqn_k2[level][loc0+index] += w2*ww3*elt_K[(pp+1)*lms+qq+2];/*dir2*/
Construct_arrays.c:405:          E->Eqn_k3[level][loc0+index] += w3*ww3*elt_K[(pp+2)*lms+qq+2];/*dir3*/
Construct_arrays.c:412:   (E->solver.exchange_id_d)(E, E->BI[level], level);
Construct_arrays.c:414:   neq=E->lmesh.NEQ[level];
Construct_arrays.c:417:      if(E->BI[level][j] ==0.0)  
Construct_arrays.c:418:        fprintf(stderr,"me= %d level %d, equation %d/%d has zero diagonal term\n",E->parallel.me,level,j,neq);
Construct_arrays.c:419:	    assert( E->BI[level][j] != 0 ); /* diagonal of matrix = 0 */
Construct_arrays.c:420:      E->BI[level][j]  = (double) 1.0/E->BI[level][j];
Construct_arrays.c:434:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:438:   for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--)   {
Construct_arrays.c:439:    for(j=0;j<=E->lmesh.NEQ[level];j++)
Construct_arrays.c:440:       E->temp[j]=0.0;
Construct_arrays.c:442:      for(i=1;i<=E->lmesh.NNO[level];i++)  {
Construct_arrays.c:443:        eqn1=E->ID[level][i].doff[1];
Construct_arrays.c:444:        eqn2=E->ID[level][i].doff[2];
Construct_arrays.c:445:        eqn3=E->ID[level][i].doff[3];
Construct_arrays.c:447:        C=E->Node_map[level] + (i-1)*max_eqn;
Construct_arrays.c:448:        B1=E->Eqn_k1[level]+(i-1)*max_eqn;
Construct_arrays.c:449:        B2=E->Eqn_k2[level]+(i-1)*max_eqn;
Construct_arrays.c:450:        B3=E->Eqn_k3[level]+(i-1)*max_eqn;
Construct_arrays.c:453:          E->temp[eqn1] += fabs(B1[j]);
Construct_arrays.c:454:          E->temp[eqn2] += fabs(B2[j]);
Construct_arrays.c:455:          E->temp[eqn3] += fabs(B3[j]);
Construct_arrays.c:459:          E->temp[C[j]] += fabs(B1[j]) + fabs(B2[j]) + fabs(B3[j]);
Construct_arrays.c:462:     (E->solver.exchange_id_d)(E, E->temp, level);
Construct_arrays.c:464:      for(i=0;i<E->lmesh.NEQ[level];i++)  {
Construct_arrays.c:465:        E->temp[i] = E->temp[i] - 1.0/E->BI[level][i];
Construct_arrays.c:467:      for(i=1;i<=E->lmesh.NNO[level];i++)
Construct_arrays.c:468:        if (E->NODE[level][i] & OFFSIDE) {
Construct_arrays.c:469:          eqn1=E->ID[level][i].doff[1];
Construct_arrays.c:470:          eqn2=E->ID[level][i].doff[2];
Construct_arrays.c:471:          eqn3=E->ID[level][i].doff[3];
Construct_arrays.c:472:          E->BI[level][eqn1] = (double) 1.0/E->temp[eqn1];
Construct_arrays.c:473:          E->BI[level][eqn2] = (double) 1.0/E->temp[eqn2];
Construct_arrays.c:474:          E->BI[level][eqn3] = (double) 1.0/E->temp[eqn3];
Construct_arrays.c:489:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Construct_arrays.c:490:      elz = E->lmesh.ELZ[lev];
Construct_arrays.c:491:      ely = E->lmesh.ELY[lev];
Construct_arrays.c:492:      noy = E->lmesh.NOY[lev];
Construct_arrays.c:493:      noz = E->lmesh.NOZ[lev];
Construct_arrays.c:494:      nno = E->lmesh.NNO[lev];
Construct_arrays.c:496:      if (E->parallel.me_loc[3]==0 )
Construct_arrays.c:497:        for (i=1;i<=E->parallel.NUM_NNO[lev].bound[5];i++) {
Construct_arrays.c:498:          node = E->parallel.NODE[lev][i].bound[5];
Construct_arrays.c:499:          E->NODE[lev][node] = E->NODE[lev][node] | TZEDGE;
Construct_arrays.c:501:      if ( E->parallel.me_loc[3]==E->parallel.nprocz-1 )
Construct_arrays.c:502:        for (i=1;i<=E->parallel.NUM_NNO[lev].bound[6];i++) {
Construct_arrays.c:503:          node = E->parallel.NODE[lev][i].bound[6];
Construct_arrays.c:504:          E->NODE[lev][node] = E->NODE[lev][node] | TZEDGE;
Construct_arrays.c:518:  for(lev=E->mesh.levmax-1;lev>=E->mesh.levmin;lev--) {
Construct_arrays.c:519:    elx = E->lmesh.ELX[lev];
Construct_arrays.c:520:	  elz = E->lmesh.ELZ[lev];
Construct_arrays.c:521:	  ely = E->lmesh.ELY[lev];
Construct_arrays.c:522:    nox = E->lmesh.NOX[lev];
Construct_arrays.c:523:    noy = E->lmesh.NOY[lev];
Construct_arrays.c:524:    noz = E->lmesh.NOZ[lev];
Construct_arrays.c:525:	  elz = E->lmesh.ELZ[lev];
Construct_arrays.c:526:	  ely = E->lmesh.ELY[lev];
Construct_arrays.c:529:    if (!E->control.NMULTIGRID)  {
Construct_arrays.c:531:      if (lev == E->mesh.levmax-1)
Construct_arrays.c:532:        elzu = E->lmesh.ELZ[E->mesh.levmax];
Construct_arrays.c:541:          for(l=1;l<=enodes[E->mesh.nsd];l++) {
Construct_arrays.c:542:            E->EL[lev][elt].sub[l] = eltu + offset[l].vector[0]
Construct_arrays.c:558:    const int dims=E->mesh.nsd;
Construct_arrays.c:559:    const int n=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:561:    for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Construct_arrays.c:563:	  for(el=1;el<=E->lmesh.NEL[lev];el++) {
Construct_arrays.c:564:	    get_elt_k(E,el,E->elt_k[lev][el].k,lev,0);
Construct_arrays.c:565:	    if (E->control.augmented_Lagr)
Construct_arrays.c:566:	        get_aug_k(E,el,E->elt_k[lev][el].k,lev);
Construct_arrays.c:567:      build_diagonal_of_K(E,el,E->elt_k[lev][el].k,lev);
Construct_arrays.c:570:    (E->solver.exchange_id_d)(E, E->BI[lev], lev);    /*correct BI   */
Construct_arrays.c:572:     for(j=0;j<E->lmesh.NEQ[lev];j++) {
Construct_arrays.c:573:        if(E->BI[lev][j] == 0.0)  
Construct_arrays.c:574:          fprintf(stderr,"me= %d level %d, equation %d/%d has zero diagonal term\n",E->parallel.me,lev,j,E->lmesh.NEQ[lev]);
Construct_arrays.c:575:          assert( E->BI[lev][j] != 0 ); /* diagonal of matrix = 0 */
Construct_arrays.c:576:          E->BI[lev][j]  = (double) 1.0/E->BI[lev][j];
Construct_arrays.c:586:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Construct_arrays.c:587:    for(el=1;el<=E->lmesh.NEL[lev];el++)
Construct_arrays.c:588:      get_elt_g(E,el,E->elt_del[lev][el].g,lev);
Construct_arrays.c:601:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Construct_arrays.c:602:    for(el=1;el<=E->lmesh.NEL[lev];el++)
Construct_arrays.c:603:      get_elt_c(E,el,E->elt_c[lev][el].c,lev);
Construct_arrays.c:620:  if (E->control.NMULTIGRID)
Construct_arrays.c:623:  if (E->control.NMULTIGRID || E->control.NASSEMBLE) {
Construct_arrays.c:632:  if (E->control.NMULTIGRID || (E->control.NASSEMBLE && !E->control.CONJ_GRAD))
Construct_arrays.c:643:if E->viscosity.z... set to Earth values, and old, num_mat=4 style is
Construct_arrays.c:659:  rl = r + E->sphere.ro;
Construct_arrays.c:661:  for(i = 0;i < E->viscosity.num_mat;i++)
Construct_arrays.c:662:    if(r > (E->sphere.ro - E->viscosity.zbase_layer[i])){
Construct_arrays.c:674:  return(layers_r(E,E->sx[3][node]));
Construct_arrays.c:685:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:688:  if(E->viscosity.layer_control) {
Construct_arrays.c:691:    for(el=1;el<=E->lmesh.nel;el++) {
Construct_arrays.c:693:      nz = ((el-1) % E->lmesh.elz) + 1;
Construct_arrays.c:694:      E->mat[el] = E->mesh.elz - (nz + E->lmesh.ezs) + 1;
Construct_arrays.c:697:    for(el=1;el<=E->lmesh.nel;el++) {
Construct_arrays.c:698:      E->mat[el] = 1;
Construct_arrays.c:699:      nodea = E->ien[el].node[2];
Construct_arrays.c:702:        E->mat[el] = llayer;
Convection.c:47:    E->control.CONVECTION = 1;
Convection.c:49:    E->advection.timestep = 0.0;
Convection.c:50:    E->advection.timesteps = 0;
Convection.c:51:    E->advection.temp_iterations = 2; /* petrov-galerkin iterations: minimum value. */
Convection.c:52:    E->advection.total_timesteps = 1;
Convection.c:53:    E->advection.sub_iterations = 1;
Convection.c:54:    E->advection.last_sub_iterations = 1;
Convection.c:55:    E->advection.gamma = 0.5;
Convection.c:56:    E->advection.dt_reduced = 1.0;
Convection.c:58:    E->monitor.T_maxvaried = 1.05;
Convection.c:60:    E->next_buoyancy_field = PG_timestep;
Convection.c:61:    E->next_buoyancy_field_init = PG_timestep_init;
Convection.c:62:    E->special_process_new_buoyancy = twiddle_thumbs;
Convection.c:63:    E->problem_settings = read_convection_settings;
Convection.c:64:    E->problem_derived_values = convection_derived_values;
Convection.c:65:    E->problem_allocate_vars = convection_allocate_memory;
Convection.c:66:    E->problem_boundary_conds = convection_boundary_conditions;
Convection.c:67:    E->problem_initial_fields = convection_initial_fields;
Convection.c:68:    E->problem_update_node_positions = twiddle_thumbs;
Convection.c:69:    E->problem_update_bcs = twiddle_thumbs;
Convection.c:127:    (E->solver.velocity_boundary_conditions)(E);      /* universal */
Convection.c:128:    (E->solver.temperature_boundary_conditions)(E);
Determine_net_rotation.c:70:  const int dims = E->mesh.nsd;
Determine_net_rotation.c:79:  elz = E->lmesh.elz;elx = E->lmesh.elx;ely = E->lmesh.ely;
Determine_net_rotation.c:105:    lnode[1] = E->ien[el].node[1];
Determine_net_rotation.c:106:    lnode[2] = E->ien[el].node[2];
Determine_net_rotation.c:107:    lnode[3] = E->ien[el].node[3];
Determine_net_rotation.c:108:    lnode[4] = E->ien[el].node[4];
Determine_net_rotation.c:110:    for(nint=1;nint <= onedvpoints[E->mesh.nsd];nint++) {
Determine_net_rotation.c:111:      for(d=1;d <= onedvpoints[E->mesh.nsd];d++) {
Determine_net_rotation.c:112:	      vtmp = E->M.vpt[GMVINDEX(d,nint)] * dGamma.vpt[GMVGAMMA(0,nint)];
Determine_net_rotation.c:113:	      x[0] += E->x[1][lnode[d]] * vtmp; /* coords */
Determine_net_rotation.c:114:	      x[1] += E->x[2][lnode[d]] * vtmp;
Determine_net_rotation.c:115:	      x[2] += E->x[3][lnode[d]] * vtmp;
Determine_net_rotation.c:117:        v[0] += E->sphere.cap.V[1][lnode[d]] * vtmp; /* theta */
Determine_net_rotation.c:118:        v[1] += E->sphere.cap.V[2][lnode[d]] * vtmp; /* phi */
Determine_net_rotation.c:123:      lnode[1] = E->ien[el].node[5];
Determine_net_rotation.c:124:      lnode[2] = E->ien[el].node[6];
Determine_net_rotation.c:125:      lnode[3] = E->ien[el].node[7];
Determine_net_rotation.c:126:      lnode[4] = E->ien[el].node[8];
Determine_net_rotation.c:128:      for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Determine_net_rotation.c:129:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++){
Determine_net_rotation.c:130:          vtmp = E->M.vpt[GMVINDEX(d,nint)] * dGamma.vpt[GMVGAMMA(1,nint)];
Determine_net_rotation.c:131:          x[0] += E->x[1][lnode[d]] * vtmp; /* coords */
Determine_net_rotation.c:132:          x[1] += E->x[2][lnode[d]] * vtmp;
Determine_net_rotation.c:133:          x[2] += E->x[3][lnode[d]] * vtmp;
Determine_net_rotation.c:135:          v[0] += E->sphere.cap.V[1][lnode[d]] * vtmp;
Determine_net_rotation.c:136:          v[1] += E->sphere.cap.V[2][lnode[d]] * vtmp;
Determine_net_rotation.c:154:  MPI_Allreduce(coef,acoef,elz9,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Determine_net_rotation.c:159:  rr = E->sx[3][E->ien[elz].node[5]] - E->sx[3][E->ien[1].node[1]];
Determine_net_rotation.c:168:    r1 = E->sx[3][E->ien[i+1].node[1]]; 
Determine_net_rotation.c:169:    r2 = E->sx[3][E->ien[i+1].node[5]];
Determine_net_rotation.c:187:  if(E->parallel.me == 0)
Determine_net_rotation.c:342://   ADDED BY -OrbData-, AND NODE-VELOCITY OUTPUT FROM -SHELLS-,
Drive_solvers.c:45:  if (E->control.NMULTIGRID || E->control.NASSEMBLE)
Drive_solvers.c:48:    for (i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Drive_solvers.c:49:      E->elt_k[i]=(struct EK *)malloc((E->lmesh.NEL[i]+1)*sizeof(struct EK));
Drive_solvers.c:67:  const int neq = E->lmesh.neq;
Drive_solvers.c:69:  E->monitor.visc_iter_count = 0; /* first solution */
Drive_solvers.c:71:  velocities_conform_bcs(E,E->U);
Drive_solvers.c:75:    get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:92:    E->monitor.visc_iter_count++;
Drive_solvers.c:96:      delta_U[i] = E->U[i] - oldU[i];
Drive_solvers.c:97:      oldU[i] = E->U[i];
Drive_solvers.c:100:    Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:101:    dUdot_mag = vnorm_nonnewt(E,delta_U,oldU,E->mesh.levmax);
Drive_solvers.c:104:      if(E->parallel.me==0){
Drive_solvers.c:106:		dUdot_mag,Udot_mag,E->monitor.visc_iter_count);
Drive_solvers.c:107:	fprintf(E->fp,"Stress dep. visc./plast.: DUdot = %.4e (%.4e) for iteration %d\n",
Drive_solvers.c:108:		dUdot_mag,Udot_mag,E->monitor.visc_iter_count);
Drive_solvers.c:109:	fflush(E->fp);
Drive_solvers.c:111:      if ((E->monitor.visc_iter_count > 50) || 
Drive_solvers.c:112:	  (dUdot_mag < E->viscosity.sdepv_misfit))
Drive_solvers.c:115:      get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:119:      E->monitor.visc_iter_count++;
Drive_solvers.c:129:  if((E->sphere.caps == 12) &&
Drive_solvers.c:130:     (E->control.remove_rigid_rotation || E->control.remove_angular_momentum)) {
Drive_solvers.c:137:  if(E->viscosity.update_allowed){
Drive_solvers.c:142:    if(E->control.restart){	
Drive_solvers.c:145:      if(E->monitor.solution_cycles ==  E->monitor.solution_cycles_init + 1)
Drive_solvers.c:151:      if(E->monitor.solution_cycles == 0)
Drive_solvers.c:159:  if((E->control.force_iteration) && (E->monitor.solution_cycles == 0)){
Drive_solvers.c:164:  if(E->viscosity.allow_anisotropic_viscosity){
Drive_solvers.c:165:    if(E->viscosity.anivisc_start_from_iso) /* first step will be
Drive_solvers.c:170:      return (E->viscosity.SDEPV || E->viscosity.PDEPV)?(1):(0);
Drive_solvers.c:174:  return ((E->viscosity.SDEPV || E->viscosity.PDEPV)?(1):(0));
Drive_solvers.c:196:  const int neq = E->lmesh.neq;
Drive_solvers.c:198:  velocities_conform_bcs(E,E->U);
Drive_solvers.c:200:  E->monitor.stop_topo_loop = 0;
Drive_solvers.c:201:  E->monitor.topo_loop = 0;
Drive_solvers.c:202:  if(E->monitor.solution_cycles==0) std_timestep(E);
Drive_solvers.c:203:  while(E->monitor.stop_topo_loop == 0) {
Drive_solvers.c:206:	    get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:211:	  if (E->viscosity.SDEPV || E->viscosity.PDEPV) {
Drive_solvers.c:224:          delta_U[i] = E->U[i] - oldU[i];
Drive_solvers.c:225:          oldU[i] = E->U[i];
Drive_solvers.c:228:			  Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:229:			  dUdot_mag = vnorm_nonnewt(E,delta_U,oldU,E->mesh.levmax);
Drive_solvers.c:231:			  if(E->parallel.me==0){
Drive_solvers.c:234:                              fprintf(E->fp,"Stress dep. visc./plast.: DUdot = %.4e (%.4e) for iteration %d\n",
Drive_solvers.c:236:				  fflush(E->fp);
Drive_solvers.c:239:			  if (count>50 || dUdot_mag<E->viscosity.sdepv_misfit)
Drive_solvers.c:242:			  get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:253:	  E->monitor.topo_loop++;
Drive_solvers.c:257:  if((E->sphere.caps == 12) &&
Drive_solvers.c:258:     (E->control.remove_rigid_rotation || E->control.remove_angular_momentum)) {
Drive_solvers.c:262:  get_STD_freesurf(E,E->slice.freesurf);
Element_calculations.c:54:  const int dims=E->mesh.nsd;
Element_calculations.c:55:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:59:    node = E->ien[e].node[a];
Element_calculations.c:61:    a1=E->id[node].doff[1];
Element_calculations.c:62:    E->F[a1] += elt_f[p];
Element_calculations.c:63:    a2=E->id[node].doff[2];
Element_calculations.c:64:    E->F[a2] += elt_f[p+1];
Element_calculations.c:65:    a3=E->id[node].doff[3];
Element_calculations.c:66:    E->F[a3] += elt_f[p+2];
Element_calculations.c:87:  const int neq=E->lmesh.neq;
Element_calculations.c:88:  const int nel=E->lmesh.nel;
Element_calculations.c:89:  const int lev=E->mesh.levmax;
Element_calculations.c:91:  get_buoyancy(E,E->buoyancy);
Element_calculations.c:94:    E->F[a] = 0.0;
Element_calculations.c:102:  for(i=1; i<=E->boundary.nel; i++) {
Element_calculations.c:103:    e = E->boundary.element[i];
Element_calculations.c:107:      if(E->control.pseudo_free_surf)
Element_calculations.c:115:  (E->solver.exchange_id_d)(E, E->F, lev);
Element_calculations.c:116:  strip_bcs_from_residual(E,E->F,lev);
Element_calculations.c:118:  /* compute the norm of E->F */
Element_calculations.c:119:  E->monitor.fdotf = sqrt(global_vdot(E, E->F, E->F, lev));
Element_calculations.c:121:  if(E->parallel.me==0) {
Element_calculations.c:122:    fprintf(stderr, "Momentum equation force %.9e\n", E->monitor.fdotf);
Element_calculations.c:123:    fprintf(E->fp, "Momentum equation force %.9e\n", E->monitor.fdotf);
Element_calculations.c:284:    const int nn=loc_mat_size[E->mesh.nsd];
Element_calculations.c:287:    const int dims=E->mesh.nsd;
Element_calculations.c:296:    if (iconv || (el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:297:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,0);
Element_calculations.c:304:      W[k]=g_point[k].weight[dims-1]*E->GDA[lev][el].vpt[k]*E->EVI[lev][off];
Element_calculations.c:306:      if(E->viscosity.allow_anisotropic_viscosity){
Element_calculations.c:309:           E->EVIn1[lev][off], E->EVIn2[lev][off], 
Element_calculations.c:310:           E->EVIn3[lev][off], E->EVI2[lev][off],E->avmode[lev][off],
Element_calculations.c:316:    get_ba(&(E->N), &(E->GNX[lev][el]), &E->element_Cc, &E->element_Ccx,
Element_calculations.c:317:           rtf, E->mesh.nsd, ba);
Element_calculations.c:326:      if(E->viscosity.allow_anisotropic_viscosity){
Element_calculations.c:341:        if(E->control.inv_gruneisen != 0)
Element_calculations.c:360:        if(E->control.inv_gruneisen != 0)
Element_calculations.c:412:  if(E->control.NMULTIGRID||E->control.NASSEMBLE)
Element_calculations.c:431:  const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:432:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:433:  const int dims=E->mesh.nsd;
Element_calculations.c:434:  const int nel=E->lmesh.NEL[level];
Element_calculations.c:435:  const int neq=E->lmesh.NEQ[level];
Element_calculations.c:442:      ii = E->IEN[level][e].node[a];
Element_calculations.c:443:      a1 = E->ID[level][ii].doff[1];
Element_calculations.c:444:      a2 = E->ID[level][ii].doff[2];
Element_calculations.c:445:      a3 = E->ID[level][ii].doff[3];
Element_calculations.c:447:	      nodeb = E->IEN[level][e].node[b];
Element_calculations.c:452:          E->elt_k[level][e].k[ii+0] * u[E->ID[level][nodeb].doff[1]] + 
Element_calculations.c:453:          E->elt_k[level][e].k[ii+1] * u[E->ID[level][nodeb].doff[2]] + 
Element_calculations.c:454:          E->elt_k[level][e].k[ii+2] * u[E->ID[level][nodeb].doff[3]];
Element_calculations.c:457:          E->elt_k[level][e].k[ii+n+0] * u[E->ID[level][nodeb].doff[1]] + 
Element_calculations.c:458:          E->elt_k[level][e].k[ii+n+1] * u[E->ID[level][nodeb].doff[2]] + 
Element_calculations.c:459:          E->elt_k[level][e].k[ii+n+2] * u[E->ID[level][nodeb].doff[3]];
Element_calculations.c:462:          E->elt_k[level][e].k[ii+n+n+0] * u[E->ID[level][nodeb].doff[1]] + 
Element_calculations.c:463:          E->elt_k[level][e].k[ii+n+n+1] * u[E->ID[level][nodeb].doff[2]] + 
Element_calculations.c:464:          E->elt_k[level][e].k[ii+n+n+2] * u[E->ID[level][nodeb].doff[3]];
Element_calculations.c:469:  (E->solver.exchange_id_d)(E, Au, level);
Element_calculations.c:491:    const int neq=E->lmesh.NEQ[level];
Element_calculations.c:492:    const int nno=E->lmesh.NNO[level];
Element_calculations.c:493:    const int dims=E->mesh.nsd;
Element_calculations.c:502:       eqn1=E->ID[level][e].doff[1];
Element_calculations.c:503:       eqn2=E->ID[level][e].doff[2];
Element_calculations.c:504:       eqn3=E->ID[level][e].doff[3];
Element_calculations.c:510:       C=E->Node_map[level] + (e-1)*max_eqn;
Element_calculations.c:511:       B1=E->Eqn_k1[level]+(e-1)*max_eqn;
Element_calculations.c:512:       B2=E->Eqn_k2[level]+(e-1)*max_eqn;
Element_calculations.c:513:       B3=E->Eqn_k3[level]+(e-1)*max_eqn;
Element_calculations.c:526:     (E->solver.exchange_id_d)(E, Au, level);
Element_calculations.c:538:    const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:539:    const int dims=E->mesh.nsd;
Element_calculations.c:540:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:543:	    node=E->IEN[level][el].node[a];
Element_calculations.c:545:	    a1 = E->ID[level][node].doff[1];
Element_calculations.c:547:	    E->BI[level][a1] += elt_k[p*n+p];
Element_calculations.c:550:	    a2 = E->ID[level][node].doff[2];
Element_calculations.c:552:	    E->BI[level][a2] += elt_k[p*n+p];
Element_calculations.c:555:	    a1 = E->ID[level][node].doff[3];
Element_calculations.c:557:	    E->BI[level][a1] += elt_k[p*n+p];
Element_calculations.c:568:  for (level=E->mesh.gridmin;level<=E->mesh.gridmax;level++)
Element_calculations.c:569:    npno = E->lmesh.NPNO[level];
Element_calculations.c:570:    neq=E->lmesh.NEQ[level];
Element_calculations.c:573:      E->BPI[level][e]=1.0;
Element_calculations.c:575:    if(!E->control.precondition)
Element_calculations.c:581:        E->BPI[level][e] = 1.0/BU;
Element_calculations.c:583:        E->BPI[level][e] = 1.0;
Element_calculations.c:598:    const int nel = E->lmesh.NEL[level];
Element_calculations.c:599:    const int ends = enodes[E->mesh.nsd];
Element_calculations.c:600:    const int dims = E->mesh.nsd;
Element_calculations.c:601:    const int npno = E->lmesh.NPNO[level];
Element_calculations.c:606:        b = E->IEN[level][e].node[a];
Element_calculations.c:607:        j1= E->ID[level][b].doff[1];
Element_calculations.c:608:        j2= E->ID[level][b].doff[2];
Element_calculations.c:609:        j3= E->ID[level][b].doff[3];
Element_calculations.c:610:        result[e] += E->elt_c[level][e].c[p  ][0] * U[j1]
Element_calculations.c:611:                   + E->elt_c[level][e].c[p+1][0] * U[j2]
Element_calculations.c:612:                   + E->elt_c[level][e].c[p+2][0] * U[j3];
Element_calculations.c:641:  const int nel=E->lmesh.NEL[level];
Element_calculations.c:642:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:643:  const int dims=E->mesh.nsd;
Element_calculations.c:644:  const int npno=E->lmesh.NPNO[level];
Element_calculations.c:652:	    b = E->IEN[level][e].node[a];
Element_calculations.c:653:	    j1= E->ID[level][b].doff[1];
Element_calculations.c:654:      j2= E->ID[level][b].doff[2];
Element_calculations.c:655:	    j3= E->ID[level][b].doff[3];
Element_calculations.c:656:	    divU[e] += E->elt_del[level][e].g[p  ][0] * U[j1]
Element_calculations.c:657:              +  E->elt_del[level][e].g[p+1][0] * U[j2]
Element_calculations.c:658:              +  E->elt_del[level][e].g[p+2][0] * U[j3];
Element_calculations.c:673:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:674:  const int dims=E->mesh.nsd;
Element_calculations.c:677:  nel=E->lmesh.NEL[lev];
Element_calculations.c:678:  neq=E->lmesh.NEQ[lev];
Element_calculations.c:690:      b = E->IEN[lev][e].node[a];
Element_calculations.c:691:      j1= E->ID[lev][b].doff[1];
Element_calculations.c:692:      j2= E->ID[lev][b].doff[2];
Element_calculations.c:693:      j3= E->ID[lev][b].doff[3];
Element_calculations.c:694:      /*for(b=0;b<ploc_mat_size[E->mesh.nsd];b++)  */
Element_calculations.c:695:      gradP[j1] += E->elt_del[lev][e].g[p  ][0] * P[e];
Element_calculations.c:696:      gradP[j2] += E->elt_del[lev][e].g[p+1][0] * P[e];
Element_calculations.c:697:      gradP[j3] += E->elt_del[lev][e].g[p+2][0] * P[e];
Element_calculations.c:701:  (E->solver.exchange_id_d)(E, gradP,  lev); /*  correct gradP   */
Element_calculations.c:717:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:718:    const int dims=E->mesh.nsd;
Element_calculations.c:720:    npno=E->lmesh.NPNO[level];
Element_calculations.c:729:      node = E->IEN[level][e].node[a];
Element_calculations.c:730:      j=E->ID[level][node].doff[1];
Element_calculations.c:731:      gradP[p] += E->BI[level][j]*E->elt_del[level][e].g[p][0];
Element_calculations.c:733:      j=E->ID[level][node].doff[2];
Element_calculations.c:734:      gradP[p+1] += E->BI[level][j]*E->elt_del[level][e].g[p+1][0];
Element_calculations.c:736:      j=E->ID[level][node].doff[3];
Element_calculations.c:737:      gradP[p+2] += E->BI[level][j]*E->elt_del[level][e].g[p+2][0];
Element_calculations.c:750:      divU +=E->elt_del[level][e].g[p][0] * gradP[p];
Element_calculations.c:751:      divU +=E->elt_del[level][e].g[p+1][0] * gradP[p+1];
Element_calculations.c:752:      divU +=E->elt_del[level][e].g[p+2][0] * gradP[p+2];
Element_calculations.c:771:    const int dims = E->mesh.nsd;
Element_calculations.c:774:    if ((el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:775:        construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,1);
Element_calculations.c:777:    temp = p_point[1].weight[dims-1] * E->GDA[lev][el].ppt[1];
Element_calculations.c:779:    switch (E->refstate.choice) {
Element_calculations.c:784:        beta = - E->control.disptn_number * E->control.inv_gruneisen;
Element_calculations.c:788:                x[i] = E->N.ppt[GNPINDEX(a,1)]
Element_calculations.c:789:                    * E->element_Cc.ppt[BPINDEX(3,i,a,1)];
Element_calculations.c:801:            j = E->IEN[lev][el].node[a];
Element_calculations.c:802:            nz = (j - 1) % E->lmesh.noz + 1;
Element_calculations.c:803:            rho[a] = E->refstate.rho[nz];
Element_calculations.c:814:                x[i] = rho[a] * E->GNX[lev][el].ppt[GNPXINDEX(2,a,1)]
Element_calculations.c:815:                    * E->N.ppt[GNPINDEX(a,1)]
Element_calculations.c:816:                    * E->element_Cc.ppt[BPINDEX(3,i,a,1)];
Element_calculations.c:852:   const int dims=E->mesh.nsd;
Element_calculations.c:857:   if ((el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:858:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,1);
Element_calculations.c:862:   temp = p_point[1].weight[dims-1] * E->GDA[lev][el].ppt[1];
Element_calculations.c:865:   if(E->viscosity.allow_anisotropic_viscosity && modify_g){
Element_calculations.c:875:			E->EVIn1[lev][off], E->EVIn2[lev][off], E->EVIn3[lev][off],
Element_calculations.c:876:			E->EVI2[lev][off],E->avmode[lev][off],
Element_calculations.c:882:     get_ba_p(&(E->N),&(E->GNX[lev][el]),&E->element_Cc, &E->element_Ccx,rtf,E->mesh.nsd,ba);
Element_calculations.c:909:	 x[i] = E->GNX[lev][el].ppt[GNPXINDEX(2,a,1)] * E->element_Cc.ppt[BPINDEX(3,i,a,1)] + 
Element_calculations.c:910:	   2.0 * ra * E->N.ppt[GNPINDEX(a,1)]*E->element_Cc.ppt[BPINDEX(3,i,a,1)] + 
Element_calculations.c:912:	   (E->GNX[lev][el].ppt[GNPXINDEX(0,a,1)]*E->element_Cc.ppt[BPINDEX(1,i,a,1)] +
Element_calculations.c:913:	    E->N.ppt[GNPINDEX(a,1)]*E->element_Ccx.ppt[BPXINDEX(1,i,1,a,1)] +
Element_calculations.c:914:	    ct * E->N.ppt[GNPINDEX(a,1)] * E->element_Cc.ppt[BPINDEX(1,i,a,1)] +
Element_calculations.c:915:	    si * (E->GNX[lev][el].ppt[GNPXINDEX(1,a,1)] * E->element_Cc.ppt[BPINDEX(2,i,a,1)] +
Element_calculations.c:916:		  E->N.ppt[GNPINDEX(a,1)] * E->element_Ccx.ppt[BPXINDEX(2,i,2,a,1)]));
Element_calculations.c:922:      /* fprintf (E->fp,"B= %d %d %g %g %g %g %g\n",el,a,E->GDA[lev][el].ppt[1],E->GNX[lev][el].ppt[GNPXINDEX(0,a,1)],E->GNX[lev][el].ppt[GNPXINDEX(1,a,1)],elt_del[p][0],elt_del[p+1][0]);
Element_calculations.c:950:  const int dims=E->mesh.nsd;
Element_calculations.c:955:  es = (el-1)/E->lmesh.elz + 1;
Element_calculations.c:957:  if ((el-1)%E->lmesh.elz==0)
Element_calculations.c:958:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,E->mesh.levmax,0);
Element_calculations.c:963:    force[p] = E->buoyancy[E->ien[el].node[p]];
Element_calculations.c:968:      force_at_gs[j] += force[k] * E->N.vpt[GNVINDEX(k,j)] ;
Element_calculations.c:973:      nodea=E->ien[el].node[a];
Element_calculations.c:977:        elt_f[p] += force_at_gs[j] * E->N.vpt[GNVINDEX(a,j)]
Element_calculations.c:978:           *E->gDA[el].vpt[j]*g_point[j].weight[dims-1]
Element_calculations.c:979:           *E->element_Cc.vpt[BVINDEX(3,i,a,j)];
Element_calculations.c:988:            nodeb=E->ien[el].node[b];
Element_calculations.c:989:            if ((E->node[nodeb]&type)&&(E->sphere.cap.VB[j][nodeb]!=0.0)){
Element_calculations.c:991:                get_elt_k(E,el,elt_k,E->mesh.levmax,1);
Element_calculations.c:996:                elt_f[p] -= elt_k[p*n+q] * E->sphere.cap.VB[j][nodeb];
Element_calculations.c:1020:	const int dims=E->mesh.nsd;
Element_calculations.c:1031:	int el = E->boundary.element[bel];
Element_calculations.c:1035:	const float rho = E->data.density;
Element_calculations.c:1036:	const float g = E->data.grav_acc;
Element_calculations.c:1038:	const float eta = E->data.ref_viscosity;
Element_calculations.c:1039:	const float kappa = E->data.therm_diff;
Element_calculations.c:1043:	if(E->control.side_sbcs)
Element_calculations.c:1045:			nodea = E->ien[el].node[ sidenodes[side][a] ];
Element_calculations.c:1047:				value = E->sbc.SB[side][d][ E->sbc.node[nodea] ];
Element_calculations.c:1048:				flagged = (E->node[nodea] & sbc_flag[d]) && (value);
Element_calculations.c:1057:				nodea = E->ien[el].node[ sidenodes[side][a] ];
Element_calculations.c:1059:					value = E->sphere.cap.VB[d][nodea];
Element_calculations.c:1060:					flagged = (E->node[nodea] & sbc_flag[d]) && (value);
Element_calculations.c:1074:				     E->mesh.levmax,0,side);
Element_calculations.c:1080:				traction_at_gs[d][k] += traction[d][j] * E->M.vpt[GMVINDEX(j,k)] ;
Element_calculations.c:1092:				elt_tr[p] += tmp * E->M.vpt[GMVINDEX(j,k)]
Element_calculations.c:1093:					* E->boundary.det[side][k][bel] * g_1d[k].weight[dims-1];
Element_calculations.c:1104:	const int dims=E->mesh.nsd;
Element_calculations.c:1115:	int el = E->boundary.element[bel];
Element_calculations.c:1119:	const float rho = E->data.density;
Element_calculations.c:1120:	const float g = E->data.grav_acc;
Element_calculations.c:1122:	const float eta = E->data.ref_viscosity;
Element_calculations.c:1123:	const float kappa = E->data.therm_diff;
Element_calculations.c:1127:	if(E->control.side_sbcs)
Element_calculations.c:1129:			nodea = E->ien[el].node[ sidenodes[side][a] ];
Element_calculations.c:1131:				value = E->sbc.SB[side][d][ E->sbc.node[nodea] ];
Element_calculations.c:1132:				flagged = (E->node[nodea] & sbc_flag[d]) && (value);
Element_calculations.c:1138:		if( side == SIDE_TOP && E->parallel.me_loc[3]==E->parallel.nprocz-1 && (el%E->lmesh.elz==0)) {
Element_calculations.c:1140:				nodea = E->ien[el].node[ sidenodes[side][a] ];
Element_calculations.c:1141:				nodeas = E->ien[el].node[ sidenodes[side][a] ]/E->lmesh.noz;
Element_calculations.c:1145:					*(E->slice.freesurf[nodeas]+E->sphere.cap.V[3][nodea]*E->advection.timestep);
Element_calculations.c:1146:				if(E->parallel.me==11 && nodea==3328)
Element_calculations.c:1147:					fprintf(stderr,"traction=%e vnew=%e timestep=%e coeff=%e\n",traction[3][a],E->sphere.cap.V[3][nodea],E->advection.timestep,-1.0*factor*rho*g*(R*R*R)/(eta*kappa));
Element_calculations.c:1150:				if(found && E->parallel.me==1)
Element_calculations.c:1152:						E->parallel.me,bel,el,side,SIDE_TOP,a,sidenodes[side][a],
Element_calculations.c:1153:						E->ien[el].node[ sidenodes[side][a] ],E->lmesh.noz,
Element_calculations.c:1161:				nodea = E->ien[el].node[ sidenodes[side][a] ];
Element_calculations.c:1163:					value = E->sphere.cap.VB[d][nodea];
Element_calculations.c:1164:					flagged = (E->node[nodea] & sbc_flag[d]) && (value);
Element_calculations.c:1177:	construct_side_c3x3matrix_el(E,el,&Cc,&Ccx,E->mesh.levmax,0,side);
Element_calculations.c:1183:				traction_at_gs[d][k] += traction[d][j] * E->M.vpt[GMVINDEX(j,k)] ;
Element_calculations.c:1195:				elt_tr[p] += tmp * E->M.vpt[GMVINDEX(j,k)]
Element_calculations.c:1196:					* E->boundary.det[side][k][bel] * g_1d[k].weight[dims-1];
Element_calculations.c:1214:     const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:1215:     const int ends=enodes[E->mesh.nsd];
Element_calculations.c:1216:     const int vpts=vpoints[E->mesh.nsd];
Element_calculations.c:1217:     const int dims=E->mesh.nsd;
Element_calculations.c:1222:	  Visc += E->EVI[level][(el-1)*vpts+a];
Element_calculations.c:1227:        nodea=E->IEN[level][el].node[a];
Element_calculations.c:1229:           nodeb=E->IEN[level][el].node[b];      /* for Kab dims*dims  */
Element_calculations.c:1231:	   elt_k[i  ] += Visc*E->control.augmented*
Element_calculations.c:1232:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:1233:		      E->elt_del[level][el].g[p[b]][0];   /*for 11 */
Element_calculations.c:1234:	   elt_k[i+1] += Visc*E->control.augmented*
Element_calculations.c:1235:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:1236:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 12 */
Element_calculations.c:1237:	   elt_k[i+n] += Visc*E->control.augmented*
Element_calculations.c:1238:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:1239:		      E->elt_del[level][el].g[p[b]][0];    /* for 21 */
Element_calculations.c:1240:	   elt_k[i+n+1] += Visc*E->control.augmented*
Element_calculations.c:1241:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:1242:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 22 */
Element_calculations.c:1245:	       elt_k[i+2] += Visc*E->control.augmented*
Element_calculations.c:1246:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:1247:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 13 */
Element_calculations.c:1248:	       elt_k[i+n+2] += Visc*E->control.augmented*
Element_calculations.c:1249:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:1250:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 23 */
Element_calculations.c:1251:	       elt_k[i+n+n] += Visc*E->control.augmented*
Element_calculations.c:1252:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:1253:		      E->elt_del[level][el].g[p[b]][0];    /* for 31 */
Element_calculations.c:1254:	       elt_k[i+n+n+1] += Visc*E->control.augmented*
Element_calculations.c:1255:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:1256:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 32 */
Element_calculations.c:1257:	       elt_k[i+n+n+2] += Visc*E->control.augmented*
Element_calculations.c:1258:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:1259:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 33 */
Full_boundary_conditions.c:57:  for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
Full_boundary_conditions.c:58:    noz = E->mesh.NOZ[lv];
Full_boundary_conditions.c:59:    if(E->mesh.topvbc != 1) {	/* free slip top */
Full_boundary_conditions.c:60:    horizontal_bc(E,E->sphere.cap.VB,noz,1,0.0,VBX,0,lv);
Full_boundary_conditions.c:61:    horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,VBZ,1,lv);
Full_boundary_conditions.c:62:    horizontal_bc(E,E->sphere.cap.VB,noz,2,0.0,VBY,0,lv);
Full_boundary_conditions.c:63:    horizontal_bc(E,E->sphere.cap.VB,noz,1,E->control.VBXtopval,SBX,1,lv);
Full_boundary_conditions.c:64:    horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,SBZ,0,lv);
Full_boundary_conditions.c:65:    horizontal_bc(E,E->sphere.cap.VB,noz,2,E->control.VBYtopval,SBY,1,lv);
Full_boundary_conditions.c:68:    if((lv==E->mesh.gridmax) && E->control.ggrd.vtop_control)
Full_boundary_conditions.c:73:    if(E->mesh.botvbc != 1) {	/* free slip bottom */
Full_boundary_conditions.c:74:      horizontal_bc(E,E->sphere.cap.VB,1,1,0.0,VBX,0,lv);
Full_boundary_conditions.c:75:      horizontal_bc(E,E->sphere.cap.VB,1,3,0.0,VBZ,1,lv);
Full_boundary_conditions.c:76:      horizontal_bc(E,E->sphere.cap.VB,1,2,0.0,VBY,0,lv);
Full_boundary_conditions.c:77:      horizontal_bc(E,E->sphere.cap.VB,1,1,E->control.VBXbotval,SBX,1,lv);
Full_boundary_conditions.c:78:      horizontal_bc(E,E->sphere.cap.VB,1,3,0.0,SBZ,0,lv);
Full_boundary_conditions.c:79:      horizontal_bc(E,E->sphere.cap.VB,1,2,E->control.VBYbotval,SBY,1,lv);
Full_boundary_conditions.c:82:    if(E->mesh.topvbc == 1) {	/* velocity/no slip BC */
Full_boundary_conditions.c:83:      horizontal_bc(E,E->sphere.cap.VB,noz,1,E->control.VBXtopval,VBX,1,lv);
Full_boundary_conditions.c:84:      horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,VBZ,1,lv);
Full_boundary_conditions.c:85:      horizontal_bc(E,E->sphere.cap.VB,noz,2,E->control.VBYtopval,VBY,1,lv);
Full_boundary_conditions.c:86:      horizontal_bc(E,E->sphere.cap.VB,noz,1,0.0,SBX,0,lv);
Full_boundary_conditions.c:87:      horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,SBZ,0,lv);
Full_boundary_conditions.c:88:      horizontal_bc(E,E->sphere.cap.VB,noz,2,0.0,SBY,0,lv);
Full_boundary_conditions.c:91:      if((lv==E->mesh.gridmax) && E->control.ggrd.vtop_control)
Full_boundary_conditions.c:94:      if(E->control.vbcs_file){ /* this should either only be called
Full_boundary_conditions.c:98:        if(lv == E->mesh.gridmin)
Full_boundary_conditions.c:103:    if(E->mesh.botvbc == 1) {	/* velocity bottom BC */
Full_boundary_conditions.c:104:      horizontal_bc(E,E->sphere.cap.VB,1,1,E->control.VBXbotval,VBX,1,lv);
Full_boundary_conditions.c:105:      horizontal_bc(E,E->sphere.cap.VB,1,3,0.0,VBZ,1,lv);
Full_boundary_conditions.c:106:      horizontal_bc(E,E->sphere.cap.VB,1,2,E->control.VBYbotval,VBY,1,lv);
Full_boundary_conditions.c:107:      horizontal_bc(E,E->sphere.cap.VB,1,1,0.0,SBX,0,lv);
Full_boundary_conditions.c:108:      horizontal_bc(E,E->sphere.cap.VB,1,3,0.0,SBZ,0,lv);
Full_boundary_conditions.c:109:      horizontal_bc(E,E->sphere.cap.VB,1,2,0.0,SBY,0,lv);
Full_boundary_conditions.c:112:    if(E->control.side_sbcs)
Full_boundary_conditions.c:126:  lev = E->mesh.levmax;
Full_boundary_conditions.c:127:  noz = E->mesh.noz;
Full_boundary_conditions.c:128:  if(E->mesh.toptbc == 1) {
Full_boundary_conditions.c:129:    horizontal_bc(E,E->sphere.cap.TB,noz,3,E->control.TBCtopval,TBZ,1,lev);
Full_boundary_conditions.c:130:    horizontal_bc(E,E->sphere.cap.TB,noz,3,E->control.TBCtopval,FBZ,0,lev);
Full_boundary_conditions.c:131:    if(E->control.tbcs_file)
Full_boundary_conditions.c:134:    horizontal_bc(E,E->sphere.cap.TB,noz,3,E->control.TBCtopval,TBZ,0,lev);
Full_boundary_conditions.c:135:    horizontal_bc(E,E->sphere.cap.TB,noz,3,E->control.TBCtopval,FBZ,1,lev);
Full_boundary_conditions.c:138:  if(E->mesh.bottbc == 1) {
Full_boundary_conditions.c:139:    horizontal_bc(E,E->sphere.cap.TB,1,3,E->control.TBCbotval,TBZ,1,lev);
Full_boundary_conditions.c:140:    horizontal_bc(E,E->sphere.cap.TB,1,3,E->control.TBCbotval,FBZ,0,lev);
Full_boundary_conditions.c:142:    horizontal_bc(E,E->sphere.cap.TB,1,3,E->control.TBCbotval,TBZ,0,lev);
Full_boundary_conditions.c:143:    horizontal_bc(E,E->sphere.cap.TB,1,3,E->control.TBCbotval,FBZ,1,lev);
Full_boundary_conditions.c:146:  if(E->control.lith_age_time==1)  {
Full_boundary_conditions.c:155:  E->temperatures_conform_bcs = temperatures_conform_bcs;
Full_boundary_conditions.c:165:  if(dirn > E->mesh.nsd)
Full_boundary_conditions.c:171:      rowl = E->lmesh.NOZ[level];
Full_boundary_conditions.c:173:  if ( ( (ROW==1) && (E->parallel.me_loc[3]==0) ) ||
Full_boundary_conditions.c:174:       ( (ROW==E->mesh.NOZ[level]) && (E->parallel.me_loc[3]==E->parallel.nprocz-1) ) ) {
Full_boundary_conditions.c:178:      for(j=1;j<=E->lmesh.NOY[level];j++)
Full_boundary_conditions.c:179:    	for(i=1;i<=E->lmesh.NOX[level];i++)     {
Full_boundary_conditions.c:180:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Full_boundary_conditions.c:181:    	  E->NODE[level][node] = E->NODE[level][node] & (~ mask);
Full_boundary_conditions.c:187:      for(j=1;j<=E->lmesh.NOY[level];j++)
Full_boundary_conditions.c:188:        for(i=1;i<=E->lmesh.NOX[level];i++)       {
Full_boundary_conditions.c:189:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Full_boundary_conditions.c:190:    	  E->NODE[level][node] = E->NODE[level][node] | (mask);
Full_boundary_conditions.c:191:    	  if(level==E->mesh.levmax)   /* NB */
Full_boundary_conditions.c:205:  fprintf(E->fp,"Periodic boundary conditions\n");
Full_boundary_conditions.c:213: fprintf(E->fp,"Periodic temperature boundary conditions\n");
Full_geometry_cartesian.c:38:  E->mesh.nsd = 2;
Full_geometry_cartesian.c:39:  E->mesh.dof = 2;
Full_geometry_cartesian.c:48:  E->mesh.nsd = 2;
Full_geometry_cartesian.c:49:  E->mesh.dof = 3;
Full_geometry_cartesian.c:57:  E->mesh.nsd = 3;
Full_geometry_cartesian.c:58:  E->mesh.dof = 3;
Full_geometry_cartesian.c:65:  E->mesh.nsd = 3;
Full_geometry_cartesian.c:66:  E->mesh.dof = 3;
Full_geometry_cartesian.c:68:  E->sphere.caps = 12;
Full_geometry_cartesian.c:69:  E->sphere.max_connections = 6;
Full_obsolete.c:46:  E->parallel.me = 0;
Full_obsolete.c:47:  E->parallel.nproc = 1;
Full_obsolete.c:48:  E->parallel.me_loc[1] = 0;
Full_obsolete.c:49:  E->parallel.me_loc[2] = 0;
Full_obsolete.c:50:  E->parallel.me_loc[3] = 0;
Full_obsolete.c:53:  MPI_Comm_rank(E->parallel.world, &(E->parallel.me) );
Full_obsolete.c:54:  MPI_Comm_size(E->parallel.world, &(E->parallel.nproc) );
Full_obsolete.c:78: const int dims = E->mesh.nsd;
Full_obsolete.c:86: if (E->parallel.nprocz==1)  {
Full_obsolete.c:87:    if (E->parallel.me==0) fprintf(stderr,"scatter_to_nlayer should not be called\n");
Full_obsolete.c:92:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:94:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:96:   SD = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Full_obsolete.c:99:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:101:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:110:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:111:    if (E->parallel.me==rootid)
Full_obsolete.c:112:      for (d=0;d<E->parallel.nprocz;d++)  {
Full_obsolete.c:114:        for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:115:          k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:116:          for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:117:            for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:118:              node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:119:              node1= k1+ (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c:127:           MPI_Send(SD,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],rootid,E->parallel.world);
Full_obsolete.c:130:           for (i=0;i<E->lmesh.NEQ[lev];i++)
Full_obsolete.c:134:        MPI_Recv(AUo[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,rootid,E->parallel.world,&status);
Full_obsolete.c:149: const int dims = E->mesh.nsd;
Full_obsolete.c:157: if (E->parallel.nprocz==1)  {
Full_obsolete.c:158:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:163:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:165:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:167:   RV = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Full_obsolete.c:170:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:172:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:181:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:182:    if (E->parallel.me!=rootid)
Full_obsolete.c:183:       MPI_Send(AUi[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:185:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:187:	   MPI_Recv(RV,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:189:           for (node=0;node<E->lmesh.NEQ[lev];node++)
Full_obsolete.c:192:         for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:193:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:194:           for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:195:             for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:196:               node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:197:               node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c:225: if (E->parallel.nprocz==1)  {
Full_obsolete.c:226:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:231:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:232:   NNO = NOZ*E->lmesh.NOX[lev]*E->lmesh.NOY[lev];
Full_obsolete.c:234:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:235:   RV = (float *)malloc((E->lmesh.NNO[lev]+2)*sizeof(float));
Full_obsolete.c:238:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:240:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:249:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:250:    if (E->parallel.me!=rootid) {
Full_obsolete.c:251:       MPI_Send(AUi[m],E->lmesh.NNO[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:256:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:258:           MPI_Recv(RV,E->lmesh.NNO[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:260:	   for (node=1;node<=E->lmesh.NNO[lev];node++)
Full_obsolete.c:263:         for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:264:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:265:           for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:266:             for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:267:               node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:268:               node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c:293: if (E->parallel.nprocz==1)  {
Full_obsolete.c:294:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:299:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz;
Full_obsolete.c:300:   NNO = NOZ*E->lmesh.ELX[lev]*E->lmesh.ELY[lev];
Full_obsolete.c:302:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:303:   RV = (float *)malloc((E->lmesh.NEL[lev]+2)*sizeof(float));
Full_obsolete.c:306:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:308:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:317:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:318:    if (E->parallel.me!=rootid) {
Full_obsolete.c:319:       MPI_Send(AUi[m],E->lmesh.NEL[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:324:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:326:           MPI_Recv(RV,E->lmesh.NEL[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:328:	   for (e=1;e<=E->lmesh.NEL[lev];e++)
Full_obsolete.c:331:         for (k=1;k<=E->lmesh.ELZ[lev];k++)   {
Full_obsolete.c:332:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:333:           for (j=1;j<=E->lmesh.ELY[lev];j++)
Full_obsolete.c:334:             for (i=1;i<=E->lmesh.ELX[lev];i++)   {
Full_obsolete.c:335:               e = k + (i-1)*E->lmesh.ELZ[lev] + (j-1)*E->lmesh.ELZ[lev]*E->lmesh.ELX[lev];
Full_obsolete.c:336:               e1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.ELX[lev];
Full_obsolete.c:363: if (E->parallel.nprocxy==1)   return;
Full_obsolete.c:365: nsl = E->sphere.nsf+1;
Full_obsolete.c:366: me = E->parallel.me;
Full_obsolete.c:370:   for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:371:     RG[i] = ( float *)malloc((E->sphere.nsf+1)*sizeof(float));
Full_obsolete.c:376: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:377:   to_everyone = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Full_obsolete.c:382:     MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c:388: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:389:   from_proc = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Full_obsolete.c:393:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c:399: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:400:   for (j=1;j<=E->sphere.nsf; j++)  {
Full_obsolete.c:423: if (E->parallel.nprocz==1)   return;
Full_obsolete.c:425: jumpp = E->sphere.hindice;
Full_obsolete.c:426: nsl = E->sphere.hindice*2;
Full_obsolete.c:427: me = E->parallel.me;
Full_obsolete.c:430: if (E->parallel.me_loc[3]==dest_proc)
Full_obsolete.c:433: for (i=0;i<E->sphere.hindice;i++)   {
Full_obsolete.c:439: if (E->parallel.me_loc[3]!=dest_proc)    {  /* send TG */
Full_obsolete.c:440:     to_proc = E->parallel.me_sph*E->parallel.nprocz+E->parallel.nprocz-1;
Full_obsolete.c:442:     MPI_Send(TG,nsl,MPI_FLOAT,to_proc,mst,E->parallel.world);
Full_obsolete.c:447: if (E->parallel.me_loc[3]==dest_proc)  {
Full_obsolete.c:448:   for (i=1;i<E->parallel.nprocz;i++) {
Full_obsolete.c:451:      MPI_Recv(RG,nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&status1);
Full_obsolete.c:453:      for (j=0;j<E->sphere.hindice;j++)   {
Full_obsolete.c:461: if (E->parallel.me_loc[3]==dest_proc)
Full_obsolete.c:482: if (E->parallel.nprocxy==1)   return;
Full_obsolete.c:484: nsl = E->sphere.hindice*2;
Full_obsolete.c:485: me = E->parallel.me;
Full_obsolete.c:487: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:492: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:493:   to_everyone = E->parallel.nprocz*(i-1) + loc_proc;
Full_obsolete.c:498:     MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c:504: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:505:   from_proc = E->parallel.nprocz*(i-1) + loc_proc;
Full_obsolete.c:509:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c:515: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:521: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:536:  i = cases[E->sphere.caps_per_proc];
Full_obsolete.c:538:  E->parallel.nproc_sph[1] = incases3[i].xy[0];
Full_obsolete.c:539:  E->parallel.nproc_sph[2] = incases3[i].xy[1];
Full_obsolete.c:541:  E->sphere.lelx = E->sphere.elx/E->parallel.nproc_sph[1];
Full_obsolete.c:542:  E->sphere.lely = E->sphere.ely/E->parallel.nproc_sph[2];
Full_obsolete.c:543:  E->sphere.lsnel = E->sphere.lely*E->sphere.lelx;
Full_obsolete.c:544:  E->sphere.lnox = E->sphere.lelx + 1;
Full_obsolete.c:545:  E->sphere.lnoy = E->sphere.lely + 1;
Full_obsolete.c:546:  E->sphere.lnsf = E->sphere.lnox*E->sphere.lnoy;
Full_obsolete.c:548:  for (i=0;i<=E->parallel.nprocz-1;i++)
Full_obsolete.c:549:    if (E->parallel.me_loc[3] == i)    {
Full_obsolete.c:550:      E->parallel.me_sph = (E->parallel.me-i)/E->parallel.nprocz;
Full_obsolete.c:551:      E->parallel.me_loc_sph[1] = E->parallel.me_sph%E->parallel.nproc_sph[1];
Full_obsolete.c:552:      E->parallel.me_loc_sph[2] = E->parallel.me_sph/E->parallel.nproc_sph[1];
Full_obsolete.c:555:  E->sphere.lexs = E->sphere.lelx * E->parallel.me_loc_sph[1];
Full_obsolete.c:556:  E->sphere.leys = E->sphere.lely * E->parallel.me_loc_sph[2];
Full_obsolete.c:577:    record_h = E->control.record_every;
Full_obsolete.c:579:    if ( (ii == 0) || ((ii % record_h) == 0) || E->control.DIRECTII)    {
Full_obsolete.c:585:    if ( ((ii == 0) || ((ii % E->control.record_every) == 0))
Full_obsolete.c:586:	 || E->control.DIRECTII)     {
Full_obsolete.c:610:  int lev = E->mesh.levmax;
Full_obsolete.c:616:  const int nno = E->lmesh.nno;
Full_obsolete.c:617:  const int nsd = E->mesh.nsd;
Full_obsolete.c:622:/*       ii = E->lmesh.nsf; */
Full_obsolete.c:623:/*       m = (E->parallel.me_loc[3]==0)?ii:0; */
Full_obsolete.c:626:      /* size2 = (E->lmesh.nel+1)*sizeof(float); */
Full_obsolete.c:629:  sprintf(output_file,"%s.coord.%d",E->control.data_file,E->parallel.me);
Full_obsolete.c:632:     fprintf(E->fp,"(Output.c #1) Cannot open %s\n",output_file);
Full_obsolete.c:635:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:636:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:637:    for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:638:      fprintf(fp1,"%.3e %.3e %.3e\n",E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Full_obsolete.c:646:  sprintf(output_file,"%s.visc.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:648:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:649:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:650:    for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:651:      fprintf(fp1,"%.3e\n",E->VI[lev][j][i]);
Full_obsolete.c:656:  sprintf(output_file,"%s.velo.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:658:  fprintf(fp1,"%d %d %.5e\n",file_number,E->lmesh.nno,E->monitor.elapsed_time);
Full_obsolete.c:659:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:660:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:661:     for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:662:       fprintf(fp1,"%.6e %.6e %.6e %.6e\n",E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],E->sphere.cap[j].V[3][i],E->T[j][i]);
Full_obsolete.c:663:     /* for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:664:	fprintf(fp1,"%.6e\n",E->T[j][i]); */
Full_obsolete.c:669:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)      {
Full_obsolete.c:670:    sprintf(output_file,"%s.surf.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:672:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Full_obsolete.c:673:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Full_obsolete.c:674:      for(i=1;i<=E->lmesh.nsf;i++)   {
Full_obsolete.c:675:	s = i*E->lmesh.noz;
Full_obsolete.c:676:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpg[j][i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Full_obsolete.c:683:  if (E->parallel.me_loc[3]==0)      {
Full_obsolete.c:684:    sprintf(output_file,"%s.botm.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:686:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Full_obsolete.c:687:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Full_obsolete.c:688:      for(i=1;i<=E->lmesh.nsf;i++)  {
Full_obsolete.c:689:	s = (i-1)*E->lmesh.noz + 1;
Full_obsolete.c:690:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Full_obsolete.c:698:/*   if (E->parallel.me<E->parallel.nprocz)  { */
Full_obsolete.c:699:/*     sprintf(output_file,"%s.ave_r.%d.%d",E->control.data_file,E->parallel.me,file_number); */
Full_obsolete.c:701:/*     for(j=1;j<=E->lmesh.noz;j++)  { */
Full_obsolete.c:702:/*         fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]); */
Full_obsolete.c:736:  size2= (E->lmesh.nno+1)*sizeof(float);
Full_obsolete.c:738:  sprintf(output_file,"%s.%05d.SZZ",E->control.data_file,file_number);
Full_obsolete.c:762:  if (E->parallel.me==proc_loc)  {
Full_obsolete.c:764:     sprintf(output_file,"%s.%s_intp",E->control.data_file,filen);
Full_obsolete.c:766:     for (i=E->sphere.nox;i>=1;i--)
Full_obsolete.c:767:     for (j=1;j<=E->sphere.noy;j++)  {
Full_obsolete.c:768:        node = i + (j-1)*E->sphere.nox;
Full_obsolete.c:769:        t = 90-E->sphere.sx[1][node]*rad;
Full_obsolete.c:770:        f = E->sphere.sx[2][node]*rad;
Full_obsolete.c:776:     fprintf(E->fp,"lmaxx=%.4e lminx=%.4e for %s\n",maxx,minx,filen);
Full_obsolete.c:779:     sprintf(output_file,"%s.%s_sharm",E->control.data_file,filen);
Full_obsolete.c:783:     for (ll=0;ll<=E->output.llmax;ll++)
Full_obsolete.c:785:        i = E->sphere.hindex[ll][mm];
Full_obsolete.c:828:	    E->trace.Have_C=(double *)malloc((E->lmesh.noz+2)*sizeof(double));
Full_obsolete.c:829:	    E->trace.Havel_tracers=(double *)malloc((E->lmesh.elz+2)*sizeof(double));
Full_obsolete.c:836:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_obsolete.c:838:	    reltrac[j]=(double *) malloc((E->lmesh.nel+1)*sizeof(double));
Full_obsolete.c:839:	    for (kk=1;kk<=E->lmesh.nel;kk++)
Full_obsolete.c:841:		    reltrac[j][kk]=(1.0*E->composition.ieltrac[j][kk]);
Full_obsolete.c:845:    return_elementwise_horiz_ave(E,reltrac,E->trace.Havel_tracers);
Full_obsolete.c:847:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_obsolete.c:852:    if (E->parallel.me<E->parallel.nprocz)
Full_obsolete.c:854:	    sprintf(output_file,"%s.ave_tracers.%d.%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Full_obsolete.c:856:	    for(kk=1;kk<=E->lmesh.elz;kk++)
Full_obsolete.c:858:		    halfpoint=0.5*(E->sx[1][3][kk+1]+E->sx[1][3][kk]);
Full_obsolete.c:859:		    fprintf(fp2,"%.4e %.4e\n",halfpoint,E->trace.Havel_tracers[kk]);
Full_obsolete.c:866:    if (E->composition.chemical_buoyancy==1)
Full_obsolete.c:868:	    return_horiz_ave(E,E->composition.comp_node,E->trace.Have_C);
Full_obsolete.c:871:	    if (E->parallel.me<E->parallel.nprocz)
Full_obsolete.c:873:		    sprintf(output_file,"%s.ave_c.%d.%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Full_obsolete.c:875:		    for(kk=1;kk<=E->lmesh.noz;kk++)
Full_obsolete.c:877:			    fprintf(fp2,"%.4e %.4e\n",E->sx[1][3][kk],E->trace.Have_C[kk]);
Full_obsolete.c:913:    fprintf(E->trace.fpt,"ERROR(icheck_regular_neighbors)-this subroutine is no longer used !\n");
Full_obsolete.c:914:    fflush(E->trace.fpt);
Full_obsolete.c:925:                    if ( (new_ntheta>0)&&(new_ntheta<=E->trace.numtheta[j])&&(new_nphi>0)&&(new_nphi<=E->trace.numphi[j]) )
Full_obsolete.c:927:                            iregel=new_ntheta+(new_nphi-1)*E->trace.numtheta[j];
Full_obsolete.c:928:                            if ((iregel>0) && (iregel<=E->trace.numregel[j]))
Full_obsolete.c:970:    fprintf(E->trace.fpt,"ERROR(iquick element)-this routine is no longer used!\n");
Full_obsolete.c:971:    fflush(E->trace.fpt);
Full_obsolete.c:978:      fprintf(E->trace.fpt,"AA: ichoice: %d\n",ichoice);
Full_obsolete.c:979:      fflush(E->trace.fpt);
Full_obsolete.c:987:      iregnode[3]=iregel+nphi+E->trace.numtheta[j]+1;
Full_obsolete.c:988:      iregnode[4]=iregel+nphi+E->trace.numtheta[j];
Full_obsolete.c:992:    itemp2=itemp1+E->trace.numtheta[j];
Full_obsolete.c:1001:            if ((iregnode[kk]<1) || (iregnode[kk]>E->trace.numregnodes[j]) )
Full_obsolete.c:1003:                    fprintf(E->trace.fpt,"ERROR(iquick)-weird regnode %d\n",iregnode[kk]);
Full_obsolete.c:1004:                    fflush(E->trace.fpt);
Full_obsolete.c:1015:            if (E->trace.regnodetoel[j][iregnode[kk]]<=0) goto next_corner;
Full_obsolete.c:1020:                    if (E->trace.regnodetoel[j][iregnode[kk]]==E->trace.regnodetoel[j][iregnode[pp]]) goto next_corner;
Full_obsolete.c:1023:            imap[ichoice]=E->trace.regnodetoel[j][iregnode[kk]];
Full_obsolete.c:1034:    E->trace.istat_ichoice[j][ichoice]++;
Full_parallel_related.c:53:  me = E->parallel.me;
Full_parallel_related.c:55:  if ( E->parallel.nprocx != E->parallel.nprocy ) {
Full_parallel_related.c:56:    if (E->parallel.me==0) 
Full_parallel_related.c:61:  surf_proc_per_cap = E->parallel.nprocx * E->parallel.nprocy;
Full_parallel_related.c:62:  proc_per_cap = surf_proc_per_cap * E->parallel.nprocz;
Full_parallel_related.c:63:  total_proc = E->sphere.caps * proc_per_cap;
Full_parallel_related.c:64:  E->parallel.total_surf_proc = E->sphere.caps * surf_proc_per_cap;
Full_parallel_related.c:66:  if ( total_proc != E->parallel.nproc ) {
Full_parallel_related.c:67:    if (E->parallel.me==0) 
Full_parallel_related.c:68:      fprintf(stderr,"!!!! # of requested CPU is incorrect (expected: %i got: %i)\n", total_proc, E->parallel.nproc);
Full_parallel_related.c:72:    //max(1,E->sphere.caps*E->parallel.nprocz/E->parallel.nproc);
Full_parallel_related.c:78:  E->parallel.me_loc[3] = (me - cap_id_surf*proc_per_cap) % E->parallel.nprocz;
Full_parallel_related.c:81:  E->parallel.me_loc[1] = ((me - cap_id_surf*proc_per_cap - E->parallel.me_loc[3])/E->parallel.nprocz) % E->parallel.nprocx;
Full_parallel_related.c:84:  E->parallel.me_loc[2] = ((((me - cap_id_surf*proc_per_cap - E->parallel.me_loc[3])/E->parallel.nprocz) - E->parallel.me_loc[1])/E->parallel.nprocx) % E->parallel.nprocy;
Full_parallel_related.c:90:  the second oordinate as fi, which goes E-W. Here we use R-L as the first
Full_parallel_related.c:96:  [xyz] is x=E->parallel.me_loc[1],y=E->parallel.me_loc[2],z=E->parallel.me_loc[3]
Full_parallel_related.c:104:  E->sphere.capid = incases1[1].links[temp]; /* id (1~12) of the current cap */
Full_parallel_related.c:109:    E->sphere.max_connections = 8;
Full_parallel_related.c:113:  E->parallel.loc2proc_map = 
Full_parallel_related.c:114:    (int ****) malloc(E->sphere.caps*sizeof(int ***));
Full_parallel_related.c:115:  for (m=0;m<E->sphere.caps;m++)  {
Full_parallel_related.c:116:    E->parallel.loc2proc_map[m] = 
Full_parallel_related.c:117:      (int ***) malloc(E->parallel.nprocx*sizeof(int **));
Full_parallel_related.c:118:    for (i=0;i<E->parallel.nprocx;i++) {
Full_parallel_related.c:119:      E->parallel.loc2proc_map[m][i] = 
Full_parallel_related.c:120:        (int **) malloc(E->parallel.nprocy*sizeof(int *));
Full_parallel_related.c:121:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:122:        E->parallel.loc2proc_map[m][i][j] = 
Full_parallel_related.c:123:          (int *) malloc(E->parallel.nprocz*sizeof(int));
Full_parallel_related.c:127:  for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:128:    for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:129:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:130:        for (k=0;k<E->parallel.nprocz;k++) {
Full_parallel_related.c:131:          E->parallel.loc2proc_map[m][i][j][k] = m*proc_per_cap
Full_parallel_related.c:132:          + j*E->parallel.nprocx*E->parallel.nprocz
Full_parallel_related.c:133:          + i*E->parallel.nprocz + k;
Full_parallel_related.c:136:  if (E->control.verbose) {
Full_parallel_related.c:137:    fprintf(E->fp_out,"me=%d loc1=%d loc2=%d loc3=%d\n",me,
Full_parallel_related.c:138:        E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3]);
Full_parallel_related.c:139:    fprintf(E->fp_out,"capid[%d]=%d \n",j,E->sphere.capid);
Full_parallel_related.c:140:    for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:141:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:142:        for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:143:          for (k=0;k<E->parallel.nprocz;k++)
Full_parallel_related.c:144:            fprintf(E->fp_out,"loc2proc_map[cap=%d][x=%d][y=%d][z=%d] = %d\n",
Full_parallel_related.c:145:                    m,i,j,k,E->parallel.loc2proc_map[m][i][j][k]);
Full_parallel_related.c:146:    fflush(E->fp_out);
Full_parallel_related.c:152:  E->exchange_node_d = exchange_node_d;
Full_parallel_related.c:153:  E->exchange_node_f = exchange_node_f;
Full_parallel_related.c:162:  processors = (int *) malloc((E->parallel.total_surf_proc+1)*sizeof(int));
Full_parallel_related.c:164:  k = E->parallel.me_loc[3];
Full_parallel_related.c:166:  for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:167:    for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:168:      for (j=0;j<E->parallel.nprocy;j++) {
Full_parallel_related.c:169:        processors[n] = E->parallel.loc2proc_map[m][i][j][k];
Full_parallel_related.c:173:  MPI_Comm_group(E->parallel.world, &world_g);
Full_parallel_related.c:174:  MPI_Group_incl(world_g, E->parallel.total_surf_proc, processors, &horizon_g);
Full_parallel_related.c:175:  MPI_Comm_create(E->parallel.world, horizon_g, &(E->parallel.horizontal_comm));
Full_parallel_related.c:177:  if (E->control.verbose) {
Full_parallel_related.c:178:    fprintf(E->fp_out,"horizontal group of me=%d loc3=%d\n",E->parallel.me,E->parallel.me_loc[3]);
Full_parallel_related.c:179:    for (j=0;j<E->parallel.total_surf_proc;j++) {
Full_parallel_related.c:180:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Full_parallel_related.c:182:    fflush(E->fp_out);
Full_parallel_related.c:196:  processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_parallel_related.c:198:  m = E->sphere.capid - 1;
Full_parallel_related.c:199:  i = E->parallel.me_loc[1];
Full_parallel_related.c:200:  j = E->parallel.me_loc[2];
Full_parallel_related.c:202:  for (k=0;k<E->parallel.nprocz;k++) {
Full_parallel_related.c:203:      processors[k] = E->parallel.loc2proc_map[m][i][j][k];
Full_parallel_related.c:206:  MPI_Comm_group(E->parallel.world, &world_g);
Full_parallel_related.c:207:  MPI_Group_incl(world_g, E->parallel.nprocz, processors, &vertical_g);
Full_parallel_related.c:208:  MPI_Comm_create(E->parallel.world, vertical_g, &(E->parallel.vertical_comm));
Full_parallel_related.c:210:  if (E->control.verbose) {
Full_parallel_related.c:211:    fprintf(E->fp_out,"vertical group of me=%d loc1=%d loc2=%d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2]);
Full_parallel_related.c:212:    for (j=0;j<E->parallel.nprocz;j++) {
Full_parallel_related.c:213:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Full_parallel_related.c:215:    fflush(E->fp_out);
Full_parallel_related.c:231:  me = E->parallel.me;
Full_parallel_related.c:233:  E->lmesh.elx = E->mesh.elx/E->parallel.nprocx;
Full_parallel_related.c:234:  E->lmesh.elz = E->mesh.elz/E->parallel.nprocz;
Full_parallel_related.c:235:  E->lmesh.ely = E->mesh.ely/E->parallel.nprocy;
Full_parallel_related.c:236:  E->lmesh.nox = E->lmesh.elx + 1;
Full_parallel_related.c:237:  E->lmesh.noz = E->lmesh.elz + 1;
Full_parallel_related.c:238:  E->lmesh.noy = E->lmesh.ely + 1;
Full_parallel_related.c:240:  E->lmesh.exs = E->parallel.me_loc[1]*E->lmesh.elx;
Full_parallel_related.c:241:  E->lmesh.eys = E->parallel.me_loc[2]*E->lmesh.ely;
Full_parallel_related.c:242:  E->lmesh.ezs = E->parallel.me_loc[3]*E->lmesh.elz;
Full_parallel_related.c:243:  E->lmesh.nxs = E->parallel.me_loc[1]*E->lmesh.elx+1;
Full_parallel_related.c:244:  E->lmesh.nys = E->parallel.me_loc[2]*E->lmesh.ely+1;
Full_parallel_related.c:245:  E->lmesh.nzs = E->parallel.me_loc[3]*E->lmesh.elz+1;
Full_parallel_related.c:247:  E->lmesh.nno = E->lmesh.noz*E->lmesh.nox*E->lmesh.noy;
Full_parallel_related.c:248:  E->lmesh.nel = E->lmesh.ely*E->lmesh.elx*E->lmesh.elz;
Full_parallel_related.c:249:  E->lmesh.npno = E->lmesh.nel;
Full_parallel_related.c:251:  E->lmesh.nsf = E->lmesh.nno/E->lmesh.noz;
Full_parallel_related.c:252:  E->lmesh.snel = E->lmesh.elx*E->lmesh.ely;
Full_parallel_related.c:254:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   {
Full_parallel_related.c:256:     if (E->control.NMULTIGRID)  {
Full_parallel_related.c:257:        nox = E->lmesh.elx/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:258:        noy = E->lmesh.ely/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:259:        noz = E->lmesh.elz/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:260:        E->parallel.redundant[i]=0;
Full_parallel_related.c:263:        { noz = E->lmesh.noz;
Full_parallel_related.c:264:          noy = E->lmesh.noy;
Full_parallel_related.c:265:          nox = E->lmesh.nox;
Full_parallel_related.c:268:     E->lmesh.ELX[i] = nox-1;
Full_parallel_related.c:269:     E->lmesh.ELY[i] = noy-1;
Full_parallel_related.c:270:     E->lmesh.ELZ[i] = noz-1;
Full_parallel_related.c:271:     E->lmesh.NOZ[i] = noz;
Full_parallel_related.c:272:     E->lmesh.NOY[i] = noy;
Full_parallel_related.c:273:     E->lmesh.NOX[i] = nox;
Full_parallel_related.c:274:     E->lmesh.NNO[i] = nox * noz * noy;
Full_parallel_related.c:275:     E->lmesh.NNOV[i] = E->lmesh.NNO[i];
Full_parallel_related.c:276:     E->lmesh.SNEL[i] = E->lmesh.ELX[i]*E->lmesh.ELY[i];
Full_parallel_related.c:278:     E->lmesh.NEL[i] = (nox-1) * (noz-1) * (noy-1);
Full_parallel_related.c:279:     E->lmesh.NPNO[i] = E->lmesh.NEL[i] ;
Full_parallel_related.c:281:     E->lmesh.NEQ[i] = E->mesh.nsd * E->lmesh.NNOV[i] ;
Full_parallel_related.c:283:     E->lmesh.EXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i];
Full_parallel_related.c:284:     E->lmesh.EYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i];
Full_parallel_related.c:285:     E->lmesh.EZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i];
Full_parallel_related.c:286:     E->lmesh.NXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i]+1;
Full_parallel_related.c:287:     E->lmesh.NYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i]+1;
Full_parallel_related.c:288:     E->lmesh.NZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i]+1;
Full_parallel_related.c:306:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++) {
Full_parallel_related.c:307:    nel = E->lmesh.NEL[lev];
Full_parallel_related.c:308:    elx = E->lmesh.ELX[lev];
Full_parallel_related.c:309:    elz = E->lmesh.ELZ[lev];
Full_parallel_related.c:310:    ely = E->lmesh.ELY[lev];
Full_parallel_related.c:311:    nox = E->lmesh.NOX[lev];
Full_parallel_related.c:312:    noy = E->lmesh.NOY[lev];
Full_parallel_related.c:313:    noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:314:    nno = E->lmesh.NNO[lev];
Full_parallel_related.c:322:        E->parallel.NODE[lev][++lnode].bound[ii] =  node;
Full_parallel_related.c:323:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Full_parallel_related.c:325:    E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Full_parallel_related.c:332:        E->parallel.NODE[lev][++lnode].bound[ii] =  node;
Full_parallel_related.c:333:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Full_parallel_related.c:335:    E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Full_parallel_related.c:343:        E->parallel.NODE[lev][++lnode].bound[ii] = node;
Full_parallel_related.c:344:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Full_parallel_related.c:346:    E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Full_parallel_related.c:353:        E->parallel.NODE[lev][++lnode].bound[ii] = node;
Full_parallel_related.c:354:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Full_parallel_related.c:356:    E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Full_parallel_related.c:364:        E->parallel.NODE[lev][++lnode].bound[ii] = node;
Full_parallel_related.c:365:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Full_parallel_related.c:367:    E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Full_parallel_related.c:374:        E->parallel.NODE[lev][++lnode].bound[ii] = node;
Full_parallel_related.c:375:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Full_parallel_related.c:377:    E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Full_parallel_related.c:384:    for (lnode=1;lnode<=E->parallel.NUM_NNO[lev].bound[2];lnode++) {
Full_parallel_related.c:385:      node = E->parallel.NODE[lev][lnode].bound[2];
Full_parallel_related.c:386:      E->NODE[lev][node] = E->NODE[lev][node] | SKIP;
Full_parallel_related.c:389:    for (lnode=1;lnode<=E->parallel.NUM_NNO[lev].bound[3];lnode++) {
Full_parallel_related.c:390:      node = E->parallel.NODE[lev][lnode].bound[3];
Full_parallel_related.c:391:      E->NODE[lev][node] = E->NODE[lev][node] | SKIP;
Full_parallel_related.c:398:    if (E->sphere.capid == 1 &&
Full_parallel_related.c:399:    E->parallel.me_loc[1] == 0 &&
Full_parallel_related.c:400:    E->parallel.me_loc[2] == 0)
Full_parallel_related.c:403:        E->NODE[lev][node] = E->NODE[lev][node] & ~SKIP;
Full_parallel_related.c:407:    if (E->sphere.capid == E->sphere.caps &&
Full_parallel_related.c:408:    E->parallel.me_loc[1] == E->parallel.nprocx-1 &&
Full_parallel_related.c:409:    E->parallel.me_loc[2] == E->parallel.nprocy-1)
Full_parallel_related.c:412:        E->NODE[lev][node] = E->NODE[lev][node] & ~SKIP;
Full_parallel_related.c:417:    if (E->parallel.me_loc[3]!=E->parallel.nprocz-1 )
Full_parallel_related.c:418:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev].bound[6];lnode++) {
Full_parallel_related.c:419:        node = E->parallel.NODE[lev][lnode].bound[6];
Full_parallel_related.c:420:        E->NODE[lev][node] = E->NODE[lev][node] | SKIP;
Full_parallel_related.c:425:  if (E->control.verbose) {
Full_parallel_related.c:426:    fprintf(E->fp_out,"output_shared_nodes %d \n",E->parallel.me);
Full_parallel_related.c:427:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Full_parallel_related.c:428:      fprintf(E->fp_out,"lev=%d  me=%d capid=%d\n",
Full_parallel_related.c:429:          lev, E->parallel.me,E->sphere.capid);
Full_parallel_related.c:431:      for (i=1;i<=E->parallel.NUM_NNO[lev].bound[ii];i++)
Full_parallel_related.c:432:        fprintf(E->fp_out,"ii=%d   %d %d \n",ii,i,
Full_parallel_related.c:433:            E->parallel.NODE[lev][i].bound[ii]);
Full_parallel_related.c:436:    for (node=1;node<=E->lmesh.NNO[lev];node++)
Full_parallel_related.c:437:      if((E->NODE[lev][node] & SKIP)) {
Full_parallel_related.c:439:        fprintf(E->fp_out,"skip %d %d \n",lnode,node);
Full_parallel_related.c:441:    fflush(E->fp_out);
Full_parallel_related.c:461:  const int dims=E->mesh.nsd;
Full_parallel_related.c:463:  me = E->parallel.me;
Full_parallel_related.c:464:  nprocx = E->parallel.nprocx;
Full_parallel_related.c:465:  nprocy = E->parallel.nprocy;
Full_parallel_related.c:466:  nprocz = E->parallel.nprocz;
Full_parallel_related.c:468:  tscaps = E->parallel.total_surf_proc;
Full_parallel_related.c:469:  lx = E->parallel.me_loc[1];
Full_parallel_related.c:470:  ly = E->parallel.me_loc[2];
Full_parallel_related.c:471:  lz = E->parallel.me_loc[3];
Full_parallel_related.c:474:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:475:    nox = E->lmesh.NOX[lev];
Full_parallel_related.c:476:    noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:477:    noy = E->lmesh.NOY[lev];
Full_parallel_related.c:479:    cap = E->sphere.capid - 1;  /* which cap I am in (0~11) */
Full_parallel_related.c:484:      target = E->parallel.loc2proc_map[cap][lx-1][ly][lz];
Full_parallel_related.c:487:      target = E->parallel.loc2proc_map[temp][nprocx-1][ly][lz];
Full_parallel_related.c:490:      target = E->parallel.loc2proc_map[temp][ly][0][lz];
Full_parallel_related.c:492:    E->parallel.PROCESSOR[lev].pass[npass] = target;
Full_parallel_related.c:498:      target = E->parallel.loc2proc_map[cap][lx+1][ly][lz];
Full_parallel_related.c:501:      target = E->parallel.loc2proc_map[temp][0][ly][lz];
Full_parallel_related.c:504:      target = E->parallel.loc2proc_map[temp][ly][nprocy-1][lz];
Full_parallel_related.c:506:    E->parallel.PROCESSOR[lev].pass[npass] = target;
Full_parallel_related.c:512:    target = E->parallel.loc2proc_map[cap][lx][ly-1][lz];
Full_parallel_related.c:515:      target = E->parallel.loc2proc_map[temp][lx][nprocy-1][lz];
Full_parallel_related.c:518:      target = E->parallel.loc2proc_map[temp][0][lx][lz];
Full_parallel_related.c:520:    E->parallel.PROCESSOR[lev].pass[npass] = target;
Full_parallel_related.c:526:    target = E->parallel.loc2proc_map[cap][lx][ly+1][lz];
Full_parallel_related.c:529:      target = E->parallel.loc2proc_map[temp][lx][0][lz];
Full_parallel_related.c:532:      target = E->parallel.loc2proc_map[temp][nprocx-1][lx][lz];
Full_parallel_related.c:534:    E->parallel.PROCESSOR[lev].pass[npass] = target;
Full_parallel_related.c:544:        target = E->parallel.loc2proc_map[temp][lx][ly][lz];
Full_parallel_related.c:547:        target = E->parallel.PROCESSOR[lev].pass[1] - nprocz;
Full_parallel_related.c:549:        target = E->parallel.PROCESSOR[lev].pass[3] - nprocxz;
Full_parallel_related.c:551:        target = E->parallel.PROCESSOR[lev].pass[1] - nprocxz;
Full_parallel_related.c:552:      E->parallel.PROCESSOR[lev].pass[npass] = target;
Full_parallel_related.c:561:        target = E->parallel.loc2proc_map[temp][lx][ly][lz];
Full_parallel_related.c:564:        target = E->parallel.PROCESSOR[lev].pass[2] + nprocz;
Full_parallel_related.c:566:        target = E->parallel.PROCESSOR[lev].pass[4] + nprocxz;
Full_parallel_related.c:568:        target = E->parallel.PROCESSOR[lev].pass[2] + nprocxz;
Full_parallel_related.c:569:      E->parallel.PROCESSOR[lev].pass[npass] = target;
Full_parallel_related.c:577:        target = E->parallel.PROCESSOR[lev].pass[4] - nprocxz;
Full_parallel_related.c:579:        target = E->parallel.PROCESSOR[lev].pass[1] + nprocz;
Full_parallel_related.c:581:        target = E->parallel.PROCESSOR[lev].pass[1] + nprocxz;
Full_parallel_related.c:582:      E->parallel.PROCESSOR[lev].pass[npass] = target;
Full_parallel_related.c:590:        target = E->parallel.PROCESSOR[lev].pass[2] - nprocz;
Full_parallel_related.c:592:        target = E->parallel.PROCESSOR[lev].pass[3] + nprocxz;
Full_parallel_related.c:594:        target = E->parallel.PROCESSOR[lev].pass[2] - nprocxz;
Full_parallel_related.c:595:      E->parallel.PROCESSOR[lev].pass[npass] = target;
Full_parallel_related.c:599:    E->parallel.TNUM_PASS[lev] = npass;
Full_parallel_related.c:603:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:606:      E->parallel.NUM_PASSz[lev].bound[ii] = 1;
Full_parallel_related.c:608:        E->parallel.NUM_PASSz[lev].bound[ii] = 0;
Full_parallel_related.c:610:        E->parallel.NUM_PASSz[lev].bound[ii] = 0;
Full_parallel_related.c:612:      for (p=1;p<=E->parallel.NUM_PASSz[lev].bound[ii];p++) {
Full_parallel_related.c:615:        kkkp = kkk + E->sphere.max_connections;
Full_parallel_related.c:617:        E->parallel.NUM_NODEz[lev].pass[kkk] = 0;
Full_parallel_related.c:618:        E->parallel.NUM_NEQz[lev].pass[kkk] = 0;
Full_parallel_related.c:620:        cap = E->sphere.capid - 1;  /* which cap I am in (0~11) */
Full_parallel_related.c:621:        E->parallel.PROCESSORz[lev].pass[kkk] =
Full_parallel_related.c:622:        E->parallel.loc2proc_map[cap][lx][ly][lz+((ii==5)?-1:1)];
Full_parallel_related.c:625:        for (k=1;k<=E->parallel.NUM_NNO[lev].bound[ii];k++) {
Full_parallel_related.c:626:          node = E->parallel.NODE[lev][k].bound[ii];
Full_parallel_related.c:627:          E->parallel.EXCHANGE_NODE[lev][++kk].pass[kkkp] = node;
Full_parallel_related.c:629:          E->parallel.EXCHANGE_ID[lev][++jj].pass[kkkp] =
Full_parallel_related.c:630:          E->ID[lev][node].doff[doff];
Full_parallel_related.c:632:        E->parallel.NUM_NODE[lev].pass[kkkp] = kk;
Full_parallel_related.c:633:        E->parallel.NUM_NEQ[lev].pass[kkkp] = jj;
Full_parallel_related.c:634:        E->parallel.NUM_NODEz[lev].pass[kkk] += kk;
Full_parallel_related.c:635:        E->parallel.NUM_NEQz[lev].pass[kkk] += jj;
Full_parallel_related.c:639:    E->parallel.TNUM_PASSz[lev] = kkk;
Full_parallel_related.c:643:  if(E->control.verbose) {
Full_parallel_related.c:644:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:645:      fprintf(E->fp_out,"output_communication route surface for lev=%d\n",lev);
Full_parallel_related.c:646:      fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",
Full_parallel_related.c:647:        E->parallel.me,E->sphere.capid,E->parallel.TNUM_PASS[lev]);
Full_parallel_related.c:648:      for (k=1;k<=E->parallel.TNUM_PASS[lev];k++) {
Full_parallel_related.c:649:        fprintf(E->fp_out,
Full_parallel_related.c:651:            E->parallel.me,k,
Full_parallel_related.c:652:            E->parallel.PROCESSOR[lev].pass[k],
Full_parallel_related.c:653:            E->parallel.NUM_NEQ[lev].pass[k],
Full_parallel_related.c:654:            E->parallel.NUM_NODE[lev].pass[k]);
Full_parallel_related.c:655:        fprintf(E->fp_out,"Eqn:\n");  
Full_parallel_related.c:656:        for(ii=1;ii<=E->parallel.NUM_NEQ[lev].pass[k];ii++)  
Full_parallel_related.c:657:          fprintf(E->fp_out,"%d %d\n",ii,
Full_parallel_related.c:658:              E->parallel.EXCHANGE_ID[lev][ii].pass[k]);  
Full_parallel_related.c:659:        fprintf(E->fp_out,"Node:\n");  
Full_parallel_related.c:660:        for(ii=1;ii<=E->parallel.NUM_NODE[lev].pass[k];ii++)  
Full_parallel_related.c:661:          fprintf(E->fp_out,"%d %d\n",ii,
Full_parallel_related.c:662:              E->parallel.EXCHANGE_NODE[lev][ii].pass[k]);  
Full_parallel_related.c:665:      fprintf(E->fp_out,"output_communication route vertical \n");
Full_parallel_related.c:666:      fprintf(E->fp_out," me= %d pass  %d \n",
Full_parallel_related.c:667:          E->parallel.me,E->parallel.TNUM_PASSz[lev]);
Full_parallel_related.c:668:      for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)   {
Full_parallel_related.c:669:      kkkp = k + E->sphere.max_connections;
Full_parallel_related.c:670:      fprintf(E->fp_out,"proc %d and pass  %d to proc %d\n",
Full_parallel_related.c:671:          E->parallel.me,k,E->parallel.PROCESSORz[lev].pass[k]);
Full_parallel_related.c:673:      fprintf(E->fp_out,"cap=%d eqn=%d node=%d\n", E->sphere.capid,
Full_parallel_related.c:674:      E->parallel.NUM_NEQ[lev].pass[kkkp],
Full_parallel_related.c:675:      E->parallel.NUM_NODE[lev].pass[kkkp]);
Full_parallel_related.c:676:      for(ii=1;ii<=E->parallel.NUM_NEQ[lev].pass[kkkp];ii++) 
Full_parallel_related.c:677:      fprintf(E->fp_out,"%d %d\n",ii,
Full_parallel_related.c:678:          E->parallel.EXCHANGE_ID[lev][ii].pass[kkkp]); 
Full_parallel_related.c:679:      for(ii=1;ii<=E->parallel.NUM_NODE[lev].pass[kkkp];ii++) 
Full_parallel_related.c:680:      fprintf(E->fp_out,"%d %d\n",ii,
Full_parallel_related.c:681:          E->parallel.EXCHANGE_NODE[lev][ii].pass[kkkp]); 
Full_parallel_related.c:684:    fflush(E->fp_out);
Full_parallel_related.c:700:  const int dims=E->mesh.nsd;
Full_parallel_related.c:702:  me = E->parallel.me;
Full_parallel_related.c:703:  nprocz = E->parallel.nprocz;
Full_parallel_related.c:706:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:707:    nox = E->lmesh.NOX[lev];
Full_parallel_related.c:708:    noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:709:    noy = E->lmesh.NOY[lev];
Full_parallel_related.c:711:    j = E->sphere.capid;
Full_parallel_related.c:712:    for (kkk=1;kkk<=E->parallel.TNUM_PASS[lev];kkk++) {
Full_parallel_related.c:715:        E->parallel.NUM_sNODE[lev].pass[kkk] =
Full_parallel_related.c:716:                     E->parallel.NUM_NNO[lev].bound[ii]/noz;
Full_parallel_related.c:718:        for (k=1;k<=E->parallel.NUM_sNODE[lev].pass[kkk];k++) {
Full_parallel_related.c:720:          node = (E->parallel.NODE[lev][lnode].bound[ii]-1)/noz + 1;
Full_parallel_related.c:721:          E->parallel.EXCHANGE_sNODE[lev][k].pass[kkk] = node;
Full_parallel_related.c:725:        E->parallel.NUM_sNODE[lev].pass[kkk]=1;
Full_parallel_related.c:727:        for (k=1;k<=E->parallel.NUM_sNODE[lev].pass[kkk];k++) {
Full_parallel_related.c:728:          node = E->parallel.EXCHANGE_NODE[lev][k].pass[kkk]/noz + 1;
Full_parallel_related.c:729:          E->parallel.EXCHANGE_sNODE[lev][k].pass[kkk] = node;
Full_parallel_related.c:737:  if(E->control.verbose) {
Full_parallel_related.c:738:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:739:      fprintf(E->fp_out,"output_communication route surface for lev=%d\n",lev);
Full_parallel_related.c:740:      fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",
Full_parallel_related.c:741:          E->parallel.me,
Full_parallel_related.c:742:          E->sphere.capid,
Full_parallel_related.c:743:          E->parallel.TNUM_PASS[lev]);
Full_parallel_related.c:744:      for (k=1;k<=E->parallel.TNUM_PASS[lev];k++) {
Full_parallel_related.c:745:        fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d node\n",
Full_parallel_related.c:746:            E->parallel.me,k,
Full_parallel_related.c:747:            E->parallel.PROCESSOR[lev].pass[k],
Full_parallel_related.c:748:            E->parallel.NUM_sNODE[lev].pass[k]);
Full_parallel_related.c:749:        fprintf(E->fp_out,"Node:\n");
Full_parallel_related.c:750:        for (ii=1;ii<=E->parallel.NUM_sNODE[lev].pass[k];ii++)
Full_parallel_related.c:751:          fprintf(E->fp_out,"%d %d\n",ii,
Full_parallel_related.c:752:              E->parallel.EXCHANGE_sNODE[lev][ii].pass[k]);
Full_parallel_related.c:755:    fflush(E->fp_out);
Full_parallel_related.c:763:  const int dims=E->mesh.nsd;
Full_parallel_related.c:765:  E->parallel.NUM_NODE[lev].pass[npass] = 
Full_parallel_related.c:766:    E->parallel.NUM_NNO[lev].bound[bd];
Full_parallel_related.c:769:  for (kk=1;kk<=E->parallel.NUM_NODE[lev].pass[npass];kk++) {
Full_parallel_related.c:770:    node = E->parallel.NODE[lev][kk].bound[bd];
Full_parallel_related.c:771:    E->parallel.EXCHANGE_NODE[lev][kk].pass[npass] = node;
Full_parallel_related.c:773:      E->parallel.EXCHANGE_ID[lev][++jj].pass[npass] = 
Full_parallel_related.c:774:        E->ID[lev][node].doff[doff];
Full_parallel_related.c:777:  E->parallel.NUM_NEQ[lev].pass[npass] = jj;
Full_parallel_related.c:785:  const int dims=E->mesh.nsd;
Full_parallel_related.c:787:  E->parallel.NUM_NODE[lev].pass[npass] = num_node;
Full_parallel_related.c:790:  for (kk=1;kk<=E->parallel.NUM_NODE[lev].pass[npass];kk++)   {
Full_parallel_related.c:792:    E->parallel.EXCHANGE_NODE[lev][kk].pass[npass] = node;
Full_parallel_related.c:794:      E->parallel.EXCHANGE_ID[lev][++jj].pass[npass] = 
Full_parallel_related.c:795:        E->ID[lev][node].doff[doff];
Full_parallel_related.c:798:  E->parallel.NUM_NEQ[lev].pass[npass] = jj;
Full_parallel_related.c:812:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Full_parallel_related.c:813:    sizeofk = (1+E->parallel.NUM_NEQ[lev].pass[k])*sizeof(double);
Full_parallel_related.c:819:  for(k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:820:    kk = (1+E->parallel.NUM_NEQz[lev].pass[k])*sizeof(double);
Full_parallel_related.c:827:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++) {
Full_parallel_related.c:829:    for(j=1;j<=E->parallel.NUM_NEQ[lev].pass[k];j++)
Full_parallel_related.c:830:      S[k][j-1] = U[ E->parallel.EXCHANGE_ID[lev][j].pass[k] ];
Full_parallel_related.c:832:    if( E->parallel.PROCESSOR[lev].pass[k] != E->parallel.me &&
Full_parallel_related.c:833:        E->parallel.PROCESSOR[lev].pass[k] != -1) {
Full_parallel_related.c:835:      MPI_Isend(S[k], E->parallel.NUM_NEQ[lev].pass[k], MPI_DOUBLE,
Full_parallel_related.c:836:                E->parallel.PROCESSOR[lev].pass[k], 1,
Full_parallel_related.c:837:                E->parallel.world, &request[idb-1]);
Full_parallel_related.c:841:  for(k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Full_parallel_related.c:842:    if( E->parallel.PROCESSOR[lev].pass[k] != E->parallel.me &&
Full_parallel_related.c:843:        E->parallel.PROCESSOR[lev].pass[k] != -1) {
Full_parallel_related.c:845:      MPI_Irecv(R[k],E->parallel.NUM_NEQ[lev].pass[k], MPI_DOUBLE,
Full_parallel_related.c:846:                  E->parallel.PROCESSOR[lev].pass[k], 1,
Full_parallel_related.c:847:                  E->parallel.world, &request[idb-1]);
Full_parallel_related.c:849:      for(j=1;j<=E->parallel.NUM_NEQ[lev].pass[k];j++)
Full_parallel_related.c:850:        U[ E->parallel.EXCHANGE_ID[lev][j].pass[k] ] += S[k][j-1];
Full_parallel_related.c:856:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Full_parallel_related.c:858:    if( E->parallel.PROCESSOR[lev].pass[k] != E->parallel.me &&
Full_parallel_related.c:859:        E->parallel.PROCESSOR[lev].pass[k] != -1) {
Full_parallel_related.c:860:      for(j=1;j<=E->parallel.NUM_NEQ[lev].pass[k];j++)
Full_parallel_related.c:861:        U[ E->parallel.EXCHANGE_ID[lev][j].pass[k] ] += R[k][j-1];
Full_parallel_related.c:866:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:868:  kk = k + E->sphere.max_connections;
Full_parallel_related.c:870:  for (j=1;j<=E->parallel.NUM_NEQ[lev].pass[kk];j++)
Full_parallel_related.c:871:    SV[jj++] = U[ E->parallel.EXCHANGE_ID[lev][j].pass[kk] ];
Full_parallel_related.c:873:  MPI_Sendrecv(SV, E->parallel.NUM_NEQz[lev].pass[k], MPI_DOUBLE,
Full_parallel_related.c:874:               E->parallel.PROCESSORz[lev].pass[k], 1,
Full_parallel_related.c:875:               RV, E->parallel.NUM_NEQz[lev].pass[k], MPI_DOUBLE,
Full_parallel_related.c:876:               E->parallel.PROCESSORz[lev].pass[k], 1,
Full_parallel_related.c:877:               E->parallel.world, &status1);
Full_parallel_related.c:880:  for (j=1;j<=E->parallel.NUM_NEQ[lev].pass[kk];j++)
Full_parallel_related.c:881:    U[ E->parallel.EXCHANGE_ID[lev][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c:884:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++) {
Full_parallel_related.c:906:  for( k=1;k<=E->parallel.TNUM_PASS[lev];k++ ) {
Full_parallel_related.c:908:    sizeofk = (1+E->parallel.NUM_NODE[lev].pass[k])*sizeof(double);
Full_parallel_related.c:914:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:915:    sizeofk = (1+E->parallel.NUM_NODEz[lev].pass[k])*sizeof(double);
Full_parallel_related.c:924:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++) {
Full_parallel_related.c:927:    for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Full_parallel_related.c:928:      S[kk][j-1] = U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ];
Full_parallel_related.c:930:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me) {
Full_parallel_related.c:931:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:933:        MPI_Isend(S[kk],E->parallel.NUM_NODE[lev].pass[k],MPI_DOUBLE,
Full_parallel_related.c:934:                  E->parallel.PROCESSOR[lev].pass[k],1,
Full_parallel_related.c:935:                  E->parallel.world,&request[idb-1]);
Full_parallel_related.c:941:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++) {
Full_parallel_related.c:944:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me) {
Full_parallel_related.c:945:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:947:        MPI_Irecv(R[kk],E->parallel.NUM_NODE[lev].pass[k],MPI_DOUBLE,
Full_parallel_related.c:948:                  E->parallel.PROCESSOR[lev].pass[k],1,
Full_parallel_related.c:949:                  E->parallel.world,&request[idb-1]);
Full_parallel_related.c:953:      for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Full_parallel_related.c:954:        U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:960:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Full_parallel_related.c:963:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me)
Full_parallel_related.c:964:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:965:        for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Full_parallel_related.c:966:          U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:971:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:973:    kk = k + E->sphere.max_connections;
Full_parallel_related.c:975:    for (j=1;j<=E->parallel.NUM_NODE[lev].pass[kk];j++)
Full_parallel_related.c:976:      SV[jj++] = U[ E->parallel.EXCHANGE_NODE[lev][j].pass[kk] ];
Full_parallel_related.c:978:    MPI_Sendrecv( SV,E->parallel.NUM_NODEz[lev].pass[k],MPI_DOUBLE,
Full_parallel_related.c:979:                  E->parallel.PROCESSORz[lev].pass[k],1,
Full_parallel_related.c:980:                  RV,E->parallel.NUM_NODEz[lev].pass[k],MPI_DOUBLE,
Full_parallel_related.c:981:                  E->parallel.PROCESSORz[lev].pass[k],1,
Full_parallel_related.c:982:                  E->parallel.world,&status1 );
Full_parallel_related.c:985:    for (j=1;j<=E->parallel.NUM_NODE[lev].pass[kk];j++)
Full_parallel_related.c:986:      U[ E->parallel.EXCHANGE_NODE[lev][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c:990:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Full_parallel_related.c:1013:  for( k=1;k<=E->parallel.TNUM_PASS[lev];k++ ) {
Full_parallel_related.c:1015:    sizeofk = (1+E->parallel.NUM_NODE[lev].pass[k])*sizeof(float);
Full_parallel_related.c:1021:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:1022:    sizeofk = (1+E->parallel.NUM_NODEz[lev].pass[k])*sizeof(float);
Full_parallel_related.c:1031:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++) {
Full_parallel_related.c:1034:    for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Full_parallel_related.c:1035:      S[kk][j-1] = U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ];
Full_parallel_related.c:1037:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me) {
Full_parallel_related.c:1038:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:1040:        MPI_Isend(S[kk],E->parallel.NUM_NODE[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:1041:                  E->parallel.PROCESSOR[lev].pass[k],1,
Full_parallel_related.c:1042:                  E->parallel.world,&request[idb-1]);
Full_parallel_related.c:1048:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++) {
Full_parallel_related.c:1051:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me) {
Full_parallel_related.c:1052:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:1054:        MPI_Irecv(R[kk],E->parallel.NUM_NODE[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:1055:                  E->parallel.PROCESSOR[lev].pass[k],1,
Full_parallel_related.c:1056:                  E->parallel.world,&request[idb-1]);
Full_parallel_related.c:1060:      for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Full_parallel_related.c:1061:        U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:1067:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Full_parallel_related.c:1070:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me)
Full_parallel_related.c:1071:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:1072:        for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Full_parallel_related.c:1073:          U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:1078:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:1080:    kk = k + E->sphere.max_connections;
Full_parallel_related.c:1082:    for (j=1;j<=E->parallel.NUM_NODE[lev].pass[kk];j++)
Full_parallel_related.c:1083:      SV[jj++] = U[ E->parallel.EXCHANGE_NODE[lev][j].pass[kk] ];
Full_parallel_related.c:1085:    MPI_Sendrecv( SV,E->parallel.NUM_NODEz[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:1086:                  E->parallel.PROCESSORz[lev].pass[k],1,
Full_parallel_related.c:1087:                  RV,E->parallel.NUM_NODEz[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:1088:                  E->parallel.PROCESSORz[lev].pass[k],1,
Full_parallel_related.c:1089:                  E->parallel.world,&status1 );
Full_parallel_related.c:1092:    for (j=1;j<=E->parallel.NUM_NODE[lev].pass[kk];j++)
Full_parallel_related.c:1093:      U[ E->parallel.EXCHANGE_NODE[lev][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c:1097:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Full_parallel_related.c:1120:  for (k=1;k<=E->parallel.TNUM_PASS[E->mesh.levmax];k++)  {
Full_parallel_related.c:1122:    sizeofk=(1+2*E->parallel.NUM_sNODE[E->mesh.levmax].pass[k])*sizeof(float);
Full_parallel_related.c:1129:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)     {
Full_parallel_related.c:1133:    for (j=1;j<=E->parallel.NUM_sNODE[lev].pass[k];j++)  {
Full_parallel_related.c:1134:      S[kk][j-1] = U1[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ];
Full_parallel_related.c:1135:      S[kk][j-1+E->parallel.NUM_sNODE[lev].pass[k]]
Full_parallel_related.c:1136:                 = U2[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ];
Full_parallel_related.c:1139:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me) {
Full_parallel_related.c:1140:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:1142:        MPI_Isend(S[kk],2*E->parallel.NUM_sNODE[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:1143:          E->parallel.PROCESSOR[lev].pass[k],1,E->parallel.world,
Full_parallel_related.c:1150:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Full_parallel_related.c:1153:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me)  {
Full_parallel_related.c:1154:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:1156:         MPI_Irecv(R[kk],2*E->parallel.NUM_sNODE[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:1157:           E->parallel.PROCESSOR[lev].pass[k],1,E->parallel.world,
Full_parallel_related.c:1162:      for (j=1;j<=E->parallel.NUM_sNODE[lev].pass[k];j++) {
Full_parallel_related.c:1163:        U1[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:1164:        U2[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ] +=
Full_parallel_related.c:1165:                             S[kk][j-1+E->parallel.NUM_sNODE[lev].pass[k]];
Full_parallel_related.c:1172:  for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Full_parallel_related.c:1176:    if (E->parallel.PROCESSOR[lev].pass[k]!=E->parallel.me)
Full_parallel_related.c:1177:      if (E->parallel.PROCESSOR[lev].pass[k]!=-1) {
Full_parallel_related.c:1178:        for (j=1;j<=E->parallel.NUM_sNODE[lev].pass[k];j++) {
Full_parallel_related.c:1179:           U1[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:1180:           U2[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ] +=
Full_parallel_related.c:1181:                          R[kk][j-1+E->parallel.NUM_sNODE[lev].pass[k]];
Full_parallel_related.c:1187:  for (k=1;k<=E->parallel.TNUM_PASS[E->mesh.levmax];k++)  {
Full_read_input_from_files.c:57:    const int dims=E->mesh.nsd;
Full_read_input_from_files.c:66:    nox=E->mesh.nox;
Full_read_input_from_files.c:67:    noy=E->mesh.noy;
Full_read_input_from_files.c:68:    noz=E->mesh.noz;
Full_read_input_from_files.c:69:    nox1=E->lmesh.nox;
Full_read_input_from_files.c:70:    noz1=E->lmesh.noz;
Full_read_input_from_files.c:71:    noy1=E->lmesh.noy;
Full_read_input_from_files.c:73:    elx=E->lmesh.elx;
Full_read_input_from_files.c:74:    elz=E->lmesh.elz;
Full_read_input_from_files.c:75:    ely=E->lmesh.ely;
Full_read_input_from_files.c:77:    emax=E->mesh.elx*E->mesh.elz*E->mesh.ely;
Full_read_input_from_files.c:93:    cap = E->sphere.capid - 1;  /* capid: 1-12 */
Full_read_input_from_files.c:99:	if(!E->control.ggrd.vtop_control){
Full_read_input_from_files.c:101:	sprintf(output_file1,"%s%0.0f.%d",E->control.velocity_boundary_file,newage1,cap);
Full_read_input_from_files.c:102:	sprintf(output_file2,"%s%0.0f.%d",E->control.velocity_boundary_file,newage2,cap);
Full_read_input_from_files.c:105:          fprintf(E->fp,"(Problem_related #4) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:111:	    fprintf(E->fp,"(Problem_related #5) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:115:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:116:	  fprintf(E->fp,"Velocity: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:117:	  fprintf(E->fp,"Velocity: File1 = %s\n",output_file1);
Full_read_input_from_files.c:119:	    fprintf(E->fp,"Velocity: File2 = %s\n",output_file2);
Full_read_input_from_files.c:121:	    fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:130:	if(!E->control.ggrd.age_control){
Full_read_input_from_files.c:132:	sprintf(output_file1,"%s%0.0f.%d",E->control.lith_age_file,newage1,cap);
Full_read_input_from_files.c:133:	sprintf(output_file2,"%s%0.0f.%d",E->control.lith_age_file,newage2,cap);
Full_read_input_from_files.c:136:          fprintf(E->fp,"(Problem_related #6) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:142:	    fprintf(E->fp,"(Problem_related #7) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:146:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:147:	  fprintf(E->fp,"Age: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:148:	  fprintf(E->fp,"Age: File1 = %s\n",output_file1);
Full_read_input_from_files.c:150:	    fprintf(E->fp,"Age: File2 = %s\n",output_file2);
Full_read_input_from_files.c:152:	    fprintf(E->fp,"Age: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:161:	if(E->control.ggrd.mat_control == 0){
Full_read_input_from_files.c:163:	sprintf(output_file1,"%s%0.0f.%d",E->control.mat_file,newage1,cap);
Full_read_input_from_files.c:164:	sprintf(output_file2,"%s%0.0f.%d",E->control.mat_file,newage2,cap);
Full_read_input_from_files.c:167:          fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:173:	    fprintf(E->fp,"(Problem_related #9) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:177:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:178:	  fprintf(E->fp,"Mat: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:179:	  fprintf(E->fp,"Mat: File1 = %s\n",output_file1);
Full_read_input_from_files.c:181:	    fprintf(E->fp,"Mat: File2 = %s\n",output_file2);
Full_read_input_from_files.c:183:	    fprintf(E->fp,"Mat: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:192:	sprintf(output_file1,"%s%0.0f.%d",E->control.temperature_boundary_file,newage1,cap);
Full_read_input_from_files.c:193:	sprintf(output_file2,"%s%0.0f.%d",E->control.temperature_boundary_file,newage2,cap);
Full_read_input_from_files.c:196:          fprintf(E->fp,"(Problem_related #10) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:202:	    fprintf(E->fp,"(Problem_related #11) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:206:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:207:	  fprintf(E->fp,"Surface Temperature: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:208:	  fprintf(E->fp,"Surface Temperature: File1 = %s\n",output_file1);
Full_read_input_from_files.c:210:	    fprintf(E->fp,"Surface Temperature: File2 = %s\n",output_file2);
Full_read_input_from_files.c:212:	    fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:224:	if(!E->control.ggrd.vtop_control){ /* grd control is called from boundary conditions subroutine */
Full_read_input_from_files.c:236:	  VB1[1][i] *= E->data.timedir;
Full_read_input_from_files.c:237:	  VB1[2][i] *= E->data.timedir;
Full_read_input_from_files.c:243:	    VB2[1][i] *= E->data.timedir;
Full_read_input_from_files.c:244:	    VB2[2][i] *= E->data.timedir;
Full_read_input_from_files.c:246:	  /* if( E->parallel.me ==0)
Full_read_input_from_files.c:252:	if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Full_read_input_from_files.c:255:	      nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Full_read_input_from_files.c:258:		E->sphere.cap.VB[1][nodel] = (VB1[1][nodeg] + (VB2[1][nodeg]-VB1[1][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Full_read_input_from_files.c:259:		E->sphere.cap.VB[2][nodel] = (VB1[2][nodeg] + (VB2[2][nodeg]-VB1[2][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Full_read_input_from_files.c:260:		E->sphere.cap.VB[3][nodel] = 0.0;
Full_read_input_from_files.c:263:		E->sphere.cap.VB[1][nodel] = VB1[1][nodeg] * E->data.scalev;
Full_read_input_from_files.c:264:		E->sphere.cap.VB[2][nodel] = VB1[2][nodeg] * E->data.scalev;
Full_read_input_from_files.c:265:		E->sphere.cap.VB[3][nodel] = 0.0;
Full_read_input_from_files.c:268:	}   /* end of E->parallel.me_loc[3]==E->parallel.nproczl-1   */
Full_read_input_from_files.c:280:	if(E->control.ggrd.age_control){
Full_read_input_from_files.c:296:              E->age_t[node] = (inputage1 + (inputage2-inputage1)/(newage2-newage1)*(age-newage1))/E->data.scalet;
Full_read_input_from_files.c:299:              E->age_t[node] = inputage1;
Full_read_input_from_files.c:311:	if(E->control.ggrd.mat_control != 0){ /* use netcdf grids */
Full_read_input_from_files.c:322:          nodea = E->ien[el].node[2];
Full_read_input_from_files.c:325:            E->mat[el] = llayer;
Full_read_input_from_files.c:346:              el = j + (i-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_read_input_from_files.c:347:              elg = E->lmesh.ezs+j + (E->lmesh.exs+i-1)*E->mesh.elz + 
Full_read_input_from_files.c:348:                (E->lmesh.eys+k-1)*E->mesh.elz*E->mesh.elx;
Full_read_input_from_files.c:349:              E->VIP[el] = VIP1[elg]+(VIP2[elg]-VIP1[elg])/(newage2-newage1)*(age-newage1);
Full_read_input_from_files.c:366:	if(E->control.ggrd.ray_control)
Full_read_input_from_files.c:393:	if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Full_read_input_from_files.c:396:	      nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Full_read_input_from_files.c:399:		E->sphere.cap.TB[1][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:400:		E->sphere.cap.TB[2][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:401:		E->sphere.cap.TB[3][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:404:		E->sphere.cap.TB[1][nodel] = TB1[nodeg];
Full_read_input_from_files.c:405:		E->sphere.cap.TB[2][nodel] = TB1[nodeg];
Full_read_input_from_files.c:406:		E->sphere.cap.TB[3][nodel] = TB1[nodeg];
Full_read_input_from_files.c:409:	}   /* end of E->parallel.me_loc[3]==E->parallel.nproczl-1   */
Full_read_input_from_files.c:416:    fflush(E->fp);
Full_solver.c:65:    E->solver.velocity_boundary_conditions = full_velocity_boundary_conditions;
Full_solver.c:66:    E->solver.temperature_boundary_conditions = full_temperature_boundary_conditions;
Full_solver.c:69:    E->solver.set_2dc_defaults = full_set_2dc_defaults;
Full_solver.c:70:    E->solver.set_2pt5dc_defaults = full_set_2pt5dc_defaults;
Full_solver.c:71:    E->solver.set_3dc_defaults = full_set_3dc_defaults;
Full_solver.c:72:    E->solver.set_3dsphere_defaults = full_set_3dsphere_defaults;
Full_solver.c:75:    E->solver.lith_age_read_files = full_lith_age_read_files;
Full_solver.c:78:    E->solver.parallel_processor_setup = full_parallel_processor_setup;
Full_solver.c:79:    E->solver.parallel_domain_decomp0 = full_parallel_domain_decomp0;
Full_solver.c:80:    E->solver.parallel_domain_boundary_nodes = full_parallel_domain_boundary_nodes;
Full_solver.c:81:    E->solver.parallel_communication_routs_v = full_parallel_communication_routs_v;
Full_solver.c:82:    E->solver.parallel_communication_routs_s = full_parallel_communication_routs_s;
Full_solver.c:83:    E->solver.exchange_id_d = full_exchange_id_d;
Full_solver.c:86:    E->solver.read_input_files_for_timesteps = full_read_input_files_for_timesteps;
Full_solver.c:89:    E->solver.node_locations = full_node_locations;
Full_solver.c:90:    E->solver.construct_boundary = full_construct_boundary;
Full_sphere_related.c:175:  temp = max(E->mesh.noy, E->mesh.nox);
Full_sphere_related.c:200:  temp = E->mesh.noy * E->mesh.nox;
Full_sphere_related.c:212:  int capnum = E->parallel.me % 12;
Full_sphere_related.c:217:      E->sphere.cap.theta[1] = M_PI/2.0;
Full_sphere_related.c:218:      E->sphere.cap.theta[2] = 3*M_PI/4.0-offset;
Full_sphere_related.c:219:      E->sphere.cap.theta[3] = M_PI;
Full_sphere_related.c:220:      E->sphere.cap.theta[4] = 3*M_PI/4.0-offset;
Full_sphere_related.c:221:      E->sphere.cap.fi[1] = M_PI/4.0;
Full_sphere_related.c:222:      E->sphere.cap.fi[2] = 0.0;
Full_sphere_related.c:223:      E->sphere.cap.fi[3] = 0.0;
Full_sphere_related.c:224:      E->sphere.cap.fi[4] = M_PI/2.0;
Full_sphere_related.c:227:      E->sphere.cap.theta[1] = 0.0;
Full_sphere_related.c:228:      E->sphere.cap.theta[2] = M_PI/4.0+offset;
Full_sphere_related.c:229:      E->sphere.cap.theta[3] = M_PI/2.0;
Full_sphere_related.c:230:      E->sphere.cap.theta[4] = M_PI/4.0+offset;
Full_sphere_related.c:231:      E->sphere.cap.fi[1] = 0.0;
Full_sphere_related.c:232:      E->sphere.cap.fi[2] = 0.0;
Full_sphere_related.c:233:      E->sphere.cap.fi[3] = M_PI/4.0;
Full_sphere_related.c:234:      E->sphere.cap.fi[4] = M_PI/2.0;
Full_sphere_related.c:237:      E->sphere.cap.theta[1] = M_PI/4.0+offset;
Full_sphere_related.c:238:      E->sphere.cap.theta[2] = M_PI/2.0;
Full_sphere_related.c:239:      E->sphere.cap.theta[3] = 3*M_PI/4.0-offset;
Full_sphere_related.c:240:      E->sphere.cap.theta[4] = M_PI/2.0;
Full_sphere_related.c:241:      E->sphere.cap.fi[1] = M_PI/2.0;
Full_sphere_related.c:242:      E->sphere.cap.fi[2] = M_PI/2.0 - M_PI/4.0;
Full_sphere_related.c:243:      E->sphere.cap.fi[3] = M_PI/2.0;
Full_sphere_related.c:244:      E->sphere.cap.fi[4] = M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:247:      E->sphere.cap.theta[1] = M_PI/2.0;
Full_sphere_related.c:248:      E->sphere.cap.theta[2] = 3*M_PI/4.0-offset;
Full_sphere_related.c:249:      E->sphere.cap.theta[3] = M_PI;
Full_sphere_related.c:250:      E->sphere.cap.theta[4] = 3*M_PI/4.0-offset;
Full_sphere_related.c:251:      E->sphere.cap.fi[1] = M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:252:      E->sphere.cap.fi[2] = M_PI/2.0;
Full_sphere_related.c:253:      E->sphere.cap.fi[3] = 0.0;
Full_sphere_related.c:254:      E->sphere.cap.fi[4] = M_PI;
Full_sphere_related.c:257:      E->sphere.cap.theta[1] = 0.0;
Full_sphere_related.c:258:      E->sphere.cap.theta[2] = M_PI/4.0+offset;
Full_sphere_related.c:259:      E->sphere.cap.theta[3] = M_PI/2.0;
Full_sphere_related.c:260:      E->sphere.cap.theta[4] = M_PI/4.0+offset;
Full_sphere_related.c:261:      E->sphere.cap.fi[1] = 0.0;
Full_sphere_related.c:262:      E->sphere.cap.fi[2] = M_PI/2.0;
Full_sphere_related.c:263:      E->sphere.cap.fi[3] = M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:264:      E->sphere.cap.fi[4] = M_PI;
Full_sphere_related.c:267:      E->sphere.cap.theta[1] = M_PI/4.0+offset;
Full_sphere_related.c:268:      E->sphere.cap.theta[2] = M_PI/2.0;
Full_sphere_related.c:269:      E->sphere.cap.theta[3] = 3*M_PI/4.0-offset;
Full_sphere_related.c:270:      E->sphere.cap.theta[4] = M_PI/2.0;
Full_sphere_related.c:271:      E->sphere.cap.fi[1] = M_PI;
Full_sphere_related.c:272:      E->sphere.cap.fi[2] = M_PI - M_PI/4.0;
Full_sphere_related.c:273:      E->sphere.cap.fi[3] = M_PI;
Full_sphere_related.c:274:      E->sphere.cap.fi[4] = M_PI + M_PI/4.0;
Full_sphere_related.c:277:      E->sphere.cap.theta[1] = M_PI/2.0;
Full_sphere_related.c:278:      E->sphere.cap.theta[2] = 3*M_PI/4.0-offset;
Full_sphere_related.c:279:      E->sphere.cap.theta[3] = M_PI;
Full_sphere_related.c:280:      E->sphere.cap.theta[4] = 3*M_PI/4.0-offset;
Full_sphere_related.c:281:      E->sphere.cap.fi[1] = 2.0*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:282:      E->sphere.cap.fi[2] = 2.0*M_PI/2.0;
Full_sphere_related.c:283:      E->sphere.cap.fi[3] = 0.0;
Full_sphere_related.c:284:      E->sphere.cap.fi[4] = 1.5*M_PI;
Full_sphere_related.c:287:      E->sphere.cap.theta[1] = 0.0;
Full_sphere_related.c:288:      E->sphere.cap.theta[2] = M_PI/4.0+offset;
Full_sphere_related.c:289:      E->sphere.cap.theta[3] = M_PI/2.0;
Full_sphere_related.c:290:      E->sphere.cap.theta[4] = M_PI/4.0+offset;
Full_sphere_related.c:291:      E->sphere.cap.fi[1] = 0.0;
Full_sphere_related.c:292:      E->sphere.cap.fi[2] = M_PI;
Full_sphere_related.c:293:      E->sphere.cap.fi[3] = M_PI + M_PI/4.0;
Full_sphere_related.c:294:      E->sphere.cap.fi[4] = 3.0*M_PI/2.0;
Full_sphere_related.c:297:      E->sphere.cap.theta[1] = M_PI/4.0+offset;
Full_sphere_related.c:298:      E->sphere.cap.theta[2] = M_PI/2.0;
Full_sphere_related.c:299:      E->sphere.cap.theta[3] = 3*M_PI/4.0-offset;
Full_sphere_related.c:300:      E->sphere.cap.theta[4] = M_PI/2.0;
Full_sphere_related.c:301:      E->sphere.cap.fi[1] = 3.0*M_PI/2.0;
Full_sphere_related.c:302:      E->sphere.cap.fi[2] = 3.0*M_PI/2.0 - M_PI/4.0;
Full_sphere_related.c:303:      E->sphere.cap.fi[3] = 3.0*M_PI/2.0;
Full_sphere_related.c:304:      E->sphere.cap.fi[4] = 3.0*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:307:      E->sphere.cap.theta[1] = M_PI/2.0;
Full_sphere_related.c:308:      E->sphere.cap.theta[2] = 3*M_PI/4.0-offset;
Full_sphere_related.c:309:      E->sphere.cap.theta[3] = M_PI;
Full_sphere_related.c:310:      E->sphere.cap.theta[4] = 3*M_PI/4.0-offset;
Full_sphere_related.c:311:      E->sphere.cap.fi[1] = 3.0*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:312:      E->sphere.cap.fi[2] = 3.0*M_PI/2.0;
Full_sphere_related.c:313:      E->sphere.cap.fi[3] = 0.0;
Full_sphere_related.c:314:      E->sphere.cap.fi[4] = 2.0*M_PI;
Full_sphere_related.c:317:      E->sphere.cap.theta[1] = 0.0;
Full_sphere_related.c:318:      E->sphere.cap.theta[2] = M_PI/4.0+offset;
Full_sphere_related.c:319:      E->sphere.cap.theta[3] = M_PI/2.0;
Full_sphere_related.c:320:      E->sphere.cap.theta[4] = M_PI/4.0+offset;
Full_sphere_related.c:321:      E->sphere.cap.fi[1] = 0.0;
Full_sphere_related.c:322:      E->sphere.cap.fi[2] = 3.0*M_PI/2.0;
Full_sphere_related.c:323:      E->sphere.cap.fi[3] = 3.0*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:324:      E->sphere.cap.fi[4] = 3.0*M_PI/2.0;
Full_sphere_related.c:327:      E->sphere.cap.theta[1] = M_PI/4.0+offset;
Full_sphere_related.c:328:      E->sphere.cap.theta[2] = M_PI/2.0;
Full_sphere_related.c:329:      E->sphere.cap.theta[3] = 3*M_PI/4.0-offset;
Full_sphere_related.c:330:      E->sphere.cap.theta[4] = M_PI/2.0;
Full_sphere_related.c:331:      E->sphere.cap.fi[1] = 2.0*M_PI;
Full_sphere_related.c:332:      E->sphere.cap.fi[2] = 2.0*M_PI - M_PI/4.0;
Full_sphere_related.c:333:      E->sphere.cap.fi[3] = 2.0*M_PI;
Full_sphere_related.c:334:      E->sphere.cap.fi[4] = 2.0*M_PI + M_PI/4.0;
Full_sphere_related.c:347:    x[i] = E->data.ra * sin(E->sphere.cap.theta[i])*cos(E->sphere.cap.fi[i]);
Full_sphere_related.c:348:    y[i] = E->data.ra * sin(E->sphere.cap.theta[i])*sin(E->sphere.cap.fi[i]);
Full_sphere_related.c:349:    z[i] = E->data.rc * cos(E->sphere.cap.theta[i]);
Full_sphere_related.c:358:    x[i] = sin(E->sphere.cap.theta[i])*cos(E->sphere.cap.fi[i]);
Full_sphere_related.c:359:    y[i] = sin(E->sphere.cap.theta[i])*sin(E->sphere.cap.fi[i]);
Full_sphere_related.c:360:    z[i] = cos(E->sphere.cap.theta[i]);
Full_sphere_related.c:379:  lev = E->mesh.levmax;
Full_sphere_related.c:382:     elx = E->lmesh.ELX[lev]*E->parallel.nprocx;
Full_sphere_related.c:383:     ely = E->lmesh.ELY[lev]*E->parallel.nprocy;
Full_sphere_related.c:386:     lelx = E->lmesh.ELX[lev];
Full_sphere_related.c:387:     lely = E->lmesh.ELY[lev];
Full_sphere_related.c:395:     for (j=0, i=E->lmesh.nxs; j<lnox; j++, i++) {
Full_sphere_related.c:404:     for (j=0, i=E->lmesh.nxs; j<lnox; j++, i++) {
Full_sphere_related.c:413:     for (k=0, i=E->lmesh.nys; k<lnoy; k++, i++) {
Full_sphere_related.c:422:     for (k=0, i=E->lmesh.nys; k<lnoy; k++, i++) {
Full_sphere_related.c:453:                 fprintf(stderr, "Error(Full_coord_of_cap): cannot find intersection point! rank=%d, nx=%d, ny=%d\n", E->parallel.me, j, k);
Full_sphere_related.c:468:     if(E->parallel.me_loc[2] == 0) {
Full_sphere_related.c:477:     if(E->parallel.me_loc[2] == E->parallel.nprocy-1) {
Full_sphere_related.c:486:     if(E->parallel.me_loc[1] == 0) {
Full_sphere_related.c:495:     if(E->parallel.me_loc[1] == E->parallel.nprocx-1) {
Full_sphere_related.c:506:     efac2 = E->data.ellipticity*(2.0 - E->data.ellipticity)/
Full_sphere_related.c:507:       ((1.- E->data.ellipticity)*(1.-E->data.ellipticity));
Full_sphere_related.c:509:     for (lev=E->mesh.levmax, step=1; lev>=E->mesh.levmin; lev--, step*=2) {
Full_sphere_related.c:512:       lvnox = E->lmesh.NOX[lev];
Full_sphere_related.c:513:       lvnoy = E->lmesh.NOY[lev];
Full_sphere_related.c:514:       lvnoz = E->lmesh.NOZ[lev];
Full_sphere_related.c:524:	   rfac = E->data.ra*1./sqrt(1.0+efac2*cost*cost);
Full_sphere_related.c:531:	     E->SX[lev][1][node] = theta;
Full_sphere_related.c:532:	     E->SX[lev][2][node] = fi;
Full_sphere_related.c:533:	     E->SX[lev][3][node] = rfac * E->sphere.R[lev][i];
Full_sphere_related.c:536:	     E->X[lev][1][node] = E->data.ra * E->sphere.R[lev][i]*sint*cosf;
Full_sphere_related.c:537:	     E->X[lev][2][node] = E->data.ra * E->sphere.R[lev][i]*sint*sinf;
Full_sphere_related.c:538:	     E->X[lev][3][node] = E->data.rc * E->sphere.R[lev][i]*cost;
Full_sphere_related.c:547:     for (lev=E->mesh.levmax, step=1; lev>=E->mesh.levmin; lev--, step*=2) {
Full_sphere_related.c:550:       lvnox = E->lmesh.NOX[lev];
Full_sphere_related.c:551:       lvnoy = E->lmesh.NOY[lev];
Full_sphere_related.c:552:       lvnoz = E->lmesh.NOZ[lev];
Full_sphere_related.c:567:	     E->SX[lev][1][node] = theta;
Full_sphere_related.c:568:	     E->SX[lev][2][node] = fi;
Full_sphere_related.c:569:	     E->SX[lev][3][node] = E->sphere.R[lev][i];
Full_sphere_related.c:572:	     E->X[lev][1][node]  = E->sphere.R[lev][i]*sint*cosf;
Full_sphere_related.c:573:	     E->X[lev][2][node]  = E->sphere.R[lev][i]*sint*sinf;
Full_sphere_related.c:574:	     E->X[lev][3][node]  = E->sphere.R[lev][i]*cost;
Full_tracer_advection.c:98:    int m = E->parallel.me;
Full_tracer_advection.c:105:    E->trace.deltheta=1.0;
Full_tracer_advection.c:106:    E->trace.delphi=1.0;
Full_tracer_advection.c:107:    input_double("regular_grid_deltheta",&(E->trace.deltheta),"1.0",m);
Full_tracer_advection.c:108:    input_double("regular_grid_delphi",&(E->trace.delphi),"1.0",m);
Full_tracer_advection.c:113:    E->trace.ianalytical_tracer_test=0;
Full_tracer_advection.c:114:    /* input_int("analytical_tracer_test",&(E->trace.ianalytical_tracer_test),
Full_tracer_advection.c:136:    sprintf(output_file,"%s.tracer_log.%d",E->control.data_file,E->parallel.me);
Full_tracer_advection.c:137:    E->trace.fpt=fopen(output_file,"w");
Full_tracer_advection.c:142:    E->trace.istat_isend=0;
Full_tracer_advection.c:143:    E->trace.istat_iempty=0;
Full_tracer_advection.c:144:    E->trace.istat_elements_checked=0;
Full_tracer_advection.c:145:    E->trace.istat1=0;
Full_tracer_advection.c:150:    E->trace.box_cushion=0.00001;
Full_tracer_advection.c:155:    E->trace.number_of_basic_quantities=12;
Full_tracer_advection.c:160:    E->trace.number_of_extra_quantities = 0;
Full_tracer_advection.c:161:    if (E->trace.nflavors > 0)
Full_tracer_advection.c:162:        E->trace.number_of_extra_quantities += 1;
Full_tracer_advection.c:165:    E->trace.number_of_tracer_quantities =
Full_tracer_advection.c:166:        E->trace.number_of_basic_quantities +
Full_tracer_advection.c:167:        E->trace.number_of_extra_quantities;
Full_tracer_advection.c:178:    if (E->trace.number_of_basic_quantities>99) {
Full_tracer_advection.c:179:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of basic in tracer_defs.h\n");
Full_tracer_advection.c:180:        fflush(E->trace.fpt);
Full_tracer_advection.c:183:    if (E->trace.number_of_extra_quantities>99) {
Full_tracer_advection.c:184:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of extraq in tracer_defs.h\n");
Full_tracer_advection.c:185:        fflush(E->trace.fpt);
Full_tracer_advection.c:188:    if (E->trace.number_of_tracer_quantities>99) {
Full_tracer_advection.c:189:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of rlater in tracer_defs.h\n");
Full_tracer_advection.c:190:        fflush(E->trace.fpt);
Full_tracer_advection.c:210:    if (E->trace.ianalytical_tracer_test==1) {
Full_tracer_advection.c:216:    if (E->composition.on)
Full_tracer_advection.c:219:    fprintf(E->trace.fpt, "Tracer intiailization takes %f seconds.\n",
Full_tracer_advection.c:286:    int lev=E->mesh.levmax;
Full_tracer_advection.c:287:    int num_ngb = E->parallel.TNUM_PASS[lev];
Full_tracer_advection.c:299:    if(E->control.verbose)
Full_tracer_advection.c:300:      fprintf(E->trace.fpt, "Entering lost_souls()\n");
Full_tracer_advection.c:303:    E->trace.istat_isend=E->trace.ilater;
Full_tracer_advection.c:305:    for (kk=1; kk<=E->trace.istat_isend; kk++) {
Full_tracer_advection.c:306:        fprintf(E->trace.fpt, "tracer#=%d xx=(%g,%g,%g)\n", kk,
Full_tracer_advection.c:307:                E->trace.rlater[j][0][kk],
Full_tracer_advection.c:308:                E->trace.rlater[j][1][kk],
Full_tracer_advection.c:309:                E->trace.rlater[j][2][kk]);
Full_tracer_advection.c:311:    fflush(E->trace.fpt);
Full_tracer_advection.c:318:    isize=E->trace.ilater*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:330:            fprintf(E->trace.fpt,"Error(lost souls)-no memory (u389)\n");
Full_tracer_advection.c:331:            fflush(E->trace.fpt);
Full_tracer_advection.c:338:    ithiscap=E->sphere.capid[j];
Full_tracer_advection.c:340:        ithatcap=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:341:        fprintf(E->trace.fpt,"cap: %d me %d TNUM: %d rank: %d\n",
Full_tracer_advection.c:342:                ithiscap,E->parallel.me,kk,ithatcap);
Full_tracer_advection.c:345:    fflush(E->trace.fpt);
Full_tracer_advection.c:363:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:368:        idestination_proc=E->parallel.PROCESSOR[lev].pass[kk];
Full_tracer_advection.c:371:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:374:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:386:	  isource_proc=E->parallel.me;
Full_tracer_advection.c:388:	  isource_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:390:	fprintf(E->trace.fpt,"%d send %d to proc %d\n",
Full_tracer_advection.c:391:		E->parallel.me,isend[j][kk],isource_proc);
Full_tracer_advection.c:392:	fprintf(E->trace.fpt,"%d recv %d from proc %d\n",
Full_tracer_advection.c:393:		E->parallel.me,ireceive[j][kk],isource_proc);
Full_tracer_advection.c:400:        isize=ireceive[ithatcap]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:406:            fprintf(E->trace.fpt,"Error(lost souls)-no memory (c721)\n");
Full_tracer_advection.c:407:            fflush(E->trace.fpt);
Full_tracer_advection.c:419:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:422:        isize=isend[ithatcap]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:431:        idestination_proc=E->parallel.PROCESSOR[lev].pass[kk];
Full_tracer_advection.c:433:        isize=isend[kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:436:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:438:        isize=ireceive[kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:441:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:468:    isize=isum*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:471:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (g323)\n");
Full_tracer_advection.c:472:        fflush(E->trace.fpt);
Full_tracer_advection.c:488:            ipos=pp*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:490:            for (mm=0;mm<E->trace.number_of_tracer_quantities;mm++) {
Full_tracer_advection.c:506:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:512:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:514:              E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:518:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (c721)\n");
Full_tracer_advection.c:519:                fflush(E->trace.fpt);
Full_tracer_advection.c:524:        for(ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:526:            ithat_processor=E->parallel.PROCESSORz[lev].pass[ivertical_neighbor];
Full_tracer_advection.c:539:                ireceive_position=it*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:554:                    E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:557:                    E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:558:                  for (mm=0;mm<=(E->trace.number_of_tracer_quantities-1);mm++) {
Full_tracer_advection.c:585:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:587:            idestination_proc = E->parallel.PROCESSORz[lev].pass[kk];
Full_tracer_advection.c:589:                      14,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:592:                      14,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:602:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:603:            fprintf(E->trace.fpt, "PROC: %d IVN: %d (P: %d) "
Full_tracer_advection.c:605:                    E->parallel.me,kk,E->parallel.PROCESSORz[lev].pass[kk],
Full_tracer_advection.c:608:        fflush(E->trace.fpt);
Full_tracer_advection.c:615:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:616:            isize=ireceive_z[kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:620:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (t590)\n");
Full_tracer_advection.c:621:                fflush(E->trace.fpt);
Full_tracer_advection.c:629:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:631:            idestination_proc = E->parallel.PROCESSORz[lev].pass[kk];
Full_tracer_advection.c:633:            isize_send=isend_z[kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:636:                      15,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:638:            isize_receive=ireceive_z[kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:641:                      15,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:654:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:660:        isize=isum*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:664:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (i981)\n");
Full_tracer_advection.c:665:                fprintf(E->trace.fpt,"isize: %d\n",isize);
Full_tracer_advection.c:666:                fflush(E->trace.fpt);
Full_tracer_advection.c:672:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:676:                irec_position=irec*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:678:                ireceive_position=kk*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:680:                for (mm=0;mm<E->trace.number_of_tracer_quantities;mm++) {
Full_tracer_advection.c:688:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:701:        E->trace.ntracers++;
Full_tracer_advection.c:703:        if (E->trace.ntracers>(E->trace.max_ntracers-5)) 
Full_tracer_advection.c:706:        ireceive_position=kk*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:708:        for (mm=0;mm<E->trace.number_of_basic_quantities;mm++) {
Full_tracer_advection.c:711:            E->trace.basicq[mm][E->trace.ntracers]=REC[ipos];
Full_tracer_advection.c:713:        for (mm=0;mm<E->trace.number_of_extra_quantities;mm++) {
Full_tracer_advection.c:714:            ipos=ireceive_position+E->trace.number_of_basic_quantities+mm;
Full_tracer_advection.c:716:            E->trace.extraq[mm][E->trace.ntracers]=REC[ipos];
Full_tracer_advection.c:719:        theta=E->trace.basicq[0][E->trace.ntracers];
Full_tracer_advection.c:720:        phi=E->trace.basicq[1][E->trace.ntracers];
Full_tracer_advection.c:721:        rad=E->trace.basicq[2][E->trace.ntracers];
Full_tracer_advection.c:722:        x=E->trace.basicq[3][E->trace.ntracers];
Full_tracer_advection.c:723:        y=E->trace.basicq[4][E->trace.ntracers];
Full_tracer_advection.c:724:        z=E->trace.basicq[5][E->trace.ntracers];
Full_tracer_advection.c:726:        iel=(E->trace.iget_element)(E,-99,x,y,z,theta,phi,rad);
Full_tracer_advection.c:729:            fprintf(E->trace.fpt,"Error(lost souls) - element not here?\n");
Full_tracer_advection.c:730:            fprintf(E->trace.fpt,"x,y,z-theta,phi,rad: %f %f %f - %f %f %f\n",x,y,z,theta,phi,rad);
Full_tracer_advection.c:731:            fflush(E->trace.fpt);
Full_tracer_advection.c:735:        E->trace.ielement[E->trace.ntracers]=iel;
Full_tracer_advection.c:738:    if(E->control.verbose){
Full_tracer_advection.c:739:      fprintf(E->trace.fpt,"Freeing memory in lost_souls()\n");
Full_tracer_advection.c:740:      fflush(E->trace.fpt);
Full_tracer_advection.c:753:    if(E->control.verbose){
Full_tracer_advection.c:754:      fprintf(E->trace.fpt,"Leaving lost_souls()\n");
Full_tracer_advection.c:755:      fflush(E->trace.fpt);
Full_tracer_advection.c:758:    E->trace.lost_souls_time += CPU_time0() - begin_time;
Full_tracer_advection.c:767:    int lev = E->mesh.levmax;
Full_tracer_advection.c:773:    numtracers=E->trace.ilater;
Full_tracer_advection.c:776:        rad=E->trace.rlater[2][kk];
Full_tracer_advection.c:777:        x=E->trace.rlater[3][kk];
Full_tracer_advection.c:778:        y=E->trace.rlater[4][kk];
Full_tracer_advection.c:779:        z=E->trace.rlater[5][kk];
Full_tracer_advection.c:783:        if (E->parallel.nprocz>1) {
Full_tracer_advection.c:792:        for (pp=1;pp<=E->parallel.TNUM_PASS[lev];pp++) {
Full_tracer_advection.c:801:            fprintf(E->trace.fpt,"Error(lost souls)-should not be here\n");
Full_tracer_advection.c:802:            fprintf(E->trace.fpt,"x: %f y: %f z: %f rad: %f\n",x,y,z,rad);
Full_tracer_advection.c:804:            if (icheck==1) fprintf(E->trace.fpt," icheck here!\n");
Full_tracer_advection.c:805:            else fprintf(E->trace.fpt,"icheck not here!\n");
Full_tracer_advection.c:806:            fflush(E->trace.fpt);
Full_tracer_advection.c:817:          E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:819:        for (pp=0;pp<=(E->trace.number_of_tracer_quantities-1);pp++) {
Full_tracer_advection.c:821:            send[ithatcap][ipos]=E->trace.rlater[pp][kk];
Full_tracer_advection.c:875:    int maxlevel=E->mesh.levmax;
Full_tracer_advection.c:910:                    fprintf(E->trace.fpt,"ERROR(gnomonic_interpolation)-inum>3!\n");
Full_tracer_advection.c:911:                    fflush(E->trace.fpt);
Full_tracer_advection.c:916:                    fprintf(E->trace.fpt,"ERROR(gnomonic_interpolation)-inum>1\n");
Full_tracer_advection.c:917:                    fprintf(E->trace.fpt,"shape %f %f %f\n",shape2d[1],shape2d[2],shape2d[3]);
Full_tracer_advection.c:918:                    fprintf(E->trace.fpt,"u %f v %f element: %d \n",u,v, nelem);
Full_tracer_advection.c:919:                    fprintf(E->trace.fpt,"Element uv boundaries: \n");
Full_tracer_advection.c:921:                        i = (E->ien[nelem].node[kk] - 1) / E->lmesh.noz + 1;
Full_tracer_advection.c:922:                        fprintf(E->trace.fpt,"%d: U: %f V:%f\n",kk,E->gnomonic[i].u,E->gnomonic[i].v);
Full_tracer_advection.c:924:                    fprintf(E->trace.fpt,"theta: %f phi: %f rad: %f\n",theta,phi,rad);
Full_tracer_advection.c:925:                    fprintf(E->trace.fpt,"Element theta-phi boundaries: \n");
Full_tracer_advection.c:927:                        fprintf(E->trace.fpt,"%d: Theta: %f Phi:%f\n",kk,E->sx[1][E->ien[nelem].node[kk]],E->sx[2][E->ien[nelem].node[kk]]);
Full_tracer_advection.c:930:                    fprintf(E->trace.fpt,"ICHECK?: %d\n",ival);
Full_tracer_advection.c:931:                    ival=(E->trace.iget_element)(E,-99,x,y,z,theta,phi,rad);
Full_tracer_advection.c:932:                    fprintf(E->trace.fpt,"New Element?: %d\n",ival);
Full_tracer_advection.c:934:                    fprintf(E->trace.fpt,"New Element (neighs)?: %d\n",ival);
Full_tracer_advection.c:937:                    fprintf(E->trace.fpt,"ICHECK?: %d\n",ival);
Full_tracer_advection.c:940:                    fprintf(E->trace.fpt,"NO LUCK\n");
Full_tracer_advection.c:941:                    fflush(E->trace.fpt);
Full_tracer_advection.c:969:    fprintf(E->trace.fpt, "shp: %e %e %e %e %e %e\n",
Full_tracer_advection.c:1105:    int n = (nelem - 1) / E->lmesh.elz + 1;
Full_tracer_advection.c:1109:    a0=E->trace.shape_coefs[j][iwedge][1][n];
Full_tracer_advection.c:1110:    a1=E->trace.shape_coefs[j][iwedge][2][n];
Full_tracer_advection.c:1111:    a2=E->trace.shape_coefs[j][iwedge][3][n];
Full_tracer_advection.c:1117:    a0=E->trace.shape_coefs[j][iwedge][4][n];
Full_tracer_advection.c:1118:    a1=E->trace.shape_coefs[j][iwedge][5][n];
Full_tracer_advection.c:1119:    a2=E->trace.shape_coefs[j][iwedge][6][n];
Full_tracer_advection.c:1125:    a0=E->trace.shape_coefs[j][iwedge][7][n];
Full_tracer_advection.c:1126:    a1=E->trace.shape_coefs[j][iwedge][8][n];
Full_tracer_advection.c:1127:    a2=E->trace.shape_coefs[j][iwedge][9][n];
Full_tracer_advection.c:1150:    node1=E->ien[nelem].node[1];
Full_tracer_advection.c:1151:    node5=E->ien[nelem].node[5];
Full_tracer_advection.c:1153:    rad1=E->sx[3][node1];
Full_tracer_advection.c:1154:    rad5=E->sx[3][node5];
Full_tracer_advection.c:1176:            fprintf(E->trace.fpt,"ERROR(get_radial_shape)\n");
Full_tracer_advection.c:1177:            fprintf(E->trace.fpt,"shaperad[1]: %f \n",shaperad[1]);
Full_tracer_advection.c:1178:            fprintf(E->trace.fpt,"shaperad[2]: %f \n",shaperad[2]);
Full_tracer_advection.c:1179:            fflush(E->trace.fpt);
Full_tracer_advection.c:1205:    phi_f = E->gnomonic_reference_phi;
Full_tracer_advection.c:1207:    cos_theta_f = E->gnomonic[0].u;
Full_tracer_advection.c:1208:    sin_theta_f = E->gnomonic[0].v;
Full_tracer_advection.c:1279:    elz=E->lmesh.elz;
Full_tracer_advection.c:1281:    nelsurf=E->lmesh.elx*E->lmesh.ely;
Full_tracer_advection.c:1296:    expansion=2.0*0.5*(M_PI/4.0)/(1.0*E->lmesh.elx);
Full_tracer_advection.c:1300:    if (E->parallel.me==0) fprintf(stderr,"Generating Regular Grid\n");
Full_tracer_advection.c:1313:    for (kk=1;kk<=E->lmesh.nno;kk=kk+E->lmesh.noz) {
Full_tracer_advection.c:1314:      theta=E->sx[1][kk];
Full_tracer_advection.c:1315:      phi=E->sx[2][kk];
Full_tracer_advection.c:1327:    deltheta=E->trace.deltheta*M_PI/180.0;
Full_tracer_advection.c:1328:    delphi=E->trace.delphi*M_PI/180.0;
Full_tracer_advection.c:1340:      fprintf(E->trace.fpt,"Error(make_regular_grid): numtheta: %d numphi: %d\n",numtheta,numphi);
Full_tracer_advection.c:1341:      fflush(E->trace.fpt);
Full_tracer_advection.c:1350:    E->trace.deltheta=deltheta;
Full_tracer_advection.c:1351:    E->trace.delphi=delphi;
Full_tracer_advection.c:1352:    E->trace.numtheta=numtheta;
Full_tracer_advection.c:1353:    E->trace.numphi=numphi;
Full_tracer_advection.c:1354:    E->trace.thetamax=thetamax;
Full_tracer_advection.c:1355:    E->trace.thetamin=thetamin;
Full_tracer_advection.c:1356:    E->trace.phimax=phimax;
Full_tracer_advection.c:1357:    E->trace.phimin=phimin;
Full_tracer_advection.c:1358:    E->trace.numregel=numregel;
Full_tracer_advection.c:1359:    E->trace.numregnodes=numregnodes;
Full_tracer_advection.c:1361:    if ( ((1.0*numregel)/(1.0*E->lmesh.elx*E->lmesh.ely)) < 0.5 ) {
Full_tracer_advection.c:1362:      fprintf(E->trace.fpt,"\n ! WARNING: regular/real ratio low: %f ! \n",
Full_tracer_advection.c:1363:      ((1.0*numregel)/(1.0*E->lmesh.nel)) );
Full_tracer_advection.c:1364:      fprintf(E->trace.fpt," Should reduce size of regular mesh\n");
Full_tracer_advection.c:1366:      ((1.0*numregel)/(1.0*E->lmesh.nel)) );
Full_tracer_advection.c:1368:      fflush(E->trace.fpt);
Full_tracer_advection.c:1369:      if (E->trace.itracer_warnings) 
Full_tracer_advection.c:1375:    fprintf(E->trace.fpt,"\nRegular grid:\n");
Full_tracer_advection.c:1376:    fprintf(E->trace.fpt,"Theta min: %f max: %f \n",thetamin,thetamax);
Full_tracer_advection.c:1377:    fprintf(E->trace.fpt,"Phi min: %f max: %f \n",phimin,phimax);
Full_tracer_advection.c:1378:    fprintf(E->trace.fpt,"Adjusted deltheta: %f delphi: %f\n",deltheta,delphi);
Full_tracer_advection.c:1379:    fprintf(E->trace.fpt,"(numtheta: %d  numphi: %d)\n",numtheta,numphi);
Full_tracer_advection.c:1380:    fprintf(E->trace.fpt,"Number of regular elements: %d  (nodes: %d)\n",
Full_tracer_advection.c:1382:    fprintf(E->trace.fpt,"regular/real ratio: %f\n",
Full_tracer_advection.c:1383:        ((1.0*numregel)/(1.0*E->lmesh.elx*E->lmesh.ely)));
Full_tracer_advection.c:1384:    fflush(E->trace.fpt);
Full_tracer_advection.c:1391:    if((E->trace.regnodetoel=
Full_tracer_advection.c:1393:      fprintf(E->trace.fpt,"ERROR(make regular) -no memory - uh3ud\n");
Full_tracer_advection.c:1394:      fflush(E->trace.fpt);
Full_tracer_advection.c:1402:      E->trace.regnodetoel[kk]=-99;
Full_tracer_advection.c:1407:    if (E->parallel.me==0) 
Full_tracer_advection.c:1413:      fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:1414:      fflush(E->trace.fpt);
Full_tracer_advection.c:1418:      fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:1419:      fflush(E->trace.fpt);
Full_tracer_advection.c:1423:      fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:1424:      fflush(E->trace.fpt);
Full_tracer_advection.c:1428:      fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:1429:      fflush(E->trace.fpt);
Full_tracer_advection.c:1433:    for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz) {
Full_tracer_advection.c:1440:        node=E->ien[mm].node[pp];
Full_tracer_advection.c:1441:        theta=E->sx[1][node];
Full_tracer_advection.c:1442:        phi=E->sx[2][node];
Full_tracer_advection.c:1480:    rad=E->sphere.ro;
Full_tracer_advection.c:1485:      E->trace.regnodetoel[kk]=-99;
Full_tracer_advection.c:1504:        E->trace.regnodetoel[kk]=ilast_el;
Full_tracer_advection.c:1511:        E->trace.regnodetoel[kk]=ival;
Full_tracer_advection.c:1517:      for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz) {
Full_tracer_advection.c:1524:            E->trace.regnodetoel[kk]=mm;
Full_tracer_advection.c:1530:      if (E->trace.regnodetoel[kk]>0) 
Full_tracer_advection.c:1535:    fprintf(E->trace.fpt,"percentage mapped: %f\n", 
Full_tracer_advection.c:1537:    fflush(E->trace.fpt);
Full_tracer_advection.c:1548:      if (E->trace.regnodetoel[kk]!=-99) {
Full_tracer_advection.c:1549:        if ((E->trace.regnodetoel[kk]<1)||
Full_tracer_advection.c:1550:            (E->trace.regnodetoel[kk]>E->lmesh.nel) ) {
Full_tracer_advection.c:1553:                    E->trace.regnodetoel[kk]);
Full_tracer_advection.c:1554:                fprintf(E->trace.fpt,
Full_tracer_advection.c:1556:                    E->trace.regnodetoel[kk]);
Full_tracer_advection.c:1557:                fflush(E->trace.fpt);
Full_tracer_advection.c:1568:    if (E->parallel.me==0) fprintf(stderr,"Beginning Regtoel submapping \n");
Full_tracer_advection.c:1595:    numregel= E->trace.numregel;
Full_tracer_advection.c:1598:      if ((E->trace.regtoel[pp]=
Full_tracer_advection.c:1600:        fprintf(E->trace.fpt,"ERROR(make regular)-no memory 98d (%d %d)\n",
Full_tracer_advection.c:1602:        fflush(E->trace.fpt);
Full_tracer_advection.c:1607:    numtheta=E->trace.numtheta;
Full_tracer_advection.c:1608:    numphi=E->trace.numphi;
Full_tracer_advection.c:1618:        E->trace.regtoel[pp][iregel]=-33;
Full_tracer_advection.c:1621:        fprintf(E->trace.fpt,
Full_tracer_advection.c:1624:        fflush(E->trace.fpt);
Full_tracer_advection.c:1630:      iregnode[3]=iregel+nphi+E->trace.numtheta+1;
Full_tracer_advection.c:1631:      iregnode[4]=iregel+nphi+E->trace.numtheta;
Full_tracer_advection.c:1635:          fprintf(E->trace.fpt,"ERROR(make regular)-bad regnode %d\n",
Full_tracer_advection.c:1637:          fflush(E->trace.fpt);
Full_tracer_advection.c:1640:        if (E->trace.regnodetoel[iregnode[kk]]>E->lmesh.nel) {
Full_tracer_advection.c:1641:          fprintf(E->trace.fpt,"AABB HERE %d %d %d %d\n",iregel,
Full_tracer_advection.c:1643:              E->trace.regnodetoel[iregnode[kk]]);
Full_tracer_advection.c:1644:          fflush(E->trace.fpt);
Full_tracer_advection.c:1655:        if (E->trace.regnodetoel[iregnode[kk]]<=0) 
Full_tracer_advection.c:1660:          if(E->trace.regnodetoel[iregnode[kk]]==
Full_tracer_advection.c:1661:              E->trace.regnodetoel[iregnode[pp]]) 
Full_tracer_advection.c:1665:        itemp[ichoice]=E->trace.regnodetoel[iregnode[kk]];
Full_tracer_advection.c:1668:          fprintf(E->trace.fpt,"ERROR(make regular) - weird ichoice %d \n",
Full_tracer_advection.c:1670:          fflush(E->trace.fpt);
Full_tracer_advection.c:1674:        if ((itemp[ichoice]<0) || (itemp[ichoice]>E->lmesh.nel) ) {
Full_tracer_advection.c:1675:          fprintf(E->trace.fpt,"ERROR(make regular) - weird element choice %d %d\n",itemp[ichoice],ichoice);
Full_tracer_advection.c:1676:          fflush(E->trace.fpt);
Full_tracer_advection.c:1687:        fprintf(E->trace.fpt,"ERROR(make_regular)-wierd ichoice %d\n",ichoice);
Full_tracer_advection.c:1688:        fflush(E->trace.fpt);
Full_tracer_advection.c:1693:        E->trace.regtoel[0][iregel]=-1;
Full_tracer_advection.c:1696:        E->trace.regtoel[0][iregel]=0;
Full_tracer_advection.c:1697:        E->trace.regtoel[1][iregel]=itemp[1];
Full_tracer_advection.c:1698:        if (itemp[1]<1 || itemp[1]>E->lmesh.nel) {
Full_tracer_advection.c:1699:          fprintf(E->trace.fpt,"ERROR(make_regular)-huh? wierd itemp\n");
Full_tracer_advection.c:1700:          fflush(E->trace.fpt);
Full_tracer_advection.c:1705:        E->trace.regtoel[0][iregel]=ichoice;
Full_tracer_advection.c:1707:          E->trace.regtoel[pp][iregel]=itemp[pp];
Full_tracer_advection.c:1708:          if (itemp[pp]<1 || itemp[pp]>E->lmesh.nel) {
Full_tracer_advection.c:1709:            fprintf(E->trace.fpt,"ERROR(make_regular)-huh? wierd itemp 2\n");
Full_tracer_advection.c:1710:            fflush(E->trace.fpt);
Full_tracer_advection.c:1716:        fprintf(E->trace.fpt,"ERROR(make_regular)- should not be here! %d\n",
Full_tracer_advection.c:1718:        fflush(E->trace.fpt);
Full_tracer_advection.c:1725:  free (E->trace.regnodetoel);
Full_tracer_advection.c:1729:  for (kk=1;kk<=E->trace.numregel;kk++) {
Full_tracer_advection.c:1730:    if ((E->trace.regtoel[0][kk]<-1)||(E->trace.regtoel[0][kk]>4)) {
Full_tracer_advection.c:1731:      fprintf(E->trace.fpt,"ERROR(make regular) regtoel ichoice0? %d %d \n",kk,E->trace.regtoel[pp][kk]);
Full_tracer_advection.c:1732:      fflush(E->trace.fpt);
Full_tracer_advection.c:1736:      if (((E->trace.regtoel[pp][kk]<1)&&(E->trace.regtoel[pp][kk]!=-33))||
Full_tracer_advection.c:1737:          (E->trace.regtoel[pp][kk]>E->lmesh.nel)) {
Full_tracer_advection.c:1738:        fprintf(E->trace.fpt,"ERROR(make regular) (%p) regtoel? %d %d(%d) %d\n",
Full_tracer_advection.c:1739:            &E->trace.regtoel[pp][kk],kk,pp,
Full_tracer_advection.c:1740:            E->trace.regtoel[0][kk],E->trace.regtoel[pp][kk]);
Full_tracer_advection.c:1741:        fflush(E->trace.fpt);
Full_tracer_advection.c:1748:  fprintf(E->trace.fpt, "Mapping completed (%f seconds)\n",
Full_tracer_advection.c:1750:  fflush(E->trace.fpt);
Full_tracer_advection.c:1754:  if (E->parallel.me==0) 
Full_tracer_advection.c:1761:  fprintf(E->trace.fpt,"\n\nInformation regarding number of real elements per regular elements\n");
Full_tracer_advection.c:1762:  fprintf(E->trace.fpt," (stats done on regular elements that were used)\n");
Full_tracer_advection.c:1763:  fprintf(E->trace.fpt,"Ichoice is number of real elements touched by a regular element\n");
Full_tracer_advection.c:1764:  fprintf(E->trace.fpt,"  (ichoice=0 is optimal)\n");
Full_tracer_advection.c:1765:  fprintf(E->trace.fpt,"Ichoice=0: %f percent\n",(100.0*istat_ichoice[0])/(1.0*isum));
Full_tracer_advection.c:1766:  fprintf(E->trace.fpt,"Ichoice=1: %f percent\n",(100.0*istat_ichoice[1])/(1.0*isum));
Full_tracer_advection.c:1767:  fprintf(E->trace.fpt,"Ichoice=2: %f percent\n",(100.0*istat_ichoice[2])/(1.0*isum));
Full_tracer_advection.c:1768:  fprintf(E->trace.fpt,"Ichoice=3: %f percent\n",(100.0*istat_ichoice[3])/(1.0*isum));
Full_tracer_advection.c:1769:  fprintf(E->trace.fpt,"Ichoice=4: %f percent\n",(100.0*istat_ichoice[4])/(1.0*isum));
Full_tracer_advection.c:1779:    fprintf(E->trace.fpt,"\nTracing Activated! (proc: %d)\n",E->parallel.me);
Full_tracer_advection.c:1780:    fprintf(E->trace.fpt,"   Allen K. McNamara 12-2003\n\n");
Full_tracer_advection.c:1782:    if (E->trace.ic_method==0)
Full_tracer_advection.c:1784:            fprintf(E->trace.fpt,"Generating New Tracer Array\n");
Full_tracer_advection.c:1785:            fprintf(E->trace.fpt,"Tracers per element: %d\n",E->trace.itperel);
Full_tracer_advection.c:1787:    if (E->trace.ic_method==1)
Full_tracer_advection.c:1789:            fprintf(E->trace.fpt,"Reading tracer file %s\n",E->trace.tracer_file);
Full_tracer_advection.c:1791:    if (E->trace.ic_method==2)
Full_tracer_advection.c:1793:            fprintf(E->trace.fpt,"Reading individual tracer files\n");
Full_tracer_advection.c:1796:    fprintf(E->trace.fpt,"Number of tracer flavors: %d\n", E->trace.nflavors);
Full_tracer_advection.c:1798:    if (E->trace.nflavors && E->trace.ic_method==0) {
Full_tracer_advection.c:1799:        fprintf(E->trace.fpt,"Initialized tracer flavors by: %d\n", E->trace.ic_method_for_flavors);
Full_tracer_advection.c:1800:        if (E->trace.ic_method_for_flavors == 0) {
Full_tracer_advection.c:1802:            fprintf(E->trace.fpt,"Layered tracer flavors\n");
Full_tracer_advection.c:1803:            for (i=0; i<E->trace.nflavors-1; i++)
Full_tracer_advection.c:1804:                fprintf(E->trace.fpt,"Interface Height: %d %f\n",i,E->trace.z_interface[i]);
Full_tracer_advection.c:1807:	else if((E->trace.ic_method_for_flavors == 1)||(E->trace.ic_method_for_flavors == 99)) {
Full_tracer_advection.c:1809:            fprintf(E->trace.fpt,"netcdf grd assigned tracer flavors\n");
Full_tracer_advection.c:1810:	    if( E->trace.ggrd_layers > 0)
Full_tracer_advection.c:1811:	      fprintf(E->trace.fpt,"file: %s top %i layers\n",E->trace.ggrd_file,
Full_tracer_advection.c:1812:		      E->trace.ggrd_layers);
Full_tracer_advection.c:1814:	      fprintf(E->trace.fpt,"file: %s only layer %i\n",E->trace.ggrd_file,
Full_tracer_advection.c:1815:		      -E->trace.ggrd_layers);
Full_tracer_advection.c:1820:            fprintf(E->trace.fpt,"Sorry-This IC methods for Flavors are Unavailable %d\n",E->trace.ic_method_for_flavors);
Full_tracer_advection.c:1821:            fflush(E->trace.fpt);
Full_tracer_advection.c:1826:    for (i=0; i<E->trace.nflavors-2; i++) {
Full_tracer_advection.c:1827:        if (E->trace.z_interface[i] < E->trace.z_interface[i+1]) {
Full_tracer_advection.c:1828:            fprintf(E->trace.fpt,"Sorry - The %d-th z_interface is smaller than the next one.\n", i);
Full_tracer_advection.c:1829:            fflush(E->trace.fpt);
Full_tracer_advection.c:1838:    fprintf(E->trace.fpt,"Regular Grid-> deltheta: %f delphi: %f\n",
Full_tracer_advection.c:1839:            E->trace.deltheta,E->trace.delphi);
Full_tracer_advection.c:1846:    fprintf(E->trace.fpt,"Box Cushion: %f\n",E->trace.box_cushion);
Full_tracer_advection.c:1847:    fprintf(E->trace.fpt,"Number of Basic Quantities: %d\n",
Full_tracer_advection.c:1848:            E->trace.number_of_basic_quantities);
Full_tracer_advection.c:1849:    fprintf(E->trace.fpt,"Number of Extra Quantities: %d\n",
Full_tracer_advection.c:1850:            E->trace.number_of_extra_quantities);
Full_tracer_advection.c:1851:    fprintf(E->trace.fpt,"Total Number of Tracer Quantities: %d\n",
Full_tracer_advection.c:1852:            E->trace.number_of_tracer_quantities);
Full_tracer_advection.c:1857:    if (E->trace.ianalytical_tracer_test==1)
Full_tracer_advection.c:1859:            fprintf(E->trace.fpt,"\n\n ! Analytical Test Being Performed ! \n");
Full_tracer_advection.c:1860:            fprintf(E->trace.fpt,"(some of the above parameters may not be used or applied\n");
Full_tracer_advection.c:1861:            fprintf(E->trace.fpt,"Velocity functions given in main code\n");
Full_tracer_advection.c:1862:            fflush(E->trace.fpt);
Full_tracer_advection.c:1865:    if (E->trace.itracer_warnings==0)
Full_tracer_advection.c:1867:            fprintf(E->trace.fpt,"\n WARNING EXITS ARE TURNED OFF! TURN THEM ON!\n");
Full_tracer_advection.c:1869:            fflush(E->trace.fpt);
Full_tracer_advection.c:1902:    elx=E->lmesh.elx;
Full_tracer_advection.c:1903:    ely=E->lmesh.ely;
Full_tracer_advection.c:1904:    elz=E->lmesh.elz;
Full_tracer_advection.c:1942:            if ((neighbor[kk]>=1)&&(neighbor[kk]<=E->lmesh.nel))
Full_tracer_advection.c:1970:    int elz=E->lmesh.elz;
Full_tracer_advection.c:1971:    int numel=E->lmesh.nel;
Full_tracer_advection.c:2033:    ibottom_node=E->ien[nel].node[1];
Full_tracer_advection.c:2034:    itop_node=E->ien[nel].node[5];
Full_tracer_advection.c:2036:    bottom_rad=E->sx[3][ibottom_node];
Full_tracer_advection.c:2037:    top_rad=E->sx[3][itop_node];
Full_tracer_advection.c:2059:    int lev = E->mesh.levmax;
Full_tracer_advection.c:2065:    E->trace.istat_elements_checked++;
Full_tracer_advection.c:2072:            node=E->ien[nel].node[kk+4];
Full_tracer_advection.c:2074:            rnode[kk][1]=E->x[1][node];
Full_tracer_advection.c:2075:            rnode[kk][2]=E->x[2][node];
Full_tracer_advection.c:2076:            rnode[kk][3]=E->x[3][node];
Full_tracer_advection.c:2078:            rnode[kk][4]=E->sx[1][node];
Full_tracer_advection.c:2079:            rnode[kk][5]=E->sx[2][node];
Full_tracer_advection.c:2081:            rnode[kk][6]=E->SinCos[lev][2][node]; /* cos(theta) */
Full_tracer_advection.c:2082:            rnode[kk][7]=E->SinCos[lev][0][node]; /* sin(theta) */
Full_tracer_advection.c:2083:            rnode[kk][8]=E->SinCos[lev][3][node]; /* cos(phi) */
Full_tracer_advection.c:2084:            rnode[kk][9]=E->SinCos[lev][1][node]; /* sin(phi) */
Full_tracer_advection.c:2122:            rnode[kk][1]=E->trace.xcap[icap][kk];
Full_tracer_advection.c:2123:            rnode[kk][2]=E->trace.ycap[icap][kk];
Full_tracer_advection.c:2124:            rnode[kk][3]=E->trace.zcap[icap][kk];
Full_tracer_advection.c:2125:            rnode[kk][4]=E->trace.theta_cap[icap][kk];
Full_tracer_advection.c:2126:            rnode[kk][5]=E->trace.phi_cap[icap][kk];
Full_tracer_advection.c:2127:            rnode[kk][6]=E->trace.cos_theta[icap][kk];
Full_tracer_advection.c:2128:            rnode[kk][7]=E->trace.sin_theta[icap][kk];
Full_tracer_advection.c:2129:            rnode[kk][8]=E->trace.cos_phi[icap][kk];
Full_tracer_advection.c:2130:            rnode[kk][9]=E->trace.sin_phi[icap][kk];
Full_tracer_advection.c:2233:            fprintf(E->trace.fpt,"Error(icheck_bounds)-too many tries\n");
Full_tracer_advection.c:2234:            fprintf(E->trace.fpt,"Rads: %f %f %f %f\n",rad1,rad2,rad3,rad4);
Full_tracer_advection.c:2235:            fprintf(E->trace.fpt,"Test Point: %f %f %f  \n",test_point[1],test_point[2],test_point[3]);
Full_tracer_advection.c:2236:            fprintf(E->trace.fpt,"Nodal points: 1: %f %f %f\n",rnode1[1],rnode1[2],rnode1[3]);
Full_tracer_advection.c:2237:            fprintf(E->trace.fpt,"Nodal points: 2: %f %f %f\n",rnode2[1],rnode2[2],rnode2[3]);
Full_tracer_advection.c:2238:            fprintf(E->trace.fpt,"Nodal points: 3: %f %f %f\n",rnode3[1],rnode3[2],rnode3[3]);
Full_tracer_advection.c:2239:            fprintf(E->trace.fpt,"Nodal points: 4: %f %f %f\n",rnode4[1],rnode4[2],rnode4[3]);
Full_tracer_advection.c:2240:            fflush(E->trace.fpt);
Full_tracer_advection.c:2280:      fprintf(stderr,"%d: icheck: %d\n",E->parallel.me,icheck);
Full_tracer_advection.c:2281:      fprintf(stderr,"%d: rads: %f %f %f %f\n",E->parallel.me,rad1,rad2,rad3,rad4);
Full_tracer_advection.c:2350:    max_radius = E->sphere.ro - E->trace.box_cushion;
Full_tracer_advection.c:2351:    min_radius = E->sphere.ri + E->trace.box_cushion;
Full_tracer_advection.c:2448:    elx=E->lmesh.elx;
Full_tracer_advection.c:2449:    ely=E->lmesh.ely;
Full_tracer_advection.c:2450:    elz=E->lmesh.elz;
Full_tracer_advection.c:2457:    if (E->parallel.nprocz>1)
Full_tracer_advection.c:2480:    if (E->trace.regtoel[0][iregel]==0)
Full_tracer_advection.c:2482:            iel=E->trace.regtoel[1][iregel];
Full_tracer_advection.c:2501:    if (E->trace.regtoel[0][iregel]>0)
Full_tracer_advection.c:2504:            ichoice=E->trace.regtoel[0][iregel];
Full_tracer_advection.c:2507:                    nelem=E->trace.regtoel[kk][iregel];
Full_tracer_advection.c:2571:                            ineighbor=E->trace.regtoel[kk][iregel];
Full_tracer_advection.c:2584:    E->trace.istat1++;
Full_tracer_advection.c:2589:      fprintf(E->trace.fpt,"WARNING(full_iget_element)-doing a full search!\n");
Full_tracer_advection.c:2590:      fprintf(E->trace.fpt,"  Most often means tracers have moved more than 1 element away\n");
Full_tracer_advection.c:2591:      fprintf(E->trace.fpt,"  or regular element resolution is way too low.\n");
Full_tracer_advection.c:2592:      fprintf(E->trace.fpt,"  COLUMN: %d \n",iel);
Full_tracer_advection.c:2593:      fprintf(E->trace.fpt,"  PREVIOUS ELEMENT: %d \n",iprevious_element);
Full_tracer_advection.c:2594:      fprintf(E->trace.fpt,"  x,y,z,theta,phi,rad: %f %f %f   %f %f %f\n",x,y,z,theta,phi,rad);
Full_tracer_advection.c:2595:      fflush(E->trace.fpt);
Full_tracer_advection.c:2596:      if (E->trace.itracer_warnings) exit(10);
Full_tracer_advection.c:2599:    if (E->trace.istat1%100==0)
Full_tracer_advection.c:2601:            fprintf(E->trace.fpt,"Checked all elements %d times already this turn\n",E->trace.istat1);
Full_tracer_advection.c:2602:            fflush(E->trace.fpt);
Full_tracer_advection.c:2612:    fprintf(E->trace.fpt,"Error(full_iget_element) - element not found\n");
Full_tracer_advection.c:2613:    fprintf(E->trace.fpt,"x,y,z,theta,phi,iregel %.15e %.15e %.15e %.15e %.15e %d\n",
Full_tracer_advection.c:2615:    fflush(E->trace.fpt);
Full_tracer_advection.c:2638:    int elz=E->lmesh.elz;
Full_tracer_advection.c:2657:            node=E->ien[iradial_element].node[8];
Full_tracer_advection.c:2658:            top_rad=E->sx[3][node];
Full_tracer_advection.c:2669:    fprintf(E->trace.fpt,"Error(iget_radial_element)-out of range %f %d %d\n",rad,iel,ibottom_element);
Full_tracer_advection.c:2670:    fflush(E->trace.fpt);
Full_tracer_advection.c:2697:    if (theta<E->trace.thetamin) return -99;
Full_tracer_advection.c:2698:    if (theta>E->trace.thetamax) return -99;
Full_tracer_advection.c:2702:    rdum=theta-E->trace.thetamin;
Full_tracer_advection.c:2703:    idum=rdum/E->trace.deltheta;
Full_tracer_advection.c:2706:    rdum=phi-E->trace.phimin;
Full_tracer_advection.c:2707:    idum=rdum/E->trace.delphi;
Full_tracer_advection.c:2710:    iregel=*ntheta+(*nphi-1)*E->trace.numtheta;
Full_tracer_advection.c:2714:    if (iregel>E->trace.numregel) return -99;
Full_tracer_advection.c:2726:/* E->gnomonic[node].u = u                                      */
Full_tracer_advection.c:2727:/* E->gnomonic[node].v = v                                      */
Full_tracer_advection.c:2731:    const int lev = E->mesh.levmax;
Full_tracer_advection.c:2738:    if ((E->gnomonic = malloc((E->lmesh.nsf+1)*sizeof(struct CITCOM_GNOMONIC)))
Full_tracer_advection.c:2744:    sint = E->SinCos[lev][0];
Full_tracer_advection.c:2745:    sinf = E->SinCos[lev][1];
Full_tracer_advection.c:2746:    cost = E->SinCos[lev][2];
Full_tracer_advection.c:2747:    cosf = E->SinCos[lev][3];
Full_tracer_advection.c:2751:    refnode = 1 + E->lmesh.noz * ((E->lmesh.noy / 2) * E->lmesh.nox
Full_tracer_advection.c:2752:                                  + E->lmesh.nox / 2);
Full_tracer_advection.c:2753:    phi_f = E->gnomonic_reference_phi = E->sx[2][refnode];
Full_tracer_advection.c:2756:    theta_f = E->sx[j][1][refnode];
Full_tracer_advection.c:2757:    for (i=1; i<=E->lmesh.nsf; i++) {
Full_tracer_advection.c:2758:        fprintf(E->trace.fpt, "i=%d (%e %e %e %e)\n",
Full_tracer_advection.c:2761:    fprintf(E->trace.fpt, "%d %d %d ref=(%e %e)\n",
Full_tracer_advection.c:2762:            E->lmesh.noz, E->lmesh.nsf, refnode, theta_f, phi_f);
Full_tracer_advection.c:2766:    E->gnomonic[0].u = cost[refnode];
Full_tracer_advection.c:2767:    E->gnomonic[0].v = sint[refnode];
Full_tracer_advection.c:2772:    for (i=1, n=1; i<=E->lmesh.nsf; i++, n+=E->lmesh.noz) {
Full_tracer_advection.c:2773:        dphi = E->sx[2][n] - phi_f;
Full_tracer_advection.c:2780:        E->gnomonic[i].u = u;
Full_tracer_advection.c:2781:        E->gnomonic[i].v = v;
Full_tracer_advection.c:2784:        fprintf(E->trace.fpt, "n=%d ns=%d cosc=%e (%e %e) -> (%e %e)\n",
Full_tracer_advection.c:2785:                n, i, cosc, E->sx[j][1][n], E->sx[j][2][n], u, v);
Full_tracer_advection.c:2820:            if ((E->trace.shape_coefs[j][iwedge][kk] =
Full_tracer_advection.c:2821:                 (double *)malloc((E->lmesh.snel+1)*sizeof(double))) == NULL) {
Full_tracer_advection.c:2822:                fprintf(E->trace.fpt,"ERROR(find shape coefs)-not enough memory(a)\n");
Full_tracer_advection.c:2823:                fflush(E->trace.fpt);
Full_tracer_advection.c:2829:    for (i=1, nelem=1; i<=E->lmesh.snel; i++, nelem+=E->lmesh.elz) {
Full_tracer_advection.c:2834:            snode = (E->ien[nelem].node[kk]-1) / E->lmesh.noz + 1;
Full_tracer_advection.c:2835:            u[kk] = E->gnomonic[snode].u;
Full_tracer_advection.c:2836:            v[kk] = E->gnomonic[snode].v;
Full_tracer_advection.c:2865:            E->trace.shape_coefs[j][iwedge][1][i] = a0;
Full_tracer_advection.c:2866:            E->trace.shape_coefs[j][iwedge][2][i] = a1;
Full_tracer_advection.c:2867:            E->trace.shape_coefs[j][iwedge][3][i] = a2;
Full_tracer_advection.c:2876:            E->trace.shape_coefs[j][iwedge][4][i] = a0;
Full_tracer_advection.c:2877:            E->trace.shape_coefs[j][iwedge][5][i] = a1;
Full_tracer_advection.c:2878:            E->trace.shape_coefs[j][iwedge][6][i] = a2;
Full_tracer_advection.c:2887:            E->trace.shape_coefs[j][iwedge][7][i] = a0;
Full_tracer_advection.c:2888:            E->trace.shape_coefs[j][iwedge][8][i] = a1;
Full_tracer_advection.c:2889:            E->trace.shape_coefs[j][iwedge][9][i] = a2;
Full_tracer_advection.c:2892:            fprintf(E->trace.fpt, "el=%d els=%d iwedge=%d shape=(%e %e %e, %e %e %e, %e %e %e)\n",
Full_tracer_advection.c:2894:                    E->trace.shape_coefs[j][iwedge][1][i],
Full_tracer_advection.c:2895:                    E->trace.shape_coefs[j][iwedge][2][i],
Full_tracer_advection.c:2896:                    E->trace.shape_coefs[j][iwedge][3][i],
Full_tracer_advection.c:2897:                    E->trace.shape_coefs[j][iwedge][4][i],
Full_tracer_advection.c:2898:                    E->trace.shape_coefs[j][iwedge][5][i],
Full_tracer_advection.c:2899:                    E->trace.shape_coefs[j][iwedge][6][i],
Full_tracer_advection.c:2900:                    E->trace.shape_coefs[j][iwedge][7][i],
Full_tracer_advection.c:2901:                    E->trace.shape_coefs[j][iwedge][8][i],
Full_tracer_advection.c:2902:                    E->trace.shape_coefs[j][iwedge][9][i]);
Full_tracer_advection.c:2973:    fprintf(E->trace.fpt,"Starting Analytical Test\n");
Full_tracer_advection.c:2974:    if (E->parallel.me==0) fprintf(stderr,"Starting Analytical Test\n");
Full_tracer_advection.c:2975:    fflush(E->trace.fpt);
Full_tracer_advection.c:2979:    E->trace.box_cushion=0.0000;
Full_tracer_advection.c:2986:    E->advection.timestep=dt;
Full_tracer_advection.c:2988:    fprintf(E->trace.fpt,"steps: %d  dt: %f\n",nsteps,dt);
Full_tracer_advection.c:2992:    for (kk=1;kk<=E->lmesh.nno;kk++) {
Full_tracer_advection.c:2994:      theta=E->sx[1][kk];
Full_tracer_advection.c:2995:      phi=E->sx[2][kk];
Full_tracer_advection.c:2996:      rad=E->sx[3][kk];
Full_tracer_advection.c:3000:      E->sphere.cap.V[1][kk]=vel_s[1];
Full_tracer_advection.c:3001:      E->sphere.cap.V[2][kk]=vel_s[2];
Full_tracer_advection.c:3002:      E->sphere.cap.V[3][kk]=vel_s[3];
Full_tracer_advection.c:3014:    if (E->trace.ntracers[j]>10) {
Full_tracer_advection.c:3015:      fprintf(E->trace.fpt,"Warning(analytical)-too many tracers to print!\n");
Full_tracer_advection.c:3016:      fflush(E->trace.fpt);
Full_tracer_advection.c:3017:      if (E->trace.itracer_warnings) exit(10);
Full_tracer_advection.c:3022:    E->monitor.solution_cycles=0;
Full_tracer_advection.c:3023:    for (pp=1;pp<=E->trace.ntracers;pp++) {
Full_tracer_advection.c:3024:      theta=E->trace.basicq[0][pp];
Full_tracer_advection.c:3025:      phi=E->trace.basicq[1][pp];
Full_tracer_advection.c:3026:      rad=E->trace.basicq[2][pp];
Full_tracer_advection.c:3028:      fprintf(E->trace.fpt,"(%d) time: %f theta: %f phi: %f rad: %f\n",
Full_tracer_advection.c:3029:          E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:3033:            E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:3044:      E->monitor.solution_cycles=kk;
Full_tracer_advection.c:3051:      for (pp=1;pp<=E->trace.ntracers;pp++) {
Full_tracer_advection.c:3052:        theta=E->trace.basicq[0][pp];
Full_tracer_advection.c:3053:        phi=E->trace.basicq[1][pp];
Full_tracer_advection.c:3054:        rad=E->trace.basicq[2][pp];
Full_tracer_advection.c:3056:        fprintf(E->trace.fpt,"(%d) time: %f theta: %f phi: %f rad: %f\n",
Full_tracer_advection.c:3057:            E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:3061:              E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:3073:    fflush(E->trace.fpt);
Full_tracer_advection.c:3076:    fprintf(E->trace.fpt,"\n\nComparison to Runge-Kutte\n");
Full_tracer_advection.c:3077:    if (E->parallel.me==0) fprintf(stderr,"Comparison to Runge-Kutte\n");
Full_tracer_advection.c:3079:    my_number=E->trace.ntracers[j];
Full_tracer_advection.c:3081:    MPI_Allreduce(&my_number,&number,1,MPI_INT,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3083:    fprintf(E->trace.fpt,"Number of tracers: %d\n", number);
Full_tracer_advection.c:3084:    if (E->parallel.me==0) fprintf(stderr,"Number of tracers: %d\n", number);
Full_tracer_advection.c:3090:            fprintf(E->trace.fpt,"(Note: RK comparison only appropriate for one tracing particle (%d here) \n",number);
Full_tracer_advection.c:3091:            if (E->parallel.me==0) fprintf(stderr,"(Note: RK comparison only appropriate for one tracing particle (%d here) \n",number);
Full_tracer_advection.c:3092:            fflush(E->trace.fpt);
Full_tracer_advection.c:3099:    MPI_Allreduce(&my_theta0,&theta0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3100:    MPI_Allreduce(&my_phi0,&phi0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3101:    MPI_Allreduce(&my_rad0,&rad0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3102:    MPI_Allreduce(&my_thetaf,&thetaf,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3103:    MPI_Allreduce(&my_phif,&phif,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3104:    MPI_Allreduce(&my_radf,&radf,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:3137:    fprintf(E->trace.fpt,"Citcom calculation: steps: %d  dt: %f\n",nsteps,dt);
Full_tracer_advection.c:3138:    fprintf(E->trace.fpt,"  (nodes per cap: %d x %d x %d)\n",E->lmesh.nox,E->lmesh.noy,(E->lmesh.noz-1)*E->parallel.nprocz+1);
Full_tracer_advection.c:3139:    fprintf(E->trace.fpt,"                    starting position: theta: %f phi: %f rad: %f\n", theta0,phi0,rad0);
Full_tracer_advection.c:3140:    fprintf(E->trace.fpt,"                    final position: theta: %f phi: %f rad: %f\n", thetaf,phif,radf);
Full_tracer_advection.c:3141:    fprintf(E->trace.fpt,"                    (final time: %f) \n",time );
Full_tracer_advection.c:3143:    fprintf(E->trace.fpt,"\n\nRunge-Kutte calculation: steps: %d  dt: %g\n",nrunge_steps,runge_dt);
Full_tracer_advection.c:3144:    fprintf(E->trace.fpt,"                    starting position: theta: %f phi: %f rad: %f\n", theta0,phi0,rad0);
Full_tracer_advection.c:3145:    fprintf(E->trace.fpt,"                    final position: theta: %f phi: %f rad: %f\n",xf_s[1],xf_s[2],xf_s[3]);
Full_tracer_advection.c:3146:    fprintf(E->trace.fpt,"                    path length: %f \n",runge_path_length );
Full_tracer_advection.c:3147:    fprintf(E->trace.fpt,"                    (final time: %f) \n",runge_time );
Full_tracer_advection.c:3149:    fprintf(E->trace.fpt,"\n\n Difference between Citcom and RK: %e  (diff per path length: %e)\n\n",difference,difperpath);
Full_tracer_advection.c:3151:    if (E->parallel.me==0)
Full_tracer_advection.c:3154:            fprintf(stderr,"  (nodes per cap: %d x %d x %d)\n",E->lmesh.nox,E->lmesh.noy,(E->lmesh.noz-1)*E->parallel.nprocz+1);
Full_tracer_advection.c:3169:    fflush(E->trace.fpt);
Full_tracer_advection.c:3340:    fprintf(E->trace.fpt,"HERE (Before Sync): %d\n",i);
Full_tracer_advection.c:3341:    fflush(E->trace.fpt);
Full_tracer_advection.c:3343:    fprintf(E->trace.fpt,"HERE (After Sync): %d\n",i);
Full_tracer_advection.c:3344:    fflush(E->trace.fpt);
Full_version_dependent.c:53:    for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Full_version_dependent.c:54:        for (i=1;i<=E->lmesh.NNO[lev];i++) {
Full_version_dependent.c:55:            t[0] = E->X[lev][1][i]*dircos[1][1]+
Full_version_dependent.c:56:                E->X[lev][2][i]*dircos[1][2]+
Full_version_dependent.c:57:                E->X[lev][3][i]*dircos[1][3];
Full_version_dependent.c:58:            t[1] = E->X[lev][1][i]*dircos[2][1]+
Full_version_dependent.c:59:                E->X[lev][2][i]*dircos[2][2]+
Full_version_dependent.c:60:                E->X[lev][3][i]*dircos[2][3];
Full_version_dependent.c:61:            t[2] = E->X[lev][1][i]*dircos[3][1]+
Full_version_dependent.c:62:                E->X[lev][2][i]*dircos[3][2]+
Full_version_dependent.c:63:                E->X[lev][3][i]*dircos[3][3];
Full_version_dependent.c:65:            E->X[lev][1][i] = t[0];
Full_version_dependent.c:66:            E->X[lev][2][i] = t[1];
Full_version_dependent.c:67:            E->X[lev][3][i] = t[2];
Full_version_dependent.c:68:            E->SX[lev][1][i] = acos(t[2]/E->SX[lev][3][i]);
Full_version_dependent.c:69:            E->SX[lev][2][i] = myatan(t[1],t[0]);
Full_version_dependent.c:90:  rr = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Full_version_dependent.c:91:  RR = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Full_version_dependent.c:94:  switch(E->control.coor){
Full_version_dependent.c:97:    dr = (E->sphere.ro-E->sphere.ri)/(E->mesh.noz-1);
Full_version_dependent.c:99:    for (k=1;k <= E->mesh.noz;k++)  {
Full_version_dependent.c:100:      rr[k] = E->sphere.ri + (k-1)*dr;
Full_version_dependent.c:104:    sprintf(output_file,"%s",E->control.coor_file);
Full_version_dependent.c:107:      fprintf(E->fp,"(Nodal_mesh.c #1) Cannot open %s\n",output_file);
Full_version_dependent.c:111:    for (k=1;k<=E->mesh.noz;k++)  {
Full_version_dependent.c:134:  for (i=1;i<=E->mesh.noz;i++)  {
Full_version_dependent.c:135:      E->sphere.gr[i] = rr[i];
Full_version_dependent.c:136:      /* if(E->parallel.me==0) fprintf(stderr, "%d %f\n", i, E->sphere.gr[i]); */
Full_version_dependent.c:139:  for (i=1;i<=E->lmesh.noz;i++)  {
Full_version_dependent.c:140:    k = E->lmesh.nzs+i-1;
Full_version_dependent.c:147:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Full_version_dependent.c:149:    if (E->control.NMULTIGRID)
Full_version_dependent.c:150:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Full_version_dependent.c:154:      for (i=1;i<=E->lmesh.NOZ[lev];i++)
Full_version_dependent.c:155:         E->sphere.R[lev][i] = RR[(i-1)*step+1];
Full_version_dependent.c:162:  ii = E->sphere.capid;
Full_version_dependent.c:165:  if (E->control.verbose) {
Full_version_dependent.c:166:      for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Full_version_dependent.c:167:          fprintf(E->fp_out,"output_coordinates before rotation %d \n",lev);
Full_version_dependent.c:168:          for (i=1;i<=E->lmesh.NNO[lev];i++)
Full_version_dependent.c:169:            if(i%E->lmesh.NOZ[lev]==1)
Full_version_dependent.c:170:              fprintf(E->fp_out,"%d %g %g %g\n",i,
Full_version_dependent.c:171:                  E->SX[lev][1][i],E->SX[lev][2][i],E->SX[lev][3][i]);
Full_version_dependent.c:173:      fflush(E->fp_out);
Full_version_dependent.c:178:  ro = -0.5*(M_PI/4.0)/E->mesh.elx;
Full_version_dependent.c:191:  ii = E->sphere.capid;
Full_version_dependent.c:194:  if (E->control.verbose) {
Full_version_dependent.c:195:      for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Full_version_dependent.c:196:          fprintf(E->fp_out,"output_coordinates after rotation %d \n",lev);
Full_version_dependent.c:197:          for (i=1;i<=E->lmesh.NNO[lev];i++)
Full_version_dependent.c:198:            if(i%E->lmesh.NOZ[lev]==1)
Full_version_dependent.c:199:              fprintf(E->fp_out,"%d %g %g %g\n",i,
Full_version_dependent.c:200:                  E->SX[lev][1][i],E->SX[lev][2][i],E->SX[lev][3][i]);
Full_version_dependent.c:202:      fflush(E->fp_out);
Full_version_dependent.c:209:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Full_version_dependent.c:210:    for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Full_version_dependent.c:211:      tg = theta_g(E->SX[lev][1][i],E);
Full_version_dependent.c:212:      E->SinCos[lev][0][i] = sin(tg); /*  */
Full_version_dependent.c:213:      E->SinCos[lev][1][i] = sin(E->SX[lev][2][i]);
Full_version_dependent.c:214:      E->SinCos[lev][2][i] = cos(tg);
Full_version_dependent.c:215:      E->SinCos[lev][3][i] = cos(E->SX[lev][2][i]);
Full_version_dependent.c:219:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Full_version_dependent.c:220:    for (i=1;i<=E->lmesh.NNO[lev];i++){
Full_version_dependent.c:221:      E->SinCos[lev][0][i] = sin(E->SX[lev][1][i]); /* sin(theta) */
Full_version_dependent.c:222:      E->SinCos[lev][1][i] = sin(E->SX[lev][2][i]); /* sin(phi) */
Full_version_dependent.c:223:      E->SinCos[lev][2][i] = cos(E->SX[lev][1][i]); /* cos(theta) */
Full_version_dependent.c:224:      E->SinCos[lev][3][i] = cos(E->SX[lev][2][i]); /* cos(phi) */
Full_version_dependent.c:234:  const int dims=E->mesh.nsd;
Full_version_dependent.c:238:  int max_size = 2*E->lmesh.elx*E->lmesh.ely + 1;
Full_version_dependent.c:239:  E->boundary.element = (int *)malloc(max_size*sizeof(int));
Full_version_dependent.c:242:    E->boundary.normal[d] = (int *)malloc(max_size*sizeof(int));
Full_version_dependent.c:245:  for(k=1; k<=E->lmesh.ely; k++)
Full_version_dependent.c:246:    for(j=1; j<=E->lmesh.elx; j++) {
Full_version_dependent.c:247:      if(E->parallel.me_loc[3] == 0) {
Full_version_dependent.c:249:        el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_version_dependent.c:250:        E->boundary.element[count] = el;
Full_version_dependent.c:251:        E->boundary.normal[dims][count] = -1;
Full_version_dependent.c:253:          E->boundary.normal[d][count] = 0;
Full_version_dependent.c:257:      if(E->parallel.me_loc[3] == E->parallel.nprocz - 1) {
Full_version_dependent.c:258:        i = E->lmesh.elz;
Full_version_dependent.c:259:        el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_version_dependent.c:260:        E->boundary.element[count] = el;
Full_version_dependent.c:261:        E->boundary.normal[dims][count] = 1;
Full_version_dependent.c:263:          E->boundary.normal[d][count] = 0;
Full_version_dependent.c:267:  E->boundary.nel = count - 1;
General_matrix_functions.c:71:  neq  = E->lmesh.NEQ[high_lev];
General_matrix_functions.c:82:  if (!E->control.NMULTIGRID) {
General_matrix_functions.c:85:    cycles = E->control.v_steps_low;
General_matrix_functions.c:93:    if(E->parallel.me==0){	/* output */
General_matrix_functions.c:103:      if(E->parallel.me==0){	/* output  */
General_matrix_functions.c:108:    }  while (!valid && counts < E->control.max_mg_cycles);
General_matrix_functions.c:126:  if(E->control.print_convergence&&E->parallel.me==0)   {
General_matrix_functions.c:127:    fprintf(E->fp,"%s residual (%03d) = %.3e from %.3e to %.3e in %5.2f secs \n",
General_matrix_functions.c:129:    fflush(E->fp);
General_matrix_functions.c:134:  E->monitor.momentum_residual = residual;
General_matrix_functions.c:135:  E->control.total_iteration_cycles += count;
General_matrix_functions.c:136:  E->control.total_v_solver_calls += 1;
General_matrix_functions.c:164:    const int levmin = E->mesh.levmin;
General_matrix_functions.c:165:    const int levmax = E->mesh.levmax;
General_matrix_functions.c:173:    for(i=E->mesh.levmin;i<=E->mesh.levmax;i++){
General_matrix_functions.c:174:      del_vel[i]=(double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:175:      AU[i] = (double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:176:      vel[i]=(double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:177:      res[i]=(double *)malloc((E->lmesh.NEQ[i])*sizeof(double));
General_matrix_functions.c:178:      if (i<E->mesh.levmax)
General_matrix_functions.c:179:        fl[i]=(double *)malloc((E->lmesh.NEQ[i])*sizeof(double));
General_matrix_functions.c:182:    Vnmax = E->control.mg_cycle;
General_matrix_functions.c:196:    cycles = E->control.v_steps_low;
General_matrix_functions.c:208:        for(j=0;j<E->lmesh.NEQ[lev];j++)
General_matrix_functions.c:211:        for(j=0;j<E->lmesh.NEQ[lev];j++)
General_matrix_functions.c:220:                E->control.v_steps_high:E->control.down_heavy);
General_matrix_functions.c:224:            for(i=0;i<E->lmesh.NEQ[dlev];i++)
General_matrix_functions.c:232:           cycles = E->control.v_steps_low;
General_matrix_functions.c:238:                  E->control.v_steps_high:E->control.up_heavy);
General_matrix_functions.c:248:              for(i=0;i<E->lmesh.NEQ[ulev];i++)   {
General_matrix_functions.c:253:                for(i=0;i<E->lmesh.NEQ[ulev];i++) {
General_matrix_functions.c:261:    for(j=0;j<E->lmesh.NEQ[levmax];j++)   {
General_matrix_functions.c:268:    for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) {
General_matrix_functions.c:273:      if (i<E->mesh.levmax)
General_matrix_functions.c:306:    const int mem_lev=E->mesh.levmax;
General_matrix_functions.c:307:    const int high_neq = E->lmesh.NEQ[level];
General_matrix_functions.c:311:    r0 = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:312:    r1 = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:313:    r2 = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:314:    z0 = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:315:    z1 = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:316:    p1 = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:317:    p2 = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:318:    Ap = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:333:        z1[i] = E->BI[level][i] * r1[i];
General_matrix_functions.c:417:    const int dims=E->mesh.nsd;
General_matrix_functions.c:419:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:420:    const int neq=E->lmesh.NEQ[level];
General_matrix_functions.c:421:    const int nel=E->lmesh.NEL[level];
General_matrix_functions.c:422:    const int nno=E->lmesh.NNO[level];
General_matrix_functions.c:445:      elt_k = E->elt_k[level][e].k;
General_matrix_functions.c:448:        node=E->IEN[level][e].node[i];
General_matrix_functions.c:451:        if(E->NODE[level][node] & VBX)
General_matrix_functions.c:453:        if(E->NODE[level][node] & VBY)
General_matrix_functions.c:455:        if(E->NODE[level][node] & VBZ)
General_matrix_functions.c:460:        node=E->IEN[level][e].node[i];
General_matrix_functions.c:464:        eqn1=E->ID[level][node].doff[1];
General_matrix_functions.c:465:        eqn2=E->ID[level][node].doff[2];
General_matrix_functions.c:466:        eqn3=E->ID[level][node].doff[3];
General_matrix_functions.c:473:          node1=E->IEN[level][e].node[j];
General_matrix_functions.c:475:          eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:476:          eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:477:          eqn13=E->ID[level][node1].doff[3];
General_matrix_functions.c:491:        node=E->IEN[level][e].node[i];
General_matrix_functions.c:495:        eqn1=E->ID[level][node].doff[1];
General_matrix_functions.c:496:        eqn2=E->ID[level][node].doff[2];
General_matrix_functions.c:497:        eqn3=E->ID[level][node].doff[3];
General_matrix_functions.c:504:            w[(i-1)*dims+0]*(F[eqn1]-Ad[eqn1])*E->BI[level][eqn1]);
General_matrix_functions.c:506:            w[(i-1)*dims+1]*(F[eqn2]-Ad[eqn2])*E->BI[level][eqn2]);
General_matrix_functions.c:508:            w[(i-1)*dims+2]*(F[eqn3]-Ad[eqn3])*E->BI[level][eqn3]);
General_matrix_functions.c:514:          node1=E->IEN[level][e].node[j];
General_matrix_functions.c:516:        eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:517:        eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:518:        eqn13=E->ID[level][node1].doff[3];
General_matrix_functions.c:534:        (E->solver.exchange_id_d)(E, Ad, level);
General_matrix_functions.c:535:        (E->solver.exchange_id_d)(E, d0, level);
General_matrix_functions.c:574:    const int dims=E->mesh.nsd;
General_matrix_functions.c:576:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:577:    const int neq=E->lmesh.NEQ[level];
General_matrix_functions.c:578:    const int num_nodes=E->lmesh.NNO[level];
General_matrix_functions.c:579:    const int nox=E->lmesh.NOX[level];
General_matrix_functions.c:580:    const int noz=E->lmesh.NOY[level];
General_matrix_functions.c:581:    const int noy=E->lmesh.NOZ[level];
General_matrix_functions.c:599:      for(j=0;j<=E->lmesh.NEQ[level];j++)
General_matrix_functions.c:600:        E->temp[j] = zeroo;
General_matrix_functions.c:604:      for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:605:        if(E->NODE[level][i] & OFFSIDE)   {
General_matrix_functions.c:606:          eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:607:          eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:608:          eqn3=E->ID[level][i].doff[3];
General_matrix_functions.c:609:          E->temp[eqn1] = (F[eqn1] - Ad[eqn1])*E->BI[level][eqn1];
General_matrix_functions.c:610:          E->temp[eqn2] = (F[eqn2] - Ad[eqn2])*E->BI[level][eqn2];
General_matrix_functions.c:611:          E->temp[eqn3] = (F[eqn3] - Ad[eqn3])*E->BI[level][eqn3];
General_matrix_functions.c:612:          E->temp1[eqn1] = Ad[eqn1];
General_matrix_functions.c:613:          E->temp1[eqn2] = Ad[eqn2];
General_matrix_functions.c:614:          E->temp1[eqn3] = Ad[eqn3];
General_matrix_functions.c:617:      for(i=1;i<=E->lmesh.NNO[level];i++) {
General_matrix_functions.c:618:        eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:619:        eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:620:        eqn3=E->ID[level][i].doff[3];
General_matrix_functions.c:621:        C=E->Node_map[level]+(i-1)*max_eqn;
General_matrix_functions.c:622:        B1=E->Eqn_k1[level]+(i-1)*max_eqn;
General_matrix_functions.c:623:        B2=E->Eqn_k2[level]+(i-1)*max_eqn;
General_matrix_functions.c:624:        B3=E->Eqn_k3[level]+(i-1)*max_eqn;
General_matrix_functions.c:631:           UU = E->temp[C[j]];
General_matrix_functions.c:637:        if(!(E->NODE[level][i]&OFFSIDE)) {
General_matrix_functions.c:638:           E->temp[eqn1] = (F[eqn1] - Ad[eqn1])*E->BI[level][eqn1];
General_matrix_functions.c:639:           E->temp[eqn2] = (F[eqn2] - Ad[eqn2])*E->BI[level][eqn2];
General_matrix_functions.c:640:           E->temp[eqn3] = (F[eqn3] - Ad[eqn3])*E->BI[level][eqn3];
General_matrix_functions.c:645:		      Ad[C[j]] += B1[j]*E->temp[eqn1]
General_matrix_functions.c:646:                   +  B2[j]*E->temp[eqn2]
General_matrix_functions.c:647:                   +  B3[j]*E->temp[eqn3];
General_matrix_functions.c:649:        d0[eqn1] += E->temp[eqn1];
General_matrix_functions.c:650:        d0[eqn2] += E->temp[eqn2];
General_matrix_functions.c:651:        d0[eqn3] += E->temp[eqn3];
General_matrix_functions.c:654:      for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:655:        if(E->NODE[level][i] & OFFSIDE)   {
General_matrix_functions.c:656:          eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:657:          eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:658:          eqn3=E->ID[level][i].doff[3];
General_matrix_functions.c:659:          Ad[eqn1] -= E->temp1[eqn1];
General_matrix_functions.c:660:          Ad[eqn2] -= E->temp1[eqn2];
General_matrix_functions.c:661:          Ad[eqn3] -= E->temp1[eqn3];
General_matrix_functions.c:664:      (E->solver.exchange_id_d)(E, Ad, level);
General_matrix_functions.c:666:      for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:667:        if(E->NODE[level][i] & OFFSIDE)   {
General_matrix_functions.c:668:          eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:669:          eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:670:          eqn3=E->ID[level][i].doff[3];
General_matrix_functions.c:671:          Ad[eqn1] += E->temp1[eqn1];
General_matrix_functions.c:672:          Ad[eqn2] += E->temp1[eqn2];
General_matrix_functions.c:673:          Ad[eqn3] += E->temp1[eqn3];
Ggrd_handling.c:104:  if (E->parallel.nprocxy == 12){
Ggrd_handling.c:110:  only_one_layer = ((E->trace.ggrd_layers > 0)?(0):(1));
Ggrd_handling.c:120:  if(E->parallel.me > 0){	
Ggrd_handling.c:122:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 
Ggrd_handling.c:123:		      0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:125:  if(ggrd_grdtrack_init_general(FALSE,E->trace.ggrd_file,
Ggrd_handling.c:127:				ggrd_ict,(E->parallel.me==0)?TRUE:FALSE,FALSE,
Ggrd_handling.c:132:  if(E->parallel.me <  E->parallel.nproc-1){
Ggrd_handling.c:135:		      MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:142:    number_of_tracers = E->trace.ntracers;
Ggrd_handling.c:144:      rad = E->trace.basicq[2][kk]; /* tracer radius */
Ggrd_handling.c:147:      if((only_one_layer && (this_layer == -E->trace.ggrd_layers)) ||
Ggrd_handling.c:148:	 ((!only_one_layer)&&(this_layer <= E->trace.ggrd_layers))){
Ggrd_handling.c:152:	phi =   E->trace.basicq[1][kk];
Ggrd_handling.c:153:	theta = E->trace.basicq[0][kk];
Ggrd_handling.c:161:	if(!E->control.ggrd_comp_smooth){
Ggrd_handling.c:168:	E->trace.extraq[0][kk]= indbl;
Ggrd_handling.c:171:	E->trace.extraq[0][kk] = 0.0;
Ggrd_handling.c:178:  if(E->parallel.me == 0)
Ggrd_handling.c:180:      fprintf(stderr,"ggrd tracer init OK for layer %i\n",-E->trace.ggrd_layers);
Ggrd_handling.c:182:      fprintf(stderr,"ggrd tracer init OK for all layers <= %i\n",E->trace.ggrd_layers);
Ggrd_handling.c:210:  noy=E->lmesh.noy;
Ggrd_handling.c:211:  nox=E->lmesh.nox;
Ggrd_handling.c:212:  noz=E->lmesh.noz;
Ggrd_handling.c:215:  if(E->parallel.me == 0)
Ggrd_handling.c:230:  if(E->parallel.me > 0){
Ggrd_handling.c:234:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:235:		      0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:238:  if(E->control.ggrd.temp.scale_with_prem){/* initialize PREM */
Ggrd_handling.c:239:    if(prem_read_model(E->control.ggrd.temp.prem.model_filename,
Ggrd_handling.c:240:		       &E->control.ggrd.temp.prem, (E->parallel.me == 0)))
Ggrd_handling.c:246:  E->control.ggrd.temp.d[0].init = FALSE;
Ggrd_handling.c:247:  if(ggrd_grdtrack_init_general(TRUE,E->control.ggrd.temp.gfile,
Ggrd_handling.c:248:				E->control.ggrd.temp.dfile,gmt_string,
Ggrd_handling.c:249:				E->control.ggrd.temp.d,(E->parallel.me == 0),
Ggrd_handling.c:253:  if(E->parallel.me <  E->parallel.nproc-1){
Ggrd_handling.c:255:    mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:258:	    E->parallel.me);
Ggrd_handling.c:265:  if(E->mesh.bottbc == 1){
Ggrd_handling.c:267:    tbot =  E->control.TBCbotval;
Ggrd_handling.c:285:          depth = (1-E->sx[3][node])*6371;
Ggrd_handling.c:287:             (double)E->sx[3][node],
Ggrd_handling.c:288:             (double)E->sx[1][node],
Ggrd_handling.c:289:             (double)E->sx[2][node],
Ggrd_handling.c:290:             E->control.ggrd.temp.d,&tadd,
Ggrd_handling.c:293:              E->sx[2][node]*57.29577951308232087,
Ggrd_handling.c:294:              90-E->sx[1][node]*57.29577951308232087,depth);
Ggrd_handling.c:298:	  if(E->control.ggrd_tinit_nl_scale){ /* nonlinear scaling,
Ggrd_handling.c:309:	  if(depth < E->control.ggrd_lower_depth_km){
Ggrd_handling.c:313:	    tmean = (tbot + E->control.TBCtopval)/2.0 +  E->control.ggrd.temp.offset;
Ggrd_handling.c:314:	    loc_scale =  E->control.ggrd.temp.scale;
Ggrd_handling.c:316:	    tmean = (tbot + E->control.TBCtopval)/2.0 +  E->control.ggrd_lower_offset;
Ggrd_handling.c:317:	    loc_scale = E->control.ggrd_lower_scale;
Ggrd_handling.c:319:	  if(E->control.ggrd.temp.scale_with_prem){
Ggrd_handling.c:323:	    prem_get_rho(&rho_prem,(double)E->sx[3][node],&E->control.ggrd.temp.prem);
Ggrd_handling.c:332:	    E->T[node] = tmean + tadd * loc_scale * rho_prem / E->data.density;
Ggrd_handling.c:335:	    E->T[node] = tmean + tadd * loc_scale;
Ggrd_handling.c:338:	  if(E->control.ggrd.temp.limit_trange){
Ggrd_handling.c:340:	    E->T[node] = min(max(E->T[node], 0.0),1.0);
Ggrd_handling.c:342:	  //fprintf(stderr,"z: %11g T: %11g\n",E->sx[3][node],E->T[node]);
Ggrd_handling.c:343:	  if(E->control.ggrd.temp.override_tbc){
Ggrd_handling.c:344:	    if((k == 1) && (E->mesh.bottbc == 1)){ /* bottom TBC */
Ggrd_handling.c:345:	      E->sphere.cap.TB[1][node] =  E->T[node];
Ggrd_handling.c:346:	      E->sphere.cap.TB[2][node] =  E->T[node];
Ggrd_handling.c:347:	      E->sphere.cap.TB[3][node] =  E->T[node];
Ggrd_handling.c:348:	      //fprintf(stderr,"z: %11g TBB: %11g\n",E->sx[3][node],E->T[node]);
Ggrd_handling.c:350:	    if((k == noz) && (E->mesh.toptbc == 1)){ /* top TBC */
Ggrd_handling.c:351:	      E->sphere.cap.TB[1][node] =  E->T[node];
Ggrd_handling.c:352:	      E->sphere.cap.TB[2][node] =  E->T[node];
Ggrd_handling.c:353:	      E->sphere.cap.TB[3][node] =  E->T[node];
Ggrd_handling.c:354:	      //fprintf(stderr,"z: %11g TBT: %11g\n",E->sx[3][node],E->T[node]);
Ggrd_handling.c:365:  ggrd_grdtrack_free_gstruc(E->control.ggrd.temp.d);
Ggrd_handling.c:378:layer <=  E->control.ggrd.mat_control for  E->control.ggrd.mat_control > 0
Ggrd_handling.c:382:layer ==  -E->control.ggrd.mat_control for  E->control.ggrd.mat_control < 0
Ggrd_handling.c:400:  const int dims=E->mesh.nsd;
Ggrd_handling.c:405:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Ggrd_handling.c:406:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Ggrd_handling.c:415:  if(E->control.ggrd_mat_is_code)
Ggrd_handling.c:421:  if(!E->control.ggrd.time_hist.init){
Ggrd_handling.c:425:    ggrd_init_thist_from_file(&E->control.ggrd.time_hist,
Ggrd_handling.c:426:			      E->control.ggrd.time_hist.file,TRUE,(E->parallel.me == 0));
Ggrd_handling.c:427:    E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:430:  timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:431:  if(!E->control.ggrd.mat_control_init){
Ggrd_handling.c:444:    if(E->parallel.me > 0)	/* wait for previous processor */
Ggrd_handling.c:445:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:446:			0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:450:    E->control.ggrd.mat = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:454:    if((in = fopen(E->control.ggrd_mat_depth_file,"r"))!=NULL) /* expect 3D setup */
Ggrd_handling.c:455:      E->control.ggrd_mat_is_3d = TRUE;
Ggrd_handling.c:457:      E->control.ggrd_mat_is_3d = FALSE;
Ggrd_handling.c:459:    if(E->parallel.me==0){
Ggrd_handling.c:460:      if(E->control.ggrd.mat_control > 0){
Ggrd_handling.c:462:		E->data.radius_km*E->viscosity.zbase_layer[E->control.ggrd.mat_control-1],
Ggrd_handling.c:463:		(is_geographic)?("geographic"):("Cartesian"),(E->control.ggrd_mat_is_3d)?("3D"):("single layer"));
Ggrd_handling.c:466:		E->data.radius_km*E->viscosity.zbase_layer[-E->control.ggrd.mat_control-1],
Ggrd_handling.c:467:		(is_geographic)?("geographic"):("Cartesian"),(E->control.ggrd_mat_is_3d)?("3D"):("single layer"));
Ggrd_handling.c:470:    for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:472:	sprintf(tfilename,"%s",E->control.ggrd.mat_file);
Ggrd_handling.c:474:	if(E->control.ggrd_mat_is_3d)
Ggrd_handling.c:475:	  sprintf(tfilename,"%s/%i/weak",E->control.ggrd.mat_file,i+1);
Ggrd_handling.c:477:	  sprintf(tfilename,"%s/%i/weak.grd",E->control.ggrd.mat_file,i+1);
Ggrd_handling.c:479:      if(ggrd_grdtrack_init_general(E->control.ggrd_mat_is_3d,tfilename,E->control.ggrd_mat_depth_file,
Ggrd_handling.c:480:				    gmt_string,(E->control.ggrd.mat+i),
Ggrd_handling.c:481:				    (E->parallel.me == 0),FALSE,
Ggrd_handling.c:485:    if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Ggrd_handling.c:487:			MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:495:  if(timedep || (!E->control.ggrd.mat_control_init)){
Ggrd_handling.c:497:    if(E->parallel.me == 0)
Ggrd_handling.c:500:      ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:501:			 E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:513:	if(((E->control.ggrd.mat_control > 0) && (E->mat[j] <=  E->control.ggrd.mat_control )) || 
Ggrd_handling.c:514:	   ((E->control.ggrd.mat_control < 0) && (E->mat[j] == -E->control.ggrd.mat_control ))){
Ggrd_handling.c:530:          ind = E->ien[el].node[inode];
Ggrd_handling.c:531:          xloc[1] += E->x[1][ind];
Ggrd_handling.c:532:          xloc[2] += E->x[2][ind];
Ggrd_handling.c:533:          xloc[3] += E->x[3][ind];
Ggrd_handling.c:540:	      if(E->control.ggrd_mat_is_3d){
Ggrd_handling.c:541:		if(!ggrd_grdtrack_interpolate_rtp((double)rout[0],(double)rout[1],(double)rout[2],(E->control.ggrd.mat+i1),&indbl,
Ggrd_handling.c:549:		if(!ggrd_grdtrack_interpolate_tp((double)rout[1],(double)rout[2],(E->control.ggrd.mat+i1),&indbl,
Ggrd_handling.c:558:		if(E->control.ggrd_mat_is_3d){
Ggrd_handling.c:560:						   (E->control.ggrd.mat+i2),&indbl2,
Ggrd_handling.c:568:						   (E->control.ggrd.mat+i2),&indbl2,
Ggrd_handling.c:580:	      if(E->control.ggrd_mat_limit_prefactor){
Ggrd_handling.c:588:	      E->VIP[el] = vip;
Ggrd_handling.c:593:	  if(E->control.ggrd_mat_is_code){
Ggrd_handling.c:597:		E->VIP[el] = 0; /* zero code --> unity scale */
Ggrd_handling.c:604:		E->VIP[el] = 1.0;
Ggrd_handling.c:610:    if(E->control.ggrd_mat_is_code){
Ggrd_handling.c:615:      if(E->parallel.me==0){
Ggrd_handling.c:616:	for(i=0;i < E->control.ggrd_mat_is_code;i++)
Ggrd_handling.c:618:		  i+1,E->control.ggrd_mat_code_viscosities[i]);
Ggrd_handling.c:626:	      if((int)E->VIP[el] < 1){ /* background */
Ggrd_handling.c:627:          E->VIP[el] = 1.0;
Ggrd_handling.c:629:          if((((int)E->VIP[el]) > E->control.ggrd_mat_is_code)||
Ggrd_handling.c:630:              (((int)E->VIP[el]) < 1)){
Ggrd_handling.c:631:            fprintf(stderr,"%i\n",(int)E->VIP[el]);
Ggrd_handling.c:634:          E->VIP[el] = 
Ggrd_handling.c:635:            E->control.ggrd_mat_code_viscosities[(int)(E->VIP[el]-1)];
Ggrd_handling.c:642:  if((!timedep) && (!E->control.ggrd.mat_control_init)){
Ggrd_handling.c:644:    ggrd_grdtrack_free_gstruc(E->control.ggrd.mat);
Ggrd_handling.c:646:  E->control.ggrd.mat_control_init = 1;
Ggrd_handling.c:655:layer <= E->control.ggrd.ray_control
Ggrd_handling.c:676:  const int dims=E->mesh.nsd;
Ggrd_handling.c:679:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Ggrd_handling.c:680:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Ggrd_handling.c:683:  lev=E->mesh.levmax;
Ggrd_handling.c:691:  if(!E->control.ggrd.time_hist.init){
Ggrd_handling.c:692:    ggrd_init_thist_from_file(&E->control.ggrd.time_hist,
Ggrd_handling.c:693:			      E->control.ggrd.time_hist.file,TRUE,(E->parallel.me == 0));
Ggrd_handling.c:694:    E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:696:  timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:697:  if(!E->control.ggrd.ray_control_init){
Ggrd_handling.c:699:    if(E->parallel.me==0)
Ggrd_handling.c:700:      fprintf(stderr,"ggrd_read_ray_from_file: initializing from %s\n",E->control.ggrd.ray_file);
Ggrd_handling.c:705:    if(E->parallel.me > 0)	/* wait for previous processor */
Ggrd_handling.c:706:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:707:			0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:708:    E->control.ggrd.ray = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:709:    for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:711:	sprintf(tfilename,"%s",E->control.ggrd.ray_file);
Ggrd_handling.c:713:	sprintf(tfilename,"%s/%i/rayleigh.grd",E->control.ggrd.ray_file,i+1);
Ggrd_handling.c:715:				    gmt_string,(E->control.ggrd.ray+i),
Ggrd_handling.c:716:				    (E->parallel.me == 0),FALSE,
Ggrd_handling.c:720:    if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Ggrd_handling.c:722:			MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:726:    E->control.surface_rayleigh = (float *)malloc(sizeof(float)*(E->lmesh.nsf+2));
Ggrd_handling.c:727:    if(!E->control.surface_rayleigh)
Ggrd_handling.c:730:  if(timedep || (!E->control.ggrd.ray_control_init)){
Ggrd_handling.c:733:      ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:734:			 E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:740:    if(E->parallel.me == 0)
Ggrd_handling.c:743:      for (j=1;j <= E->lmesh.nsf;j++)  {
Ggrd_handling.c:744:	node = j * E->lmesh.noz ;
Ggrd_handling.c:745:	rout[1] = (double)E->sx[1][node];
Ggrd_handling.c:746:	rout[2] = (double)E->sx[2][node];
Ggrd_handling.c:747:	if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.ray+i1),&indbl,
Ggrd_handling.c:753:	//fprintf(stderr,"%i %i %g %g %g\n",j,E->lmesh.nsf,rout[1],rout[2],indbl);
Ggrd_handling.c:756:					   (E->control.ggrd.ray+i2),&indbl2,
Ggrd_handling.c:767:	E->control.surface_rayleigh[j] = vip;
Ggrd_handling.c:770:  if((!timedep) && (!E->control.ggrd.ray_control_init)){			/* forget the grid */
Ggrd_handling.c:771:    ggrd_grdtrack_free_gstruc(E->control.ggrd.ray);
Ggrd_handling.c:773:  E->control.ggrd.ray_control_init = 1;
Ggrd_handling.c:809:  const int dims=E->mesh.nsd;
Ggrd_handling.c:822:  nox = E->lmesh.nox;
Ggrd_handling.c:823:  noz = E->lmesh.noz;
Ggrd_handling.c:824:  noy = E->lmesh.noy;
Ggrd_handling.c:830:  if(E->control.ggrd_allow_mixed_vbcs)
Ggrd_handling.c:835:  if(E->mesh.toplayerbc != 0)
Ggrd_handling.c:841:  top_proc = E->parallel.nprocz-1;
Ggrd_handling.c:845:  if((allow_internal && (E->parallel.me == 0)) || (E->parallel.me == top_proc))
Ggrd_handling.c:850:  switch(E->mesh.topvbc){
Ggrd_handling.c:869:  if(E->control.ggrd_vtop_euler && (!use_vel)){
Ggrd_handling.c:875:	    ((E->mesh.topvbc)?("velocities"):("tractions")),E->control.ggrd_allow_mixed_vbcs);
Ggrd_handling.c:882:    vscale = E->data.scalev * E->data.timedir;
Ggrd_handling.c:883:    if(E->control.ggrd_vtop_euler)
Ggrd_handling.c:884:      vscale *=  E->data.radius_km*1e3/1e6*1e2*M_PI/180.;		/* for deg/Myr -> cm/yr conversion */
Ggrd_handling.c:885:    if(E->parallel.me == 0)
Ggrd_handling.c:891:    vscale =  1e6/(E->data.ref_viscosity*E->data.therm_diff/(E->data.radius_km*E->data.radius_km*1e6));
Ggrd_handling.c:898:  if (allow_internal || (E->parallel.me_loc[3] == top_proc)) { 
Ggrd_handling.c:910:    if(!E->control.ggrd.time_hist.init){/* init times, if available*/
Ggrd_handling.c:911:      ggrd_init_thist_from_file(&E->control.ggrd.time_hist,E->control.ggrd.time_hist.file,
Ggrd_handling.c:912:				TRUE,(E->parallel.me == 0));
Ggrd_handling.c:913:      E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:915:    timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:917:    if(!E->control.ggrd.vtop_control_init){
Ggrd_handling.c:939:      E->control.ggrd.svt = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:940:      E->control.ggrd.svp = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:941:      if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:943:	euler = (struct elvc **)malloc(E->control.ggrd.time_hist.nvtimes * sizeof(struct elvc *));
Ggrd_handling.c:944:	max_code = (int *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(int));
Ggrd_handling.c:948:      E->control.ggrd.svt->bandlim = E->control.ggrd.svp->bandlim = 1e6;
Ggrd_handling.c:949:      for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:957:	  if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:958:	    sprintf(tfilename1,"%s/code.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:959:	    sprintf(tfilename2,"%s/rotvec.dat",E->control.ggrd.vtop_dir);
Ggrd_handling.c:961:	    sprintf(tfilename1,"%s/vt.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:962:	    sprintf(tfilename2,"%s/vp.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:965:	  if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:966:	    sprintf(tfilename1,"%s/%i/code.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:967:	    sprintf(tfilename2,"%s/%i/rotvec.dat",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:969:	    sprintf(tfilename1,"%s/%i/vt.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:970:	    sprintf(tfilename2,"%s/%i/vp.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:973:	if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:979:					gmt_string,(E->control.ggrd.svt+i),
Ggrd_handling.c:1010:					gmt_string,(E->control.ggrd.svt+i),verbose,FALSE,
Ggrd_handling.c:1014:					gmt_string,(E->control.ggrd.svp+i),verbose,FALSE,
Ggrd_handling.c:1021:      if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:1022:	if(E->control.ggrd.time_hist.nvtimes == 1){
Ggrd_handling.c:1025:		   E->control.data_dir,E->parallel.me);
Ggrd_handling.c:1032:		E->control.ggrd.time_hist.nvtimes,E->control.ggrd.svt->fmaxlim[0]);
Ggrd_handling.c:1040:    theta_max = (90.-E->control.ggrd.svt[0].south)*M_PI/180-1e-5;
Ggrd_handling.c:1041:    theta_min = (90.-E->control.ggrd.svt[0].north)*M_PI/180+1e-5;
Ggrd_handling.c:1044:	      E->control.ggrd.svt[0].south,E->control.ggrd.svt[0].north);
Ggrd_handling.c:1046:    if((E->control.ggrd.time_hist.nvtimes > 1)|| (!E->control.ggrd.vtop_control_init)){
Ggrd_handling.c:1060:	  i1 = E->control.ggrd.time_hist.nvtimes - 1;
Ggrd_handling.c:1065:	  ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:1066:			     E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:1085:      if(E->control.ggrd_allow_mixed_vbcs){
Ggrd_handling.c:1092:	if(E->control.ggrd_vtop_euler)
Ggrd_handling.c:1098:	cutoff = E->control.ggrd.svt->fmaxlim[0] + 1e-5;	  
Ggrd_handling.c:1099:	for(level=E->mesh.gridmax;level >= E->mesh.gridmin;level--){/* multigrid levels */
Ggrd_handling.c:1101:	  noxl = E->lmesh.NOX[level];
Ggrd_handling.c:1102:	  noyl = E->lmesh.NOY[level];
Ggrd_handling.c:1103:	  nozl = E->lmesh.NOZ[level];
Ggrd_handling.c:1121:		  rout[1] = E->SX[level][1][nodel]; /* theta,phi */
Ggrd_handling.c:1122:		  rout[2] = E->SX[level][2][nodel];
Ggrd_handling.c:1146:            (E->control.ggrd.svp+i1),vin1,FALSE,shift_to_pos_lon)){
Ggrd_handling.c:1154:              (E->control.ggrd.svp+i2),vin2,FALSE,shift_to_pos_lon)){
Ggrd_handling.c:1171:		    ontop = ((k==nozl) && (E->parallel.me_loc[3]==E->parallel.nprocz-1))?(TRUE):(FALSE);
Ggrd_handling.c:1177:		      E->NODE[level][nodel] = E->NODE[level][nodel] & (~VBX);
Ggrd_handling.c:1178:		      E->NODE[level][nodel] = E->NODE[level][nodel] | SBX;
Ggrd_handling.c:1179:		      E->NODE[level][nodel] = E->NODE[level][nodel] & (~VBY);
Ggrd_handling.c:1180:		      E->NODE[level][nodel] = E->NODE[level][nodel] | SBY;
Ggrd_handling.c:1185:			E->NODE[level][nodel] = E->NODE[level][nodel] | VBX;
Ggrd_handling.c:1186:			E->NODE[level][nodel] = E->NODE[level][nodel] & (~SBX);
Ggrd_handling.c:1187:			E->NODE[level][nodel] = E->NODE[level][nodel] | VBY;
Ggrd_handling.c:1188:			E->NODE[level][nodel] = E->NODE[level][nodel] & (~SBY);
Ggrd_handling.c:1192:			E->NODE[level][nodel] = E->NODE[level][nodel] & (~VBX);
Ggrd_handling.c:1193:			E->NODE[level][nodel] = E->NODE[level][nodel] | SBX;
Ggrd_handling.c:1194:			E->NODE[level][nodel] = E->NODE[level][nodel] & (~VBY);
Ggrd_handling.c:1195:			E->NODE[level][nodel] = E->NODE[level][nodel] | SBY;
Ggrd_handling.c:1203:	fprintf(stderr,"ggrd_read_vtop_from_file: mixed_bc: %i free %i fixed for CPU %i\n",nfree,nfixed,E->parallel.me);
Ggrd_handling.c:1218:      if(!E->control.ggrd_vtop_euler)		/* else, is not defined */
Ggrd_handling.c:1219:	cutoff = E->control.ggrd.svp->fmaxlim[0] * vscale + 1e-5;
Ggrd_handling.c:1226:      E->lmesh.NOZ[E->mesh.gridmax],E->mesh.gridmax,
Ggrd_handling.c:1234:	      rout[1] = E->sx[1][nodel]; /* theta,phi coordinates */
Ggrd_handling.c:1235:	      rout[2] = E->sx[2][nodel];
Ggrd_handling.c:1258:	      if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svt+i1),
Ggrd_handling.c:1264:	      if(!E->control.ggrd_vtop_euler){
Ggrd_handling.c:1266:		if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i1),
Ggrd_handling.c:1275:		if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svt+i2),vin2,
Ggrd_handling.c:1281:		if(!E->control.ggrd_vtop_euler){
Ggrd_handling.c:1283:		  if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i2),(vin2+1),
Ggrd_handling.c:1303:		if(!E->control.ggrd_vtop_euler){
Ggrd_handling.c:1320:		ontop = ((k==noz) && (E->parallel.me_loc[3]==E->parallel.nprocz-1))?(TRUE):(FALSE);
Ggrd_handling.c:1322:		if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:1345:		  vx[1]=euler[euler_i][code].w[1] * E->x[m][3][nodel] - euler[euler_i][code].w[2] * E->x[m][2][nodel]; /* vx =  */
Ggrd_handling.c:1346:		  vx[2]=euler[euler_i][code].w[2] * E->x[m][1][nodel] - euler[euler_i][code].w[0] * E->x[m][3][nodel]; /* vy =  */
Ggrd_handling.c:1347:		  vx[3]=euler[euler_i][code].w[0] * E->x[m][2][nodel] - euler[euler_i][code].w[1] * E->x[m][1][nodel]; /* vz =  */
Ggrd_handling.c:1357:		  E->sphere.cap.VB[1][nodel] = 0;	/* theta */
Ggrd_handling.c:1358:		  E->sphere.cap.VB[2][nodel] = 0;	/* phi */
Ggrd_handling.c:1361:		  E->sphere.cap.VB[1][nodel] = v[1];	/* theta */
Ggrd_handling.c:1362:		  E->sphere.cap.VB[2][nodel] = v[2];	/* phi */
Ggrd_handling.c:1365:		  E->sphere.cap.VB[3][nodel] = 0.0; /* r */
Ggrd_handling.c:1371:      if((!timedep)&&(!E->control.ggrd.vtop_control_init)){			/* forget the grids */
Ggrd_handling.c:1372:	ggrd_grdtrack_free_gstruc(E->control.ggrd.svt);
Ggrd_handling.c:1373:	ggrd_grdtrack_free_gstruc(E->control.ggrd.svp);
Ggrd_handling.c:1377:    if(E->control.ggrd_vtop_euler){
Ggrd_handling.c:1382:      for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++) /* unload */
Ggrd_handling.c:1391:  E->control.ggrd.vtop_control_init = TRUE;
Ggrd_handling.c:1408:    if(E->mesh.toplayerbc > 0){
Ggrd_handling.c:1411:	if(E->SX[level][3][k] < E->mesh.toplayerbc_r) /* assume regular mesh structure */
Ggrd_handling.c:1419:    }else if(E->mesh.toplayerbc < 0){
Ggrd_handling.c:1421:      if(level == E->mesh.gridmax)
Ggrd_handling.c:1422:	*botnode = nozl + E->mesh.toplayerbc;
Ggrd_handling.c:1424:	*botnode = nozl + (int)((float)E->mesh.toplayerbc / pow(2.,(float)(E->mesh.gridmax-level)));
Ggrd_handling.c:1430:	      E->mesh.toplayerbc,E->mesh.toplayerbc_r);
Ggrd_handling.c:1436:	    allow_internal,*assign,*botnode,*topnode,nozl,E->mesh.toplayerbc_r);
Ggrd_handling.c:1450:  if(!E->control.ggrd.ray_control_init)
Ggrd_handling.c:1452:  if(E->parallel.me == 0)
Ggrd_handling.c:1454:	    E->control.ggrd.ray_control);
Ggrd_handling.c:1459:    for(snode=1;snode <= E->lmesh.nsf;snode++){ /* loop through surface nodes */
Ggrd_handling.c:1460:      if(fabs(E->control.surface_rayleigh[snode]-1.0)>1e-6){
Ggrd_handling.c:1461:	for(i=1;i <= E->lmesh.noz;i++){ /* go through depth layers */
Ggrd_handling.c:1462:	  node = (snode-1)*E->lmesh.noz + i; /* global node number */
Ggrd_handling.c:1463:	  if(layers(E,node) <= E->control.ggrd.ray_control){ 
Ggrd_handling.c:1468:	    xloc=1.0 + ((1 - E->sx[3][node]) - 
Ggrd_handling.c:1469:			E->viscosity.zbase_layer[E->control.ggrd.ray_control-1])/
Ggrd_handling.c:1470:	      E->viscosity.zbase_layer[E->control.ggrd.ray_control-1];
Ggrd_handling.c:1478:	    bnew = buoy[node] * E->control.surface_rayleigh[snode]; /* modified rayleigh */
Ggrd_handling.c:1535:  const int dims=E->mesh.nsd;
Ggrd_handling.c:1539:  const int vpts = vpoints[E->mesh.nsd];
Ggrd_handling.c:1542:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Ggrd_handling.c:1543:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Ggrd_handling.c:1552:  if(E->viscosity.allow_anisotropic_viscosity == 0)
Ggrd_handling.c:1556:  for(i=E->mesh.gridmin;i <= E->mesh.gridmax;i++){
Ggrd_handling.c:1557:    nel  = E->lmesh.NEL[i];
Ggrd_handling.c:1561:        E->EVI2[i][ind] = 0.0;
Ggrd_handling.c:1562:        E->EVIn1[i][ind] = 1.0; E->EVIn2[i][ind] = E->EVIn3[i][ind] = 0.0;
Ggrd_handling.c:1563:        E->avmode[i][ind] = (unsigned char)
Ggrd_handling.c:1564:        E->viscosity.allow_anisotropic_viscosity;
Ggrd_handling.c:1577:  if(E->parallel.me > 0)	/* wait for previous processor */
Ggrd_handling.c:1578:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:1579:		      0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:1589:  if(E->parallel.me==0){
Ggrd_handling.c:1590:    if(E->viscosity.anivisc_layer > 0){
Ggrd_handling.c:1592:	      E->data.radius_km*E->viscosity.zbase_layer[E->viscosity.anivisc_layer - 1],
Ggrd_handling.c:1596:	      E->data.radius_km*((E->viscosity.anivisc_layer<-1)?(E->viscosity.zbase_layer[-E->viscosity.anivisc_layer - 2]):(0)),
Ggrd_handling.c:1597:	      E->data.radius_km*E->viscosity.zbase_layer[-E->viscosity.anivisc_layer - 1],
Ggrd_handling.c:1606:  sprintf(tfilename,"%s/vis2.grd",E->viscosity.anisotropic_init_dir);
Ggrd_handling.c:1608:				vis2_grd,(E->parallel.me == 0),FALSE,
Ggrd_handling.c:1612:  sprintf(tfilename,"%s/nr.grd",E->viscosity.anisotropic_init_dir);
Ggrd_handling.c:1614:				nr_grd,(E->parallel.me == 0),FALSE,
Ggrd_handling.c:1618:  sprintf(tfilename,"%s/nt.grd",E->viscosity.anisotropic_init_dir);
Ggrd_handling.c:1620:				ntheta_grd,(E->parallel.me == 0),FALSE,
Ggrd_handling.c:1624:  sprintf(tfilename,"%s/np.grd",E->viscosity.anisotropic_init_dir);
Ggrd_handling.c:1626:				nphi_grd,(E->parallel.me == 0),FALSE,
Ggrd_handling.c:1631:  if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Ggrd_handling.c:1633:		      MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:1644:      if(((E->viscosity.anivisc_layer > 0)&&
Ggrd_handling.c:1645:	  (E->mat[j] <=   E->viscosity.anivisc_layer))||
Ggrd_handling.c:1646:	 ((E->viscosity.anivisc_layer < 0)&&
Ggrd_handling.c:1647:	  (E->mat[j] ==  -E->viscosity.anivisc_layer))){
Ggrd_handling.c:1658:	      ind = E->ien[el].node[inode];
Ggrd_handling.c:1659:	      xloc[1] += E->x[1][ind];
Ggrd_handling.c:1660:	      xloc[2] += E->x[2][ind];
Ggrd_handling.c:1661:	      xloc[3] += E->x[3][ind];
Ggrd_handling.c:1705:	      E->EVI2[E->mesh.gridmax][ind]  =   vis2;
Ggrd_handling.c:1706:	      E->EVIn1[E->mesh.gridmax][ind]  = cvec[0];
Ggrd_handling.c:1707:	      E->EVIn2[E->mesh.gridmax][ind]  = cvec[1];
Ggrd_handling.c:1708:	      E->EVIn3[E->mesh.gridmax][ind]  = cvec[2];
Global_operations.c:52:    const int dims = E->mesh.nsd;
Global_operations.c:54:    noy = E->lmesh.noy;
Global_operations.c:55:    noz = E->lmesh.noz;
Global_operations.c:56:    nox = E->lmesh.nox;
Global_operations.c:72:    H = (double *)malloc( (E->lmesh.noz+1)*sizeof(double));
Global_operations.c:80:  const int dims = E->mesh.nsd;
Global_operations.c:88:  sizeofH = (2*E->lmesh.noz+2)*sizeof(double);
Global_operations.c:93:  noz = E->lmesh.noz;
Global_operations.c:94:  noy = E->lmesh.noy;
Global_operations.c:95:  elz = E->lmesh.elz;
Global_operations.c:96:  elx = E->lmesh.elx;
Global_operations.c:97:  ely = E->lmesh.ely;
Global_operations.c:110:          lnode[1] = E->ien[el].node[1];
Global_operations.c:111:          lnode[2] = E->ien[el].node[2];
Global_operations.c:112:          lnode[3] = E->ien[el].node[3];
Global_operations.c:113:          lnode[4] = E->ien[el].node[4];
Global_operations.c:115:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:116:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:117:              temp[i] += X[lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:123:            lnode[1] = E->ien[el].node[5];
Global_operations.c:124:            lnode[2] = E->ien[el].node[6];
Global_operations.c:125:            lnode[3] = E->ien[el].node[7];
Global_operations.c:126:            lnode[4] = E->ien[el].node[8];
Global_operations.c:128:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:129:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:130:                temp[i+1] += X[lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:139:  MPI_Allreduce(temp,Have,noz2+1,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:145: /* if (E->parallel.me==0)
Global_operations.c:147:      fprintf(stderr,"area %d %d %g\n",E->parallel.me,i,Have[i+noz]);
Global_operations.c:156:  const int dims = E->mesh.nsd;
Global_operations.c:164:  sizeofH = (2*E->lmesh.noz+2)*sizeof(float);
Global_operations.c:169:  noz = E->lmesh.noz;
Global_operations.c:170:  noy = E->lmesh.noy;
Global_operations.c:171:  elz = E->lmesh.elz;
Global_operations.c:172:  elx = E->lmesh.elx;
Global_operations.c:173:  ely = E->lmesh.ely;
Global_operations.c:186:          lnode[1] = E->ien[el].node[1];
Global_operations.c:187:          lnode[2] = E->ien[el].node[2];
Global_operations.c:188:          lnode[3] = E->ien[el].node[3];
Global_operations.c:189:          lnode[4] = E->ien[el].node[4];
Global_operations.c:191:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:192:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:193:              temp[i] += X[lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:199:            lnode[1] = E->ien[el].node[5];
Global_operations.c:200:            lnode[2] = E->ien[el].node[6];
Global_operations.c:201:            lnode[3] = E->ien[el].node[7];
Global_operations.c:202:            lnode[4] = E->ien[el].node[8];
Global_operations.c:204:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:205:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:206:                temp[i+1] += X[lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:215:  MPI_Allreduce(temp,Have,noz2+1,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:242:  sizeofH = (2*E->lmesh.elz+2)*sizeof(double);
Global_operations.c:247:  noz = E->lmesh.noz;
Global_operations.c:248:  noy = E->lmesh.noy;
Global_operations.c:249:  elz = E->lmesh.elz;
Global_operations.c:250:  elx = E->lmesh.elx;
Global_operations.c:251:  ely = E->lmesh.ely;
Global_operations.c:266:        temp[i] += X[el]*E->ECO[E->mesh.levmax][el].area;
Global_operations.c:267:        temp[i+elz] += E->ECO[E->mesh.levmax][el].area;
Global_operations.c:275:  MPI_Allreduce(temp,Have,elz2+1,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:292:    const int vpts = vpoints[E->mesh.nsd];
Global_operations.c:293:    const int ends = enodes[E->mesh.nsd];
Global_operations.c:298:    for (el=1;el<=E->lmesh.nel;el++)  {
Global_operations.c:301:          n = E->ien[el].node[i];
Global_operations.c:302:          volume1 += E->N.vpt[GNVINDEX(i,j)] * E->gDA[el].vpt[j];
Global_operations.c:303:          integral1 += Z[n] * E->N.vpt[GNVINDEX(i,j)] * E->gDA[el].vpt[j];
Global_operations.c:307:    MPI_Allreduce(&volume1  ,&volume  ,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:308:    MPI_Allreduce(&integral1,&integral,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:326:  const int vpts = vpoints[E->mesh.nsd];
Global_operations.c:327:  const int ends = enodes[E->mesh.nsd];
Global_operations.c:332:  for (el=1;el<=E->lmesh.nel;el++)  {
Global_operations.c:335:          n = E->ien[el].node[i];
Global_operations.c:336:          volume1 += E->N.vpt[GNVINDEX(i,j)] * E->gDA[el].vpt[j];
Global_operations.c:337:          integral1 += Z[n] * E->N.vpt[GNVINDEX(i,j)] * E->gDA[el].vpt[j];
Global_operations.c:342:  MPI_Allreduce(&volume1  ,&volume  ,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:343:  MPI_Allreduce(&integral1,&integral,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:355: MPI_Allreduce(&Tmax,&ttmax,1,MPI_FLOAT,MPI_MAX,E->parallel.horizontal_comm);
Global_operations.c:366: MPI_Allreduce(data,temp,total,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:381: temp = (float *) malloc((E->sphere.hindice*2)*sizeof(float));
Global_operations.c:382: sphcs = (float *) malloc((E->sphere.hindice*2)*sizeof(float));
Global_operations.c:385: jumpp = E->sphere.hindice;
Global_operations.c:386: total = E->sphere.hindice*2;
Global_operations.c:387: for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:393: MPI_Allreduce(sphcs,temp,total,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:396: for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:411:  neq=E->lmesh.NEQ[lev];
Global_operations.c:416:  neq=E->lmesh.NEQ[lev];
Global_operations.c:421:  for (i=1;i<=E->parallel.Skip_neq[lev];i++)
Global_operations.c:422:     temp1 += A[E->parallel.Skip_id[lev][i]]*B[E->parallel.Skip_id[lev][i]];
Global_operations.c:426:  MPI_Allreduce(&temp, &prod,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:439:  neq=E->lmesh.NEQ[lev];
Global_operations.c:445:  for (i=1;i<=E->parallel.Skip_neq[lev];i++)
Global_operations.c:446:    if ((E->parallel.Skip_id[lev][i]+1)%3==0)
Global_operations.c:447:      temp1 += A[E->parallel.Skip_id[lev][i]]*A[E->parallel.Skip_id[lev][i]];
Global_operations.c:451:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:464:  neq=E->lmesh.NEQ[lev];
Global_operations.c:469:  for (i=1;i<=E->parallel.Skip_neq[lev];i++)
Global_operations.c:470:     temp1 += A[E->parallel.Skip_id[lev][i]]*B[E->parallel.Skip_id[lev][i]];
Global_operations.c:474:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:484:  npno=E->lmesh.NPNO[lev];
Global_operations.c:488:  npno=E->lmesh.NPNO[lev];
Global_operations.c:492:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:507:    for (i=1; i<=E->lmesh.nno; i++) {
Global_operations.c:508:        eqn1 = E->id[i].doff[1];
Global_operations.c:509:        eqn2 = E->id[i].doff[2];
Global_operations.c:510:        eqn3 = E->id[i].doff[3];
Global_operations.c:514:                 V[eqn3] * V[eqn3]) * E->NMass[i];
Global_operations.c:517:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:519:    return (prod/E->mesh.volume);
Global_operations.c:531:    for (i=1; i<=E->lmesh.npno; i++) {
Global_operations.c:533:        temp += P[i] * P[i] * E->eco[i].area;
Global_operations.c:536:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:538:    return (prod/E->mesh.volume);
Global_operations.c:550:    for (i=1; i<=E->lmesh.npno; i++) {
Global_operations.c:552:        temp += A[i] * A[i] / E->eco[i].area;
Global_operations.c:558:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:560:    return (prod/E->mesh.volume);
Global_operations.c:568:  nno=E->lmesh.NNO[lev];
Global_operations.c:572:  nno=E->lmesh.NNO[lev];
Global_operations.c:574:  if (!(E->NODE[lev][i] & SKIP))
Global_operations.c:577:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:590:  nno=E->lmesh.NNO[lev];
Global_operations.c:592:    if (!(E->NODE[lev][i] & SKIP))
Global_operations.c:595:  MPI_Allreduce(&temp, &prod,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:606:  MPI_Allreduce(&a, &temp,1,MPI_FLOAT,MPI_MIN,E->parallel.world);
Global_operations.c:613:  MPI_Allreduce(&a, &temp,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Global_operations.c:620:  MPI_Allreduce(&a, &temp,1,MPI_FLOAT,MPI_MAX,E->parallel.world);
Global_operations.c:630:  for(i=1;i<=E->lmesh.nno;i++)
Global_operations.c:643:  for(i=1;i<=E->lmesh.nno;i++)
Global_operations.c:654: const int dims = E->mesh.nsd;
Global_operations.c:656: const int nel=E->lmesh.nel;
Global_operations.c:663:         node = E->IEN[lev][e].node[a];
Global_operations.c:664:         dtemp += dU[ E->ID[lev][node].doff[i] ]*
Global_operations.c:665:                  dU[ E->ID[lev][node].doff[i] ];
Global_operations.c:666:         temp += U[ E->ID[lev][node].doff[i] ]*
Global_operations.c:667:                 U[ E->ID[lev][node].doff[i] ];
Global_operations.c:671:  MPI_Allreduce(&dtemp, &temp2,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:672:  MPI_Allreduce(&temp, &temp1,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:685:    if (E->parallel.nprocz > 1)  {
Global_operations.c:686:	total = E->sphere.hindice*2;
Global_operations.c:691:	jumpp = E->sphere.hindice;
Global_operations.c:692:	for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:699:		      E->parallel.vertical_comm);
Global_operations.c:702:	for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:719:    if(E->parallel.nprocz == 1) return;
Global_operations.c:721:    jumpp = E->sphere.hindice;
Global_operations.c:722:    total = E->sphere.hindice*2;
Global_operations.c:725:    if (E->parallel.me_loc[3] == root) {
Global_operations.c:727:        for (j=0; j<E->sphere.hindice; j++)   {
Global_operations.c:733:    MPI_Bcast(temp, total, MPI_FLOAT, root, E->parallel.vertical_comm);
Global_operations.c:735:    if (E->parallel.me_loc[3] != root) {
Global_operations.c:737:        for (j=0; j<E->sphere.hindice; j++)   {
Global_operations.c:764:    const int lev = E->mesh.levmax;
Global_operations.c:765:    const int nno = E->lmesh.nno;
Global_operations.c:775:    if(E->control.remove_angular_momentum) {
Global_operations.c:777:        for (i=1;i<=E->lmesh.elz;i++)
Global_operations.c:779:                0.5*(E->refstate.rho[i] + E->refstate.rho[i+1])*
Global_operations.c:780:                (pow(E->sx[3][i+1],5.0) - pow(E->sx[3][i],5.0));
Global_operations.c:783:                      MPI_SUM, E->parallel.vertical_comm);
Global_operations.c:787:            (pow(E->sphere.ro,5.0) - pow(E->sphere.ri,5.0));
Global_operations.c:796:      for (e=1;e<=E->lmesh.nel;e++) {
Global_operations.c:798:	t = theta_g(E->eco[e].centre[1],E);
Global_operations.c:800:	t = E->eco[e].centre[1];
Global_operations.c:802:	f = E->eco[e].centre[2];
Global_operations.c:803:	r = E->eco[e].centre[3];
Global_operations.c:815:	    vx[j] += VV[1][i]*E->N.ppt[GNPINDEX(i,j)]; 
Global_operations.c:816:	    vy[j] += VV[2][i]*E->N.ppt[GNPINDEX(i,j)]; 
Global_operations.c:823:        if(E->control.remove_angular_momentum) {
Global_operations.c:824:            int nz = (e-1) % E->lmesh.elz + 1;
Global_operations.c:825:            rho = 0.5 * (E->refstate.rho[nz] + E->refstate.rho[nz+1]);
Global_operations.c:829:	exyz[1] += (wx*cos_t*cos_f - wy*sin_f) * E->eco[e].area * rho;
Global_operations.c:830:	exyz[2] += (wx*cos_t*sin_f + wy*cos_f) * E->eco[e].area * rho;
Global_operations.c:831:	exyz[3] -= (wx*sin_t                 ) * E->eco[e].area * rho;
Global_operations.c:834:    MPI_Allreduce(exyz,fxyz,4,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:844:    if (E->parallel.me==0) {
Global_operations.c:845:        if(E->control.remove_angular_momentum) {
Global_operations.c:846:            fprintf(E->fp,"Angular momentum: rot=%e tr=%e fr=%e\n",rot,tr*180/M_PI,fr*180/M_PI);
Global_operations.c:849:            fprintf(E->fp,"Rigid rotation: rot=%e tr=%e fr=%e\n",rot,tr*180/M_PI,fr*180/M_PI);
Global_operations.c:859:	vx[0] = fxyz[2]* E->x[3][node] - fxyz[3]*E->x[2][node];
Global_operations.c:860:	vx[1] = fxyz[3]* E->x[1][node] - fxyz[1]*E->x[3][node];
Global_operations.c:861:	vx[2] = fxyz[1]* E->x[2][node] - fxyz[2]*E->x[1][node];
Global_operations.c:866:	E->sphere.cap.V[1][node] -= v_theta;
Global_operations.c:867:	E->sphere.cap.V[2][node] -= v_phi;
Global_operations.c:873:	frd = fr - E->sx[2][node];
Global_operations.c:874:	v_theta = E->sx[3][node] * sin_t * sin(frd);
Global_operations.c:875:	v_phi =   E->sx[3][node] * 
Global_operations.c:876:	  (  E->SinCos[lev][0][node] * cos_t - E->SinCos[lev][2][node]  * sin_t * cos(frd) );
Global_operations.c:878:	E->sphere.cap.V[1][node] -= v_theta;
Global_operations.c:879:	E->sphere.cap.V[2][node] -= v_phi;
Initial_temperature.c:58:  int m = E->parallel.me;
Initial_temperature.c:59:  int noz = E->lmesh.noz;
Initial_temperature.c:65:  input_int("tic_method", &(E->convection.tic_method), "0,0,2", m);
Initial_temperature.c:70:    E->convection.tic_method = 4; /*  */
Initial_temperature.c:71:    E->control.ggrd.use_temp = 1;
Initial_temperature.c:86:     (E->control.mantle_temp).
Initial_temperature.c:107:      E->convection.number_of_perturbations = n;
Initial_temperature.c:109:      if (! input_float_vector("perturbmag", n, E->convection.perturb_mag, m) ) {
Initial_temperature.c:113:      if (! input_int_vector("perturbm", n, E->convection.perturb_mm, m) ) {
Initial_temperature.c:117:      if (! input_int_vector("perturbl", n, E->convection.perturb_ll, m) ) {
Initial_temperature.c:121:      if (! input_int_vector("perturblayer", n, E->convection.load_depth, m) ) {
Initial_temperature.c:127:      E->convection.number_of_perturbations = 1;
Initial_temperature.c:128:      E->convection.perturb_mag[0] = 1;
Initial_temperature.c:129:      E->convection.perturb_mm[0] = 2;
Initial_temperature.c:130:      E->convection.perturb_ll[0] = 2;
Initial_temperature.c:131:      E->convection.load_depth[0] = (noz+1)/2;
Initial_temperature.c:134:    input_float("half_space_age", &(E->convection.half_space_age), "40.0,1e-3,nomax", m);
Initial_temperature.c:135:    input_float("mantle_temp",&(E->control.mantle_temp),"1.0",m);
Initial_temperature.c:138:    switch(E->convection.tic_method){
Initial_temperature.c:140:      if( ! input_float_vector("blob_center", 3, E->convection.blob_center, m)) {
Initial_temperature.c:141:	assert( E->sphere.caps == 12 || E->sphere.caps == 1 );
Initial_temperature.c:142:	if(E->sphere.caps == 12) { /* Full version: just quit here */
Initial_temperature.c:146:	else if(E->sphere.caps == 1) { /* Regional version: put the blob at the center */
Initial_temperature.c:148:	  E->convection.blob_center[0] = 0.5*(E->control.theta_min+E->control.theta_max);
Initial_temperature.c:149:	  E->convection.blob_center[1] = 0.5*(E->control.fi_min+E->control.fi_max);
Initial_temperature.c:150:	  E->convection.blob_center[2] = 0.5*(E->sphere.ri+E->sphere.ro);
Initial_temperature.c:153:      input_float("blob_radius", &(E->convection.blob_radius), "0.063,0.0,1.0", m);
Initial_temperature.c:154:      input_float("blob_dT", &(E->convection.blob_dT), "0.18,nomin,nomax", m);
Initial_temperature.c:155:      input_boolean("blob_bc_persist",&(E->convection.blob_bc_persist),"off",m);
Initial_temperature.c:168:		    &(E->control.ggrd.temp.scale_with_prem),"off",E->parallel.me);
Initial_temperature.c:171:		    &(E->control.ggrd.temp.limit_trange),"on",E->parallel.me);
Initial_temperature.c:174:		   &(E->control.ggrd.temp.scale),"1.0",E->parallel.me); /* scale */
Initial_temperature.c:177:		   &(E->control.ggrd.temp.offset),"0.0",E->parallel.me); /* offset */
Initial_temperature.c:181:      input_float("ggrd_lower_depth_km",&(E->control.ggrd_lower_depth_km),"7000",
Initial_temperature.c:182:		  E->parallel.me); /* depth, in km, below which
Initial_temperature.c:184:      input_float("ggrd_lower_scale",&(E->control.ggrd_lower_scale),"1.0",E->parallel.me);
Initial_temperature.c:185:      input_float("ggrd_lower_offset",&(E->control.ggrd_lower_offset),"1.0",E->parallel.me);
Initial_temperature.c:189:		   E->control.ggrd.temp.gfile,"",E->parallel.me); /* grids */
Initial_temperature.c:191:		   E->control.ggrd.temp.dfile,"",E->parallel.me); /* depth.dat layers of grids*/
Initial_temperature.c:194:		    &(E->control.ggrd.temp.override_tbc),"off",E->parallel.me);
Initial_temperature.c:196:		   E->control.ggrd.temp.prem.model_filename,"hc/prem/prem.dat", 
Initial_temperature.c:197:		   E->parallel.me); /* PREM model filename */
Initial_temperature.c:200:      input_boolean("ggrd_tinit_nl_scale",&(E->control.ggrd_tinit_nl_scale),"off",E->parallel.me);
Initial_temperature.c:216:  if (E->convection.tic_method == -1) {
Initial_temperature.c:219:      if(strcmp(E->output.format, "ascii-gz") == 0)
Initial_temperature.c:225:  else if (E->control.lith_age)
Initial_temperature.c:233:  if (E->control.verbose)
Initial_temperature.c:241:  fprintf(E->fp_out,"output_temperature\n");
Initial_temperature.c:242:  fprintf(E->fp_out,"for cap %d\n",E->sphere.capid);
Initial_temperature.c:243:  for (j=1;j<=E->lmesh.nno;j++)
Initial_temperature.c:244:    fprintf(E->fp_out,"X = %.6e Z = %.6e Y = %.6e T[%06d] = %.6e \n",
Initial_temperature.c:245:        E->sx[1][j],E->sx[2][j],E->sx[3][j],j,E->T[j]);
Initial_temperature.c:246:  fflush(E->fp_out);
Initial_temperature.c:259:  ii = E->monitor.solution_cycles_init;
Initial_temperature.c:260:  sprintf(output_file,"%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,ii);
Initial_temperature.c:263:    fprintf(E->fp,"(Initial_temperature.c #1) Cannot open %s\n",output_file);
Initial_temperature.c:267:  if (E->parallel.me==0)
Initial_temperature.c:268:    fprintf(E->fp,"Reading %s for initial temperature\n",output_file);
Initial_temperature.c:275:  for(i=1;i<=E->lmesh.nno;i++)  {
Initial_temperature.c:283:    E->T[i] = max(0.0,min(g,1.0));
Initial_temperature.c:297:    nox = E->lmesh.nox;
Initial_temperature.c:298:    noy = E->lmesh.noy;
Initial_temperature.c:299:    noz = E->lmesh.noz;
Initial_temperature.c:305:                r1 = E->sx[3][node];
Initial_temperature.c:306:                E->T[node] = E->control.TBCbotval - (E->control.TBCtopval + 
Initial_temperature.c:307:                    E->control.TBCbotval)*(r1 - E->sphere.ri)/
Initial_temperature.c:308:                  (E->sphere.ro - E->sphere.ri);
Initial_temperature.c:319:    nox = E->lmesh.nox;
Initial_temperature.c:320:    noy = E->lmesh.noy;
Initial_temperature.c:321:    noz = E->lmesh.noz;
Initial_temperature.c:327:                r1 = E->sx[3][node];
Initial_temperature.c:328:                E->T[node] = (E->control.TBCtopval*E->sphere.ro
Initial_temperature.c:329:                                 - E->control.TBCbotval*E->sphere.ri)
Initial_temperature.c:330:                    / (E->sphere.ro - E->sphere.ri)
Initial_temperature.c:331:                    + (E->control.TBCbotval - E->control.TBCtopval)
Initial_temperature.c:332:                    * E->sphere.ro * E->sphere.ri / r1
Initial_temperature.c:333:                    / (E->sphere.ro - E->sphere.ri);
Initial_temperature.c:343:    for(i=1; i<=E->lmesh.nno; i++)
Initial_temperature.c:344:        E->T[i] = mantle_temp;
Initial_temperature.c:354:    nox = E->lmesh.nox;
Initial_temperature.c:355:    noy = E->lmesh.noy;
Initial_temperature.c:356:    noz = E->lmesh.noz;
Initial_temperature.c:358:    dT = (mantle_temp - E->control.TBCtopval);
Initial_temperature.c:359:    tmp = 0.5 / sqrt(age_in_myrs / E->data.scalet);
Initial_temperature.c:366:                r1 = E->sx[3][node];
Initial_temperature.c:367:                E->T[node] -= dT * erfc(tmp * (E->sphere.ro - r1));
Initial_temperature.c:378:    nox = E->lmesh.nox;
Initial_temperature.c:379:    noy = E->lmesh.noy;
Initial_temperature.c:380:    noz = E->lmesh.noz;
Initial_temperature.c:382:    dT = (E->control.TBCbotval - mantle_temp);
Initial_temperature.c:383:    tmp = 0.5 / sqrt(age_in_myrs / E->data.scalet);
Initial_temperature.c:389:                r1 = E->sx[3][node];
Initial_temperature.c:390:                E->T[node] += dT * erfc(tmp * (r1 - E->sphere.ri));
Initial_temperature.c:406:    nox = E->lmesh.nox;
Initial_temperature.c:407:    noy = E->lmesh.noy;
Initial_temperature.c:408:    noz = E->lmesh.noz;
Initial_temperature.c:409:    gnoz = E->mesh.noz;
Initial_temperature.c:411:    for (p=0; p<E->convection.number_of_perturbations; p++) {
Initial_temperature.c:412:        ll = E->convection.perturb_ll[p];
Initial_temperature.c:413:        mm = E->convection.perturb_mm[p];
Initial_temperature.c:414:        kk = E->convection.load_depth[p];
Initial_temperature.c:415:        con = E->convection.perturb_mag[p];
Initial_temperature.c:419:        k = kk - E->lmesh.nzs + 1; /* convert global nz to local nz */
Initial_temperature.c:421:        if (E->parallel.me_loc[1] == 0 && E->parallel.me_loc[2] == 0
Initial_temperature.c:422:            && E->sphere.capid == 1 )
Initial_temperature.c:425:        if(E->sphere.caps == 1) {
Initial_temperature.c:428:            tlen = M_PI / (E->control.theta_max - E->control.theta_min);
Initial_temperature.c:429:            flen = M_PI / (E->control.fi_max - E->control.fi_min);
Initial_temperature.c:434:                    t1 = (E->sx[1][node] - E->control.theta_min) * tlen;
Initial_temperature.c:435:                    f1 = (E->sx[2][node] - E->control.fi_min) * flen;
Initial_temperature.c:437:                    E->T[node] += con * cos(ll*t1) * cos(mm*f1);
Initial_temperature.c:446:                        t1 = E->sx[1][node];
Initial_temperature.c:447:                        f1 = E->sx[2][node];
Initial_temperature.c:449:                        E->T[node] += 
Initial_temperature.c:468:    nox = E->lmesh.nox;
Initial_temperature.c:469:    noy = E->lmesh.noy;
Initial_temperature.c:470:    noz = E->lmesh.noz;
Initial_temperature.c:471:    gnoz = E->mesh.noz;
Initial_temperature.c:473:    rlen = M_PI / (E->sphere.ro - E->sphere.ri);
Initial_temperature.c:475:    for (p=0; p<E->convection.number_of_perturbations; p++) {
Initial_temperature.c:476:        ll = E->convection.perturb_ll[p];
Initial_temperature.c:477:        mm = E->convection.perturb_mm[p];
Initial_temperature.c:478:        con = E->convection.perturb_mag[p];
Initial_temperature.c:480:        if (E->parallel.me_loc[1] == 0 && E->parallel.me_loc[2] == 0
Initial_temperature.c:481:            && E->sphere.capid == 1 )
Initial_temperature.c:484:        if(E->sphere.caps == 1) {
Initial_temperature.c:487:            tlen = M_PI / (E->control.theta_max - E->control.theta_min);
Initial_temperature.c:488:            flen = M_PI / (E->control.fi_max - E->control.fi_min);
Initial_temperature.c:494:                        t1 = (E->sx[1][node] - E->control.theta_min) * tlen;
Initial_temperature.c:495:                        f1 = (E->sx[2][node] - E->control.fi_min) * flen;
Initial_temperature.c:496:                        r1 = E->sx[3][node];
Initial_temperature.c:498:                        E->T[node] += con * cos(ll*t1) * cos(mm*f1)
Initial_temperature.c:499:                            * sin((r1-E->sphere.ri) * rlen);
Initial_temperature.c:508:                        t1 = E->sx[1][node];
Initial_temperature.c:509:                        f1 = E->sx[2][node];
Initial_temperature.c:510:                        r1 = E->sx[3][node];
Initial_temperature.c:512:                        E->T[node] += con * modified_plgndr_a(ll,mm,t1)
Initial_temperature.c:514:                            * sin((r1-E->sphere.ri) * rlen);
Initial_temperature.c:531:    noy = E->lmesh.noy;
Initial_temperature.c:532:    nox = E->lmesh.nox;
Initial_temperature.c:533:    noz = E->lmesh.noz;
Initial_temperature.c:535:    rout = E->sphere.ro;
Initial_temperature.c:536:    rin = E->sphere.ri;
Initial_temperature.c:539:    theta_center = E->convection.blob_center[0];
Initial_temperature.c:540:    fi_center    = E->convection.blob_center[1];
Initial_temperature.c:541:    r_center     = E->convection.blob_center[2];
Initial_temperature.c:542:    radius       = E->convection.blob_radius;
Initial_temperature.c:543:    amp          = E->convection.blob_dT;
Initial_temperature.c:545:    if(E->parallel.me == 0)
Initial_temperature.c:556:                dx[1] = E->x[1][node] - x_center[1];
Initial_temperature.c:557:                dx[2] = E->x[2][node] - x_center[2];
Initial_temperature.c:558:                dx[3] = E->x[3][node] - x_center[3];
Initial_temperature.c:562:                  E->T[node] += amp * exp(-1.0*distance/radius);
Initial_temperature.c:564:                  if(E->convection.blob_bc_persist){
Initial_temperature.c:565:                    r1 = E->sx[3][node];
Initial_temperature.c:568:                      E->sphere.cap.TB[1][node]=E->T[node];
Initial_temperature.c:569:                      E->sphere.cap.TB[2][node]=E->T[node];
Initial_temperature.c:570:                      E->sphere.cap.TB[3][node]=E->T[node];
Initial_temperature.c:582:    switch (E->convection.tic_method){
Initial_temperature.c:593:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:599:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:601:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:625:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:627:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:635:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:637:        add_bottom_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:645:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:647:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:648:        add_bottom_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:657:        if((E->parallel.nprocz % 2) == 0) {
Initial_temperature.c:658:            if(E->parallel.me==0)
Initial_temperature.c:660:                        E->convection.tic_method);
Initial_temperature.c:672:            E->convection.number_of_perturbations = 1;
Initial_temperature.c:674:            mid = (E->mesh.noz+1) / 2;
Initial_temperature.c:675:            E->convection.load_depth[0] = mid;
Initial_temperature.c:677:            k = mid - E->lmesh.nzs + 1; /* convert to local nz */
Initial_temperature.c:678:            E->convection.perturb_mag[0] = 0;
Initial_temperature.c:679:            if ( (k > 1) && (k < E->lmesh.noz) ) {
Initial_temperature.c:681:                E->convection.perturb_mag[0] = 2 / (E->sx[3][k+1] - E->sx[3][k-1]);
Initial_temperature.c:691:                E->convection.tic_method);
Initial_temperature.c:697:        fprintf(stderr,"Invalid value: 'tic_method=%d'\n", E->convection.tic_method);
Instructions.c:92:  //chatty = ((E->parallel.me == 0)&&(E->control.verbose))?(1):(0);
Instructions.c:93:  chatty = E->parallel.me == 0;
Instructions.c:95:    E->monitor.cpu_time_at_last_cycle =
Instructions.c:96:        E->monitor.cpu_time_at_start = CPU_time0();
Instructions.c:99:    (E->problem_derived_values)(E);   /* call this before global_derived_  */
Instructions.c:102:    (E->solver.parallel_processor_setup)(E);   /* get # of proc in x,y,z */
Instructions.c:103:    (E->solver.parallel_domain_decomp0)(E);  /* get local nel, nno, elx, nox et al */
Instructions.c:106:    (E->problem_allocate_vars)(E);
Instructions.c:107:    (E->solver_allocate_vars)(E);
Instructions.c:112:    (E->solver.construct_boundary)(E);
Instructions.c:113:    (E->solver.parallel_domain_boundary_nodes)(E);
Instructions.c:117:    (E->solver.node_locations)(E);
Instructions.c:130:    if(E->output.write_q_files)
Instructions.c:133:      E->output.fpqt = E->output.fpqb = NULL;
Instructions.c:138:    if(E->control.lith_age)
Instructions.c:141:    (E->problem_boundary_conds)(E);
Instructions.c:151:    (E->solver.parallel_communication_routs_v)(E);
Instructions.c:154:    if(E->control.use_cbf_topo){
Instructions.c:155:      (E->solver.parallel_communication_routs_s)(E); 
Instructions.c:168:    if(E->control.inv_gruneisen != 0)
Instructions.c:184:    if(E->control.tracer) {
Instructions.c:186:	(E->problem_tracer_setup)(E);
Instructions.c:194:    if(E->control.ggrd.ray_control)
Instructions.c:233:    (E->next_buoyancy_field_init)(E);
Instructions.c:244:    if(E->control.mat_control)
Instructions.c:260:    if (E->control.tracer==1) {
Instructions.c:263:        if (E->composition.on)
Instructions.c:267:    (E->problem_initial_fields)(E);   /* temperature/chemistry/melting etc */
Instructions.c:281:  int m=E->parallel.me,i;
Instructions.c:287:  input_string("Problem",E->control.PROBLEM_TYPE,"convection",m);
Instructions.c:289:  if ( strcmp(E->control.PROBLEM_TYPE,"convection") == 0)
Instructions.c:291:  else if ( strcmp(E->control.PROBLEM_TYPE,"convection-chemical") == 0)
Instructions.c:294:    fprintf(E->fp,"Unable to determine problem type, assuming convection ... \n");
Instructions.c:298:  input_string("Geometry",E->control.GEOMETRY,"sphere",m);
Instructions.c:299:  if ( strcmp(E->control.GEOMETRY,"sphere") == 0)
Instructions.c:300:      (E->solver.set_3dsphere_defaults)(E);
Instructions.c:302:    fprintf(E->fp,"Unable to determine geometry, assuming sphere 3d ... \n");
Instructions.c:303:    (E->solver.set_3dsphere_defaults)(E);
Instructions.c:306:  input_string("Solver",E->control.SOLVER_TYPE,"cgrad",m);
Instructions.c:307:  if ( strcmp(E->control.SOLVER_TYPE,"cgrad") == 0)
Instructions.c:309:  else if ( strcmp(E->control.SOLVER_TYPE,"multigrid") == 0)
Instructions.c:312:    if (E->parallel.me==0) fprintf(stderr,"Unable to determine how to solve, specify Solver=VALID_OPTION \n");
Instructions.c:321:  input_string("datadir",E->control.data_dir,".",m);
Instructions.c:322:  input_string("datafile",E->control.data_prefix,"initialize",m);
Instructions.c:323:  input_string("datadir_old",E->control.data_dir_old,".",m);
Instructions.c:324:  input_string("datafile_old",E->control.data_prefix_old,"initialize",m);
Instructions.c:326:  input_int("nproc_surf",&(E->parallel.nprocxy),"1",m);
Instructions.c:327:  input_int("nprocx",&(E->parallel.nprocx),"1",m);
Instructions.c:328:  input_int("nprocy",&(E->parallel.nprocy),"1",m);
Instructions.c:329:  input_int("nprocz",&(E->parallel.nprocz),"1",m);
Instructions.c:331:  if (E->control.CONJ_GRAD) {
Instructions.c:332:      input_int("nodex",&(E->mesh.nox),"essential",m);
Instructions.c:333:      input_int("nodez",&(E->mesh.noz),"essential",m);
Instructions.c:334:      input_int("nodey",&(E->mesh.noy),"essential",m);
Instructions.c:336:      E->mesh.mgunitx = (E->mesh.nox - 1) / E->parallel.nprocx;
Instructions.c:337:      E->mesh.mgunity = (E->mesh.noy - 1) / E->parallel.nprocy;
Instructions.c:338:      E->mesh.mgunitz = (E->mesh.noz - 1) / E->parallel.nprocz;
Instructions.c:339:      E->mesh.levels = 1;
Instructions.c:342:      input_int("mgunitx",&(E->mesh.mgunitx),"1",m);
Instructions.c:343:      input_int("mgunitz",&(E->mesh.mgunitz),"1",m);
Instructions.c:344:      input_int("mgunity",&(E->mesh.mgunity),"1",m);
Instructions.c:346:      input_int("levels",&(E->mesh.levels),"1",m);
Instructions.c:348:      levmax = E->mesh.levels - 1;
Instructions.c:349:      E->mesh.nox = E->mesh.mgunitx * (int) pow(2.0,levmax) * E->parallel.nprocx + 1;
Instructions.c:350:      E->mesh.noy = E->mesh.mgunity * (int) pow(2.0,levmax) * E->parallel.nprocy + 1;
Instructions.c:351:      E->mesh.noz = E->mesh.mgunitz * (int) pow(2.0,levmax) * E->parallel.nprocz + 1;
Instructions.c:354:  input_double("radius_outer",&(E->sphere.ro),"1",m);
Instructions.c:355:  input_double("radius_inner",&(E->sphere.ri),"0.55",m);
Instructions.c:357:  if(E->sphere.caps == 1) {
Instructions.c:358:      input_double("theta_min",&(E->control.theta_min),"essential",m);
Instructions.c:359:      input_double("theta_max",&(E->control.theta_max),"essential",m);
Instructions.c:360:      input_double("fi_min",&(E->control.fi_min),"essential",m);
Instructions.c:361:      input_double("fi_max",&(E->control.fi_max),"essential",m);
Instructions.c:364:  input_int("coor",&(E->control.coor),"0",m);
Instructions.c:365:  if(E->control.coor == 2){
Instructions.c:370:    E->control.coor_refine[0] = 0.10; /* bottom 10% */
Instructions.c:371:    E->control.coor_refine[1] = 0.15; /* get 15% of the nodes */
Instructions.c:372:    E->control.coor_refine[2] = 0.10; /* top 10% */
Instructions.c:373:    E->control.coor_refine[3] = 0.20; /* get 20% of the nodes */
Instructions.c:374:    input_float_vector("coor_refine",4,E->control.coor_refine,m);
Instructions.c:375:  }else if(E->control.coor == 3){
Instructions.c:385:    input_int("r_grid_layers", &(E->control.rlayers), "1",m);
Instructions.c:386:    if(E->control.rlayers > 20)
Instructions.c:389:    input_float_vector("rr", E->control.rlayers, (E->control.rrlayer),m);
Instructions.c:391:    input_int_vector("nr", E->control.rlayers, (E->control.nrlayer),m);
Instructions.c:394:  input_string("coor_file",E->control.coor_file,"",m);
Instructions.c:397:  input_boolean("node_assemble",&(E->control.NASSEMBLE),"off",m);
Instructions.c:400:  input_boolean("verbose",&(E->control.verbose),"off",m);
Instructions.c:401:  input_boolean("see_convergence",&(E->control.print_convergence),"off",m);
Instructions.c:403:  input_boolean("stokes_flow_only",&(E->control.stokes),"off",m);
Instructions.c:405:  //input_boolean("remove_hor_buoy_avg",&(E->control.remove_hor_buoy_avg),"on",m);
Instructions.c:409:  input_boolean("restart",&(E->control.restart),"off",m);
Instructions.c:410:  input_int("post_p",&(E->control.post_p),"0",m);
Instructions.c:411:  input_int("solution_cycles_init",&(E->monitor.solution_cycles_init),"0",m);
Instructions.c:415:  input_int("num_mat",&(E->viscosity.num_mat),"1",m); /* number of layers, moved
Instructions.c:417:  if(E->viscosity.num_mat > CITCOM_MAX_VISC_LAYER)
Instructions.c:422:  input_float("z_cmb",&(E->viscosity.zcmb),"0.45",m); /* 0.45063569 */
Instructions.c:423:  input_float("z_lmantle",&(E->viscosity.zlm),"0.103594412180191",m); /*0.10359441  */
Instructions.c:424:  input_float("z_410",&(E->viscosity.z410),"0.0643541045361796",m); /* 0.06434, more like it */
Instructions.c:425:  input_float("z_lith",&(E->viscosity.zlith),"0.0156961230576048",m); /* 0.0157, more like it */
Instructions.c:430:  E->viscosity.zbase_layer[0] = E->viscosity.zbase_layer[1] = -999;
Instructions.c:431:  input_float_vector("z_layer",E->viscosity.num_mat,(E->viscosity.zbase_layer),m);
Instructions.c:436:  input_float("start_age",&(E->control.start_age),"0.0",m);
Instructions.c:437:  input_int("reset_startage",&(E->control.reset_startage),"0",m);
Instructions.c:438:  input_int("zero_elapsed_time",&(E->control.zero_elapsed_time),"0",m);
Instructions.c:440:  input_int("output_ll_max",&(E->output.llmax),"1",m);
Instructions.c:442:  input_int("topvbc",&(E->mesh.topvbc),"0",m);
Instructions.c:443:  input_int("botvbc",&(E->mesh.botvbc),"0",m);
Instructions.c:451:  input_int("toplayerbc",&(E->mesh.toplayerbc),"0",m); /* > 0: apply surface boundary condition
Instructions.c:456:  input_float("toplayerbc_r",&(E->mesh.toplayerbc_r),"0.984303876942",m); /* minimum r to apply BC to, 
Instructions.c:462:  input_float("topvbxval",&(E->control.VBXtopval),"0.0",m);
Instructions.c:463:  input_float("botvbxval",&(E->control.VBXbotval),"0.0",m);
Instructions.c:464:  input_float("topvbyval",&(E->control.VBYtopval),"0.0",m);
Instructions.c:465:  input_float("botvbyval",&(E->control.VBYbotval),"0.0",m);
Instructions.c:468:  input_float("T_interior_max_for_exit",&(E->monitor.T_interior_max_for_exit),"1.5",m);
Instructions.c:470:  input_int("pseudo_free_surf",&(E->control.pseudo_free_surf),"0",m);
Instructions.c:472:  input_int("toptbc",&(E->mesh.toptbc),"1",m);
Instructions.c:473:  input_int("bottbc",&(E->mesh.bottbc),"1",m);
Instructions.c:474:  input_float("toptbcval",&(E->control.TBCtopval),"0.0",m);
Instructions.c:475:  input_float("bottbcval",&(E->control.TBCbotval),"1.0",m);
Instructions.c:477:  input_boolean("side_sbcs",&(E->control.side_sbcs),"off",m);
Instructions.c:479:  input_int("file_vbcs",&(E->control.vbcs_file),"0",m);
Instructions.c:480:  input_string("vel_bound_file",E->control.velocity_boundary_file,"",m);
Instructions.c:482:  input_int("file_tbcs",&(E->control.tbcs_file),"0",m);
Instructions.c:483:  input_string("temp_bound_file",E->control.temperature_boundary_file,"",m);
Instructions.c:485:  input_int("reference_state",&(E->refstate.choice),"1",m);
Instructions.c:486:  if(E->refstate.choice == 0) {
Instructions.c:487:      input_string("refstate_file",E->refstate.filename,"refstate.dat",m);
Instructions.c:490:  input_int("mineral_physics_model",&(E->control.mineral_physics_model),"1",m);
Instructions.c:492:  input_int("mat_control",&(E->control.mat_control),"0",m);
Instructions.c:493:  input_string("mat_file",E->control.mat_file,"",m);
Instructions.c:496:  input_boolean("precise_strain_rate",&(E->control.precise_strain_rate),"off",m);
Instructions.c:513:     read in time-constant prefactors from weak.grd netcdf file that apply to top two E->mat layers
Instructions.c:543:  ggrd_init_master(&E->control.ggrd);
Instructions.c:547:	       E->control.ggrd.time_hist.file,"",m); 
Instructions.c:548:  /* if > 0, will use top  E->control.ggrd.mat_control layers and assign a prefactor for the viscosity */
Instructions.c:550:  input_int("ggrd_mat_control",&(E->control.ggrd.mat_control),"0",m); 
Instructions.c:551:  input_boolean("ggrd_mat_limit_prefactor",&(E->control.ggrd_mat_limit_prefactor),"on",m); /* limit prefactor to with 1e+/-5 */
Instructions.c:552:  input_int("ggrd_mat_is_code",&(E->control.ggrd_mat_is_code),"0",m); /* the viscosity grids are
Instructions.c:559:  if(E->control.ggrd_mat_is_code){
Instructions.c:561:    E->control.ggrd_mat_code_viscosities = (float *)malloc(sizeof(float)*E->control.ggrd_mat_is_code);
Instructions.c:562:    for(i=0;i < E->control.ggrd_mat_is_code;i++)
Instructions.c:563:      E->control.ggrd_mat_code_viscosities[i] = 1;
Instructions.c:565:		       E->control.ggrd_mat_is_code,(E->control.ggrd_mat_code_viscosities),m);
Instructions.c:567:  input_string("ggrd_mat_file",E->control.ggrd.mat_file,"",m); /* file to read prefactors from */
Instructions.c:569:	       E->control.ggrd_mat_depth_file,"_i_do_not_exist_",m); 
Instructions.c:570:  if(E->control.ggrd.mat_control != 0) /* this will override mat_control setting */
Instructions.c:571:    E->control.mat_control = 1;
Instructions.c:578:	    &(E->control.ggrd.ray_control),"0",m); 
Instructions.c:580:	       E->control.ggrd.ray_file,"",m); /* file to read prefactors from */
Instructions.c:592:  input_int("ggrd_vtop_control",&(E->control.ggrd.vtop_control),"0",m); 
Instructions.c:593:  input_string("ggrd_vtop_dir",E->control.ggrd.vtop_dir,"",m); /* file to read prefactors from */
Instructions.c:601:  from E->control.ggrd.vtop_dir/rotvec.dat
Instructions.c:603:  and location codes from E->control.ggrd.vtop_dir/code.grd
Instructions.c:610:  input_boolean("ggrd_vtop_euler",&(E->control.ggrd_vtop_euler),"off",m);
Instructions.c:611:  if(E->control.ggrd_vtop_euler)
Instructions.c:612:    E->control.ggrd.vtop_control = 1;
Instructions.c:614:  if(E->control.ggrd.vtop_control) /* this will override mat_control setting */
Instructions.c:615:    E->control.vbcs_file = 1;
Instructions.c:621:  input_boolean("allow_mixed_vbcs",&(E->control.ggrd_allow_mixed_vbcs),"off",m);
Instructions.c:626:  input_boolean("ggrd_comp_smooth",&(E->control.ggrd_comp_smooth),"off",m);
Instructions.c:631:  input_boolean("aug_lagr",&(E->control.augmented_Lagr),"off",m);
Instructions.c:632:  input_double("aug_number",&(E->control.augmented),"0.0",m);
Instructions.c:634:  input_boolean("remove_rigid_rotation",&(E->control.remove_rigid_rotation),"on",m);
Instructions.c:635:  input_boolean("inner_remove_rigid_rotation",&(E->control.inner_remove_rigid_rotation),"off",m);
Instructions.c:636:  input_boolean("remove_angular_momentum",&(E->control.remove_angular_momentum),"on",m);
Instructions.c:638:  input_boolean("self_gravitation",&(E->control.self_gravitation),"off",m);
Instructions.c:639:  input_boolean("use_cbf_topo",&(E->control.use_cbf_topo),"off",m); /* make default on later XXX TWB */
Instructions.c:642:  input_int("storage_spacing",&(E->control.record_every),"10",m);
Instructions.c:643:  input_int("checkpointFrequency",&(E->control.checkpoint_frequency),"100",m);
Instructions.c:644:  input_int("cpu_limits_in_seconds",&(E->control.record_all_until),"5",m);
Instructions.c:645:  input_int("write_q_files",&(E->output.write_q_files),"0",m);/* write additional
Instructions.c:647:  if(E->output.write_q_files){	/* make sure those get written at
Instructions.c:649:    E->output.write_q_files = min(E->output.write_q_files,E->control.record_every);
Instructions.c:653:  input_boolean("precond",&(E->control.precondition),"off",m);
Instructions.c:655:  input_int("mg_cycle",&(E->control.mg_cycle),"2,0,nomax",m);
Instructions.c:656:  input_int("down_heavy",&(E->control.down_heavy),"1,0,nomax",m);
Instructions.c:657:  input_int("up_heavy",&(E->control.up_heavy),"1,0,nomax",m);
Instructions.c:658:  input_double("accuracy",&(E->control.accuracy),"1.0e-4,0.0,1.0",m);
Instructions.c:659:  input_double("inner_accuracy_scale",&(E->control.inner_accuracy_scale),"1.0,0.000001,1.0",m);
Instructions.c:661:  input_boolean("force_iteration",&(E->control.force_iteration),"off",m);
Instructions.c:663:  input_boolean("check_continuity_convergence",&(E->control.check_continuity_convergence),"on",m);
Instructions.c:664:  input_boolean("check_pressure_convergence",&(E->control.check_pressure_convergence),"on",m);
Instructions.c:669:    E->control.check_continuity_convergence = 0;
Instructions.c:670:    E->control.check_pressure_convergence = 0;
Instructions.c:673:  input_int("vhighstep",&(E->control.v_steps_high),"1,0,nomax",m);
Instructions.c:674:  input_int("vlowstep",&(E->control.v_steps_low),"250,0,nomax",m);
Instructions.c:675:  input_int("max_mg_cycles",&(E->control.max_mg_cycles),"50,0,nomax",m);
Instructions.c:676:  input_int("piterations",&(E->control.p_iterations),"100,0,nomax",m);
Instructions.c:678:  input_float("rayleigh",&(E->control.Atemp),"essential",m);
Instructions.c:680:  input_float("dissipation_number",&(E->control.disptn_number),"0.0",m);
Instructions.c:684:      E->control.inv_gruneisen = 1/tmp;
Instructions.c:686:      E->control.inv_gruneisen = 0;
Instructions.c:688:  if(E->control.inv_gruneisen != 0) {
Instructions.c:690:      input_string("uzawa",E->control.uzawa,"cg",m);
Instructions.c:691:      if(strcmp(E->control.uzawa, "cg") == 0) {
Instructions.c:693:          input_int("compress_iter_maxstep",&(E->control.compress_iter_maxstep),"100",m);
Instructions.c:695:      else if(strcmp(E->control.uzawa, "bicg") == 0) {
Instructions.c:701:  input_float("surfaceT",&(E->control.surface_temp),"0.1",m);
Instructions.c:702:  /*input_float("adiabaticT0",&(E->control.adiabaticT0),"0.4",m);*/
Instructions.c:703:  input_float("Q0",&(E->control.Q0),"0.0",m);
Instructions.c:707:  input_float("gravacc",&(E->data.grav_acc),"9.81",m);
Instructions.c:708:  input_float("thermexp",&(E->data.therm_exp),"3.0e-5",m);
Instructions.c:709:  input_float("cp",&(E->data.Cp),"1200.0",m);
Instructions.c:710:  input_float("thermdiff",&(E->data.therm_diff),"1.0e-6",m);
Instructions.c:711:  input_float("density",&(E->data.density),"3340.0",m);
Instructions.c:712:  input_float("density_above",&(E->data.density_above),"1030.0",m);
Instructions.c:713:  input_float("density_below",&(E->data.density_below),"6600.0",m);
Instructions.c:714:  input_float("refvisc",&(E->data.ref_viscosity),"1.0e21",m);
Instructions.c:727:  E->data.ellipticity = ell_tmp;
Instructions.c:728:  if(fabs(E->data.ellipticity) > 5e-7){
Instructions.c:731:    E->data.ra = pow((1.-E->data.ellipticity),-1./3.); /* non dim long axis */
Instructions.c:732:    E->data.rc = 1./(E->data.ra * E->data.ra); /* non dim short axis */
Instructions.c:733:    E->data.efac = (1.-E->data.ellipticity)*(1.-E->data.ellipticity);
Instructions.c:734:    if(E->parallel.me == 0){
Instructions.c:736:	      E->data.ellipticity,E->data.ra,E->data.rc);
Instructions.c:738:    E->data.use_ellipse = 1;
Instructions.c:740:    E->data.ra = E->data.rc = E->data.efac=1.0;
Instructions.c:741:    E->data.use_ellipse = 0;
Instructions.c:747:  input_double("rotation_m",&E->data.rotm,"0.0",m);
Instructions.c:748:  if(fabs(E->data.rotm) > 5e-7){
Instructions.c:750:    E->data.j2 = 2./3.*E->data.ellipticity*(1.-E->data.ellipticity/2.)-
Instructions.c:751:      E->data.rotm/3.*(1.-3./2.*E->data.rotm-2./7.*E->data.ellipticity);
Instructions.c:753:    E->data.ge = 1/(E->data.ra*E->data.ra)*(1+3./2.*E->data.j2-E->data.rotm);
Instructions.c:754:    if(E->parallel.me==0)
Instructions.c:756:	      E->data.rotm,E->data.j2,E->data.ge);
Instructions.c:757:    E->data.use_rotation_g = 1;
Instructions.c:759:    E->data.use_rotation_g = 0;
Instructions.c:767:  E->data.radius_km = tmp / 1e3;
Instructions.c:769:  E->data.therm_cond = E->data.therm_diff * E->data.density * E->data.Cp;
Instructions.c:771:  input_float("reftemperature",&(E->data.ref_temperature),"2700.0",m);
Instructions.c:773:  if (E->control.stokes!=1) {
Instructions.c:774:     E->data.ref_viscosity = E->data.ref_temperature *
Instructions.c:775:         E->data.density * E->data.grav_acc * E->data.therm_exp *
Instructions.c:776:      E->data.radius_km * E->data.radius_km * E->data.radius_km * 1e9
Instructions.c:777:     /(E->control.Atemp * E->data.therm_diff);
Instructions.c:791:  (E->problem_settings)(E);
Instructions.c:801:    if (E->control.CONJ_GRAD) {
Instructions.c:803:        if(E->mesh.levels != 1)
Instructions.c:808:        if(E->mesh.levels < 2)
Instructions.c:810:        if(E->mesh.levels > MAX_LEVELS)
Instructions.c:816:    if(E->sphere.caps == 12 &&
Instructions.c:817:       (E->control.remove_angular_momentum || E->control.remove_rigid_rotation) &&
Instructions.c:818:       (E->mesh.topvbc || E->mesh.botvbc || E->control.side_sbcs)) {
Instructions.c:819:      if(E->parallel.me == 0)
Instructions.c:824:    if((fabs(E->viscosity.zbase_layer[0]+999) < 1e-5) &&
Instructions.c:825:       (fabs(E->viscosity.zbase_layer[1]+999) < 1e-5)) {
Instructions.c:827:        if(E->viscosity.num_mat != 4)
Instructions.c:830:        E->viscosity.zbase_layer[0] = E->viscosity.zlith;
Instructions.c:831:        E->viscosity.zbase_layer[1] = E->viscosity.z410;
Instructions.c:832:        E->viscosity.zbase_layer[2] = E->viscosity.zlm;
Instructions.c:833:        E->viscosity.zbase_layer[3] = E->viscosity.zcmb; /* the lowest layers is never checked, really 
Instructions.c:839:    if (strcmp(E->output.vtk_format, "binary") == 0) {
Instructions.c:842:        if(E->parallel.me == 0) {
Instructions.c:858:   E->mesh.levmax = E->mesh.levels-1;
Instructions.c:859:   E->mesh.gridmax = E->mesh.levmax;
Instructions.c:861:   E->mesh.elx = E->mesh.nox-1;
Instructions.c:862:   E->mesh.ely = E->mesh.noy-1;
Instructions.c:863:   E->mesh.elz = E->mesh.noz-1;
Instructions.c:865:   if(E->sphere.caps == 1) {
Instructions.c:867:       E->mesh.nno = E->sphere.caps * E->mesh.nox * E->mesh.noy * E->mesh.noz;
Instructions.c:873:       E->mesh.nno = E->sphere.caps * (E->mesh.nox-1) * (E->mesh.noy-1) * E->mesh.noz
Instructions.c:874:           + 2*E->mesh.noz;
Instructions.c:877:   E->mesh.nel = E->sphere.caps*E->mesh.elx*E->mesh.elz*E->mesh.ely;
Instructions.c:879:   E->mesh.nnov = E->mesh.nno;
Instructions.c:883:   E->mesh.neq = E->mesh.nnov*E->mesh.nsd;
Instructions.c:885:   E->mesh.npno = E->mesh.nel;
Instructions.c:886:   E->mesh.nsf = E->mesh.nox*E->mesh.noy;
Instructions.c:888:   for(i=E->mesh.levmax;i>=E->mesh.levmin;i--) {
Instructions.c:889:      nox = E->mesh.mgunitx * (int) pow(2.0,(double)i)*E->parallel.nprocx + 1;
Instructions.c:890:      noy = E->mesh.mgunity * (int) pow(2.0,(double)i)*E->parallel.nprocy + 1;
Instructions.c:891:      noz = E->mesh.mgunitz * (int) pow(2.0,(double)i)*E->parallel.nprocz + 1;
Instructions.c:893:      E->mesh.ELX[i] = nox-1;
Instructions.c:894:      E->mesh.ELY[i] = noy-1;
Instructions.c:895:      E->mesh.ELZ[i] = noz-1;
Instructions.c:896:      if(E->sphere.caps == 1) {
Instructions.c:897:          E->mesh.NNO[i] = nox * noz * noy;
Instructions.c:900:          E->mesh.NNO[i] = E->sphere.caps * (nox-1) * (noy-1) * noz + 2 * noz;
Instructions.c:902:      E->mesh.NEL[i] = E->sphere.caps * (nox-1) * (noz-1) * (noy-1);
Instructions.c:903:      E->mesh.NPNO[i] = E->mesh.NEL[i] ;
Instructions.c:904:      E->mesh.NOX[i] = nox;
Instructions.c:905:      E->mesh.NOZ[i] = noz;
Instructions.c:906:      E->mesh.NOY[i] = noy;
Instructions.c:908:      E->mesh.NNOV[i] = E->mesh.NNO[i];
Instructions.c:909:      E->mesh.NEQ[i] = E->mesh.nsd * E->mesh.NNOV[i] ;
Instructions.c:917:    E->data.scalet = (E->data.radius_km*1e3*E->data.radius_km*1e3/E->data.therm_diff)/(1.e6*365.25*24*3600);
Instructions.c:919:    E->data.scalev = (E->data.radius_km*1e3/E->data.therm_diff)/(100*365.25*24*3600);
Instructions.c:920:    E->data.timedir = E->control.Atemp / fabs(E->control.Atemp);
Instructions.c:923:    if(E->control.print_convergence && E->parallel.me==0) {
Instructions.c:925:                E->mesh.nox, E->mesh.noz, E->mesh.noy, E->mesh.nno, E->mesh.nel);
Instructions.c:926:	fprintf(E->fp,"Problem has %i x %i x %i nodes per cap, %i nodes and %i elements in total\n",
Instructions.c:927:                E->mesh.nox, E->mesh.noz, E->mesh.noy, E->mesh.nno, E->mesh.nel);
Instructions.c:945:  npno = E->lmesh.npno;
Instructions.c:946:  nel  = E->lmesh.nel;
Instructions.c:947:  nno  = E->lmesh.nno;
Instructions.c:948:  nsf  = E->lmesh.nsf;
Instructions.c:949:  noz  = E->lmesh.noz;
Instructions.c:950:  nox  = E->lmesh.nox;
Instructions.c:951:  noy  = E->lmesh.noy;
Instructions.c:952:  elx  = E->lmesh.elx;
Instructions.c:953:  ely  = E->lmesh.ely;
Instructions.c:955:  E->P        = (double *) malloc((npno+1)*sizeof(double));
Instructions.c:956:  E->T        = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:957:  E->NP       = (float *) malloc((nno+1)*sizeof(float));
Instructions.c:958:  E->buoyancy = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:960:  E->gstress = (float *) malloc((6*nno+1)*sizeof(float));
Instructions.c:962:  //E->stress[j]   = (float *) malloc((12*nsf+1)*sizeof(float));
Instructions.c:964:  for(i=1;i<=E->mesh.nsd;i++)
Instructions.c:965:      E->sphere.cap.TB[i] = (float *)  malloc((nno+1)*sizeof(float));
Instructions.c:967:  E->slice.tpg      = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:968:  E->slice.tpgb     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:969:  E->slice.divg     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:970:  E->slice.vort     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:971:  E->slice.shflux    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:972:  E->slice.bhflux    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:973:  /*  if(E->mesh.topvbc==2 && E->control.pseudo_free_surf) */
Instructions.c:974:  E->slice.freesurf    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:976:  E->mat = (int *) malloc((nel+2)*sizeof(int));
Instructions.c:977:  E->VIP = (float *) malloc((nel+2)*sizeof(float));
Instructions.c:979:  E->heating_adi    = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:980:  E->heating_visc   = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:981:  E->heating_latent = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:984:  E->TMass = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:987:  E->NMass = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:992:  E->sien         = (struct SIEN *) malloc((nxyz+2)*sizeof(struct SIEN));
Instructions.c:993:  E->surf_element = (int *) malloc((nxyz+2)*sizeof(int));
Instructions.c:994:  E->surf_node    = (int *) malloc((nsf+2)*sizeof(int));
Instructions.c:998:  E->rho      = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:1001:  E->Have.T         = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:1002:  E->Have.V[1]      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:1003:  E->Have.V[2]      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:1005:  E->sphere.gr = (double *)malloc((E->mesh.noz+1)*sizeof(double));
Instructions.c:1007: for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) {
Instructions.c:1008:  E->sphere.R[i] = (double *)  malloc((E->lmesh.NOZ[i]+1)*sizeof(double));
Instructions.c:1009:    nno  = E->lmesh.NNO[i];
Instructions.c:1010:    npno = E->lmesh.NPNO[i];
Instructions.c:1011:    nel  = E->lmesh.NEL[i];
Instructions.c:1012:    nox = E->lmesh.NOX[i];
Instructions.c:1013:    noz = E->lmesh.NOZ[i];
Instructions.c:1014:    noy = E->lmesh.NOY[i];
Instructions.c:1015:    elx = E->lmesh.ELX[i];
Instructions.c:1016:    ely = E->lmesh.ELY[i];
Instructions.c:1017:    snel=E->lmesh.SNEL[i];
Instructions.c:1019:    for(d=1;d<=E->mesh.nsd;d++)   {
Instructions.c:1020:      E->X[i][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:1021:      E->SX[i][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:1025:      E->SinCos[i][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:1027:    E->IEN[i] = (struct IEN *)   malloc((nel+2)*sizeof(struct IEN));
Instructions.c:1028:    E->EL[i]  = (struct SUBEL *) malloc((nel+2)*sizeof(struct SUBEL));
Instructions.c:1029:    E->sphere.area1[i] = (double *) malloc((snel+1)*sizeof(double));
Instructions.c:1031:      E->sphere.angle1[i][k] = (double *) malloc((snel+1)*sizeof(double));
Instructions.c:1033:    E->GNX[i]=(struct Shape_function_dx *)malloc((nel+1)*sizeof(struct Shape_function_dx));
Instructions.c:1034:    E->GDA[i] = (struct Shape_function_dA *)malloc((nel+1)*sizeof(struct Shape_function_dA));
Instructions.c:1036:    E->MASS[i]     = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:1037:    E->ECO[i] = (struct COORD *) malloc((nno+2)*sizeof(struct COORD));
Instructions.c:1039:    E->TWW[i] = (struct FNODE *)   malloc((nel+2)*sizeof(struct FNODE));
Instructions.c:1041:    for(d=1;d<=E->mesh.nsd;d++)
Instructions.c:1042:      for(l=1;l<=E->lmesh.NNO[i];l++)  {
Instructions.c:1043:        E->SX[i][d][l] = 0.0;
Instructions.c:1044:        E->X[i][d][l] = 0.0;
Instructions.c:1049: for(i=0;i<=E->output.llmax;i++)
Instructions.c:1050:  E->sphere.hindex[i] = (int *) malloc((E->output.llmax+3)
Instructions.c:1054: for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Instructions.c:1056:    nno  = E->lmesh.NNO[i];
Instructions.c:1057:    npno = E->lmesh.NPNO[i];
Instructions.c:1058:    nel  = E->lmesh.NEL[i];
Instructions.c:1059:    nox = E->lmesh.NOX[i];
Instructions.c:1060:    noz = E->lmesh.NOZ[i];
Instructions.c:1061:    noy = E->lmesh.NOY[i];
Instructions.c:1062:    elx = E->lmesh.ELX[i];
Instructions.c:1063:    ely = E->lmesh.ELY[i];
Instructions.c:1066:    E->CC[i] =(struct CC *)  malloc((1)*sizeof(struct CC));
Instructions.c:1067:    E->CCX[i]=(struct CCX *)  malloc((1)*sizeof(struct CCX));
Instructions.c:1069:    E->elt_del[i] = (struct EG *) malloc((nel+1)*sizeof(struct EG));
Instructions.c:1071:    if(E->control.inv_gruneisen != 0)
Instructions.c:1072:        E->elt_c[i] = (struct EC *) malloc((nel+1)*sizeof(struct EC));
Instructions.c:1074:    E->EVI[i] = (float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1075:    E->BPI[i] = (double *) malloc((npno+1)*sizeof(double));
Instructions.c:1077:    E->ID[i]  = (struct ID *)    malloc((nno+1)*sizeof(struct ID));
Instructions.c:1078:    E->VI[i]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1079:    E->NODE[i] = (unsigned int *)malloc((nno+1)*sizeof(unsigned int));
Instructions.c:1085:    E->parallel.EXCHANGE_sNODE[i] = (struct PASS *) malloc((nozl+2)*sizeof(struct PASS));
Instructions.c:1086:    E->parallel.NODE[i]   = (struct BOUND *) malloc((nxyz+2)*sizeof(struct BOUND));
Instructions.c:1087:    E->parallel.EXCHANGE_NODE[i]=(struct PASS *) malloc((nxyz+2)*sizeof(struct PASS));
Instructions.c:1088:    E->parallel.EXCHANGE_ID[i] = (struct PASS *) malloc((nxyz*E->mesh.nsd+3)*sizeof(struct PASS));
Instructions.c:1090:    for(l=1;l<=E->lmesh.NNO[i];l++)  {
Instructions.c:1091:      E->NODE[i][l] = (INTX | INTY | INTZ);  /* and any others ... */
Instructions.c:1092:      E->VI[i][l] = 1.0;
Instructions.c:1096: if(E->viscosity.allow_anisotropic_viscosity){ /* any anisotropic
Instructions.c:1098:   for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Instructions.c:1099:       nel  = E->lmesh.NEL[i];
Instructions.c:1100:       nno  = E->lmesh.NNO[i];
Instructions.c:1101:       E->EVI2[i]=(float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1102:       E->avmode[i]=(unsigned char *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(unsigned char));
Instructions.c:1103:       E->EVIn1[i]=(float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1104:       E->EVIn2[i]=(float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1105:       E->EVIn3[i]=(float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:1107:       E->VI2[i]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1108:       E->VIn1[i]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1109:       E->VIn2[i]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1110:       E->VIn3[i]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:1111:       if((!(E->EVI2[i]))||(!(E->VI2[i]))||
Instructions.c:1112:	  (!(E->EVIn1[i]))||(!(E->EVIn2[i]))||(!(E->EVIn3[i]))||
Instructions.c:1113:	  (!(E->VIn1[i]))||(!(E->VIn2[i]))||(!(E->VIn3[i]))){
Instructions.c:1115:		 E->parallel.me);
Instructions.c:1118:   E->viscosity.anisotropic_viscosity_init = FALSE;
Instructions.c:1122:  for(k=1;k<=E->mesh.nsd;k++)
Instructions.c:1123:    for(i=1;i<=E->lmesh.nno;i++)
Instructions.c:1124:      E->sphere.cap.TB[k][i] = 0.0;
Instructions.c:1126:  for(i=1;i<=E->lmesh.nno;i++)
Instructions.c:1127:     E->T[i] = 0.0;
Instructions.c:1129:  for(i=1;i<=E->lmesh.nel;i++)   {
Instructions.c:1130:      E->mat[i]=1;
Instructions.c:1131:      E->VIP[i]=1.0;
Instructions.c:1133:      E->heating_adi[i] = 0;
Instructions.c:1134:      E->heating_visc[i] = 0;
Instructions.c:1135:      E->heating_latent[i] = 1.0;
Instructions.c:1138:  for(i=1;i<=E->lmesh.npno;i++)
Instructions.c:1139:      E->P[i] = 0.0;
Instructions.c:1145:  if (strcmp(E->output.format, "hdf5") == 0)
Instructions.c:1154:    E->monitor.incompressibility = 0;
Instructions.c:1155:    E->monitor.fdotf = 0;
Instructions.c:1156:    E->monitor.vdotv = 0;
Instructions.c:1157:    E->monitor.pdotp = 0;
Instructions.c:1161:    E->lmesh.nnov = E->lmesh.nno;
Instructions.c:1162:    E->lmesh.neq = E->lmesh.nnov * E->mesh.nsd;
Instructions.c:1164:    E->temp = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:1165:    E->temp1 = (double *) malloc(E->lmesh.neq*sizeof(double));
Instructions.c:1166:    E->F = (double *) malloc(E->lmesh.neq*sizeof(double));
Instructions.c:1167:    E->U = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:1168:    E->u1 = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:1171:    for(i=1;i<=E->mesh.nsd;i++) {
Instructions.c:1172:      E->sphere.cap.V[i]=(float *)malloc((E->lmesh.nnov+1)*sizeof(float));
Instructions.c:1173:      E->sphere.cap.VB[i]=(float *)malloc((E->lmesh.nnov+1)*sizeof(float));
Instructions.c:1174:      E->sphere.cap.Vprev[i]=(float *) malloc((E->lmesh.nnov+1)*sizeof(float));
Instructions.c:1177:    for(i=0;i<E->lmesh.neq;i++)
Instructions.c:1178:      E->U[i] = E->temp[i] = E->temp1[i] = 0.0;
Instructions.c:1180:    for(k=1;k<=E->mesh.nsd;k++)
Instructions.c:1181:      for(i=1;i<=E->lmesh.nnov;i++)
Instructions.c:1182:        E->sphere.cap.VB[k][i] = 0.0;
Instructions.c:1184:  for(l=E->mesh.gridmin;l<=E->mesh.gridmax;l++) {
Instructions.c:1185:      E->lmesh.NEQ[l] = E->lmesh.NNOV[l] * E->mesh.nsd;
Instructions.c:1187:      E->BI[l] = (double *) malloc((E->lmesh.NEQ[l])*sizeof(double));
Instructions.c:1188:      k = (E->lmesh.NOX[l]*E->lmesh.NOZ[l]+E->lmesh.NOX[l]*E->lmesh.NOY[l]+
Instructions.c:1189:          E->lmesh.NOY[l]*E->lmesh.NOZ[l])*6;
Instructions.c:1190:      E->zero_resid[l] = (int *) malloc((k+2)*sizeof(int));
Instructions.c:1191:      E->parallel.Skip_id[l] = (int *) malloc((k+2)*sizeof(int));
Instructions.c:1193:      for(i=0;i<E->lmesh.NEQ[l];i++) {
Instructions.c:1194:         E->BI[l][i]=0.0;
Instructions.c:1208:  E->control.v_steps_low = 10;
Instructions.c:1209:  E->control.v_steps_upper = 1;
Instructions.c:1210:  E->control.accuracy = 1.0e-4;
Instructions.c:1211:  E->control.verbose=0; /* debugging/profiles */
Instructions.c:1215:    E->control.stokes=0;
Instructions.c:1216:    E->control.restart=0;
Instructions.c:1217:    E->control.CONVECTION = 0;
Instructions.c:1218:    E->control.CART2D = 0;
Instructions.c:1219:    E->control.CART3D = 0;
Instructions.c:1220:    E->control.CART2pt5D = 0;
Instructions.c:1221:    E->control.AXI = 0;
Instructions.c:1222:    E->control.CONJ_GRAD = 0;
Instructions.c:1223:    E->control.NMULTIGRID = 0;
Instructions.c:1224:    E->control.augmented_Lagr = 0;
Instructions.c:1225:    E->control.augmented = 0.0;
Instructions.c:1227:    E->trace.fpt = NULL;
Instructions.c:1228:    E->control.tracer = 0;
Instructions.c:1229:    E->composition.on = 0;
Instructions.c:1231:  E->parallel.nprocx=1; E->parallel.nprocz=1; E->parallel.nprocy=1;
Instructions.c:1233:  E->mesh.levmax=0;
Instructions.c:1234:  E->mesh.levmin=0;
Instructions.c:1235:  E->mesh.gridmax=0;
Instructions.c:1236:  E->mesh.gridmin=0;
Instructions.c:1237:  E->mesh.noz = 1;    E->mesh.nzs = 1;  E->lmesh.noz = 1;    E->lmesh.nzs = 1;
Instructions.c:1238:  E->mesh.noy = 1;    E->mesh.nys = 1;  E->lmesh.noy = 1;    E->lmesh.nys = 1;
Instructions.c:1239:  E->mesh.nox = 1;    E->mesh.nxs = 1;  E->lmesh.nox = 1;    E->lmesh.nxs = 1;
Instructions.c:1241:  E->sphere.ro = 1.0;
Instructions.c:1242:  E->sphere.ri = 0.5;
Instructions.c:1244:  E->control.precondition = 0;  /* for larger visc contrasts turn this back on  */
Instructions.c:1246:  E->mesh.toptbc = 1; /* fixed t */
Instructions.c:1247:  E->mesh.bottbc = 1;
Instructions.c:1248:  E->mesh.topvbc = 0; /* stress */
Instructions.c:1249:  E->mesh.botvbc = 0;
Instructions.c:1250:  E->control.VBXtopval=0.0;
Instructions.c:1251:  E->control.VBYtopval=0.0;
Instructions.c:1252:  E->control.VBXbotval=0.0;
Instructions.c:1253:  E->control.VBYbotval=0.0;
Instructions.c:1255:  E->data.radius_km = 6370.0; /* Earth, whole mantle defaults */
Instructions.c:1256:  E->data.grav_acc = 9.81;
Instructions.c:1257:  E->data.therm_diff = 1.0e-6;
Instructions.c:1258:  E->data.therm_exp = 3.e-5;
Instructions.c:1259:  E->data.density = 3300.0;
Instructions.c:1260:  E->data.ref_viscosity=1.e21;
Instructions.c:1261:  E->data.density_above = 1000.0;    /* sea water */
Instructions.c:1262:  E->data.density_below = 6600.0;    /* sea water */
Instructions.c:1264:  E->data.Cp = 1200.0;
Instructions.c:1265:  E->data.therm_cond = 3.168;
Instructions.c:1266:  E->data.res_density = 3300.0;  /* density when X = ... */
Instructions.c:1267:  E->data.res_density_X = 0.3;
Instructions.c:1268:  E->data.melt_density = 2800.0;
Instructions.c:1269:  E->data.permeability = 3.0e-10;
Instructions.c:1270:  E->data.gas_const = 8.3;
Instructions.c:1271:  E->data.surf_heat_flux = 4.4e-2;
Instructions.c:1273:  E->data.grav_const = 6.6742e-11;
Instructions.c:1275:  E->data.youngs_mod = 1.0e11;
Instructions.c:1276:  E->data.Te = 0.0;
Instructions.c:1277:  E->data.T_sol0 = 1373.0;      /* Dave's values 1991 (for the earth) */
Instructions.c:1278:  E->data.Tsurf = 273.0;
Instructions.c:1279:  E->data.dTsol_dz = 3.4e-3 ;
Instructions.c:1280:  E->data.dTsol_dF = 440.0;
Instructions.c:1281:  E->data.dT_dz = 0.48e-3;
Instructions.c:1282:  E->data.delta_S = 250.0;
Instructions.c:1283:  E->data.ref_temperature = 2 * 1350.0; /* fixed temperature ... delta T */
Instructions.c:1287:    sprintf(E->control.data_prefix,"citcom.tmp.%d",getpid());
Instructions.c:1289:    E->control.NASSEMBLE = 0;
Instructions.c:1291:    E->monitor.elapsed_time=0.0;
Instructions.c:1293:    E->control.record_all_until = 10000000;
Instructions.c:1302:    for(i=1;i<=E->lmesh.nno;i++)    {
Instructions.c:1303:      if ((E->node[i] & VBX) && (E->node[i] & SBX))
Instructions.c:1305:      if ((E->node[i] & VBZ) && (E->node[i] & SBZ))
Instructions.c:1307:      if ((E->node[i] & VBY) && (E->node[i] & SBY))
Instructions.c:1309:      if ((E->node[i] & TBX) && (E->node[i] & FBX))
Instructions.c:1311:      if ((E->node[i] & TBZ) && (E->node[i] & FBZ))
Instructions.c:1313:      if ((E->node[i] & TBY) && (E->node[i] & FBY))
Instructions.c:1317:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Instructions.c:1318:    for(i=1;i<=E->lmesh.NNO[lev];i++) {
Instructions.c:1319:      if ((E->NODE[lev][i] & VBX) && (E->NODE[lev][i]  & SBX))
Instructions.c:1321:      if ((E->NODE[lev][i] & VBZ) && (E->NODE[lev][i]  & SBZ))
Instructions.c:1323:      if ((E->NODE[lev][i] & VBY) && (E->NODE[lev][i]  & SBY))
Instructions.c:1337:  E->eco[j] = E->ECO[E->mesh.levmax][j];
Instructions.c:1338:  E->ien[j] = E->IEN[E->mesh.levmax][j];
Instructions.c:1339:  E->id[j] = E->ID[E->mesh.levmax][j];
Instructions.c:1340:  E->Vi[j] = E->VI[E->mesh.levmax][j];
Instructions.c:1341:  E->EVi[j] = E->EVI[E->mesh.levmax][j];
Instructions.c:1342:  E->node[j] = E->NODE[E->mesh.levmax][j];
Instructions.c:1343:  E->cc[j] = E->CC[E->mesh.levmax][j];
Instructions.c:1344:  E->ccx[j] = E->CCX[E->mesh.levmax][j];
Instructions.c:1345:  E->Mass[j] = E->MASS[E->mesh.levmax][j];
Instructions.c:1346:  E->gDA[j] = E->GDA[E->mesh.levmax][j];
Instructions.c:1347:  E->gNX[j] = E->GNX[E->mesh.levmax][j];
Instructions.c:1349:  for (i=1;i<=E->mesh.nsd;i++)    {
Instructions.c:1350:    E->x[j][i] = E->X[E->mesh.levmax][j][i];
Instructions.c:1351:    E->sx[j][i] = E->SX[E->mesh.levmax][j][i];
Instructions.c:1359:{ if(E->control.verbose && E->parallel.me==0)
Instructions.c:1369:{ if(E->control.verbose && E->fp)
Instructions.c:1370:    { fprintf(E->fp,"%s\n",string);
Instructions.c:1371:      fflush(E->fp);
Instructions.c:1405:  for(i=1;i<=E->lmesh.npno;i++)
Instructions.c:1406:    E->P[i]=0.0;
Instructions.c:1414:  for(i=1;i<=E->lmesh.nnov;i++)   {
Instructions.c:1415:    E->sphere.cap.V[1][i]=0.0;
Instructions.c:1416:    E->sphere.cap.V[2][i]=0.0;
Instructions.c:1417:    E->sphere.cap.V[3][i]=0.0;
Instructions.c:1427:  E->fp = NULL;
Instructions.c:1428:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1429:    sprintf(logfile,"%s/log", E->control.data_dir);
Instructions.c:1431:    sprintf(logfile,"%s.log", E->control.data_file);
Instructions.c:1433:  if (E->control.restart || E->control.post_p)
Instructions.c:1435:      E->fp = output_open(logfile, "a");
Instructions.c:1437:      E->fp = output_open(logfile, "w");
Instructions.c:1447:  E->fptime = NULL;
Instructions.c:1448:  if (E->parallel.me == 0) {
Instructions.c:1449:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1450:    sprintf(timeoutput,"%s/time", E->control.data_dir);
Instructions.c:1452:    sprintf(timeoutput,"%s.time", E->control.data_file);
Instructions.c:1454:  if (E->control.restart || E->control.post_p)
Instructions.c:1456:      E->fptime = output_open(timeoutput, "a");
Instructions.c:1458:      E->fptime = output_open(timeoutput, "w");
Instructions.c:1469:  E->fp_out = NULL;
Instructions.c:1470:  if (E->control.verbose) {
Instructions.c:1471:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1472:    sprintf(output_file,"%s/info.%d", E->control.data_dir, E->parallel.me);
Instructions.c:1474:    sprintf(output_file,"%s.info.%d", E->control.data_file, E->parallel.me);
Instructions.c:1475:  E->fp_out = output_open(output_file, "w");
Instructions.c:1487:  if((E->parallel.me_loc[3] == E->parallel.nprocz-1) &&
Instructions.c:1488:     (E->parallel.me==E->parallel.nprocz-1)){
Instructions.c:1490:    if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1491:      sprintf(output_file,"%s/qt.dat", E->control.data_dir);
Instructions.c:1493:      sprintf(output_file,"%s.qt.dat", E->control.data_file);
Instructions.c:1494:    if(E->control.restart)
Instructions.c:1495:      E->output.fpqt = output_open(output_file, "a"); /* append for restart */
Instructions.c:1497:      E->output.fpqt = output_open(output_file, "w");
Instructions.c:1499:    E->output.fpqt = NULL;
Instructions.c:1501:  if (E->parallel.me_loc[3] == 0)    {
Instructions.c:1503:    if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1504:      sprintf(output_file,"%s/qb.dat", E->control.data_dir);
Instructions.c:1506:      sprintf(output_file,"%s.qb.dat", E->control.data_file);
Instructions.c:1507:    if(E->control.restart)
Instructions.c:1508:      E->output.fpqb = output_open(output_file, "a"); /* append */
Instructions.c:1510:      E->output.fpqb = output_open(output_file, "w");
Instructions.c:1512:    E->output.fpqb = NULL;
Instructions.c:1527:    len = strlen(E->output.optional);
Instructions.c:1530:    next = E->output.optional;
Instructions.c:1532:    E->output.connectivity = 0;
Instructions.c:1533:    E->output.stress = 0;
Instructions.c:1534:    E->output.pressure = 0;
Instructions.c:1535:    E->output.surf = 0;
Instructions.c:1536:    E->output.botm = 0;
Instructions.c:1537:    E->output.geoid = 0;
Instructions.c:1538:    E->output.horiz_avg = 0;
Instructions.c:1539:    E->output.seismic = 0;
Instructions.c:1540:    E->output.coord_bin = 0;
Instructions.c:1541:    E->output.tracer = 0;
Instructions.c:1542:    E->output.comp_el = 0;
Instructions.c:1543:    E->output.comp_nd = 0;
Instructions.c:1544:    E->output.heating = 0;
Instructions.c:1564:            E->output.connectivity = 1;
Instructions.c:1566:            E->output.stress = 1;
Instructions.c:1568:            E->output.pressure = 1;
Instructions.c:1570:            E->output.surf = 1;
Instructions.c:1572:            E->output.botm = 1;
Instructions.c:1574:	    if (E->parallel.nprocxy != 12) {
Instructions.c:1580:		E->output.geoid  = 1;
Instructions.c:1583:            E->output.horiz_avg = 1;
Instructions.c:1585:            E->output.seismic = E->output.coord_bin = 1;
Instructions.c:1589:            if(E->parallel.me==0) {
Instructions.c:1590:                fprintf(stderr, "Total temperature contrast = %f K\n", E->data.ref_temperature);
Instructions.c:1591:                fprintf(E->fp, "Total temperature contrast = %f K\n", E->data.ref_temperature);
Instructions.c:1595:            E->output.tracer = 1;
Instructions.c:1597:            E->output.comp_el = 1;
Instructions.c:1599:            E->output.comp_nd = 1;
Instructions.c:1601:            E->output.heating = 1;
Instructions.c:1603:            if(E->parallel.me == 0)
Instructions.c:1611:/* check whether E->control.data_file contains a path seperator */
Instructions.c:1616:  found = strchr(E->control.data_prefix, '/');
Instructions.c:1618:      fprintf(stderr, "error in input parameter: datafile='%s' contains '/'\n", E->control.data_file);
Instructions.c:1622:  if (E->control.restart || E->control.post_p ||
Instructions.c:1623:      (E->convection.tic_method == -1) ||
Instructions.c:1624:      (E->control.tracer && (E->trace.ic_method == 2))) {
Instructions.c:1625:      found = strchr(E->control.data_prefix_old, '/');
Instructions.c:1627:	  fprintf(stderr, "error in input parameter: datafile_old='%s' contains '/'\n", E->control.data_file);
Instructions.c:1685:	sprintf(tmp, "%d", E->parallel.me);
Instructions.c:1721:    expand_datadir(E, E->control.data_dir);
Instructions.c:1722:    mkdatadir(E->control.data_dir);
Instructions.c:1723:    snprintf(E->control.data_file, 200, "%s/%s", E->control.data_dir,
Instructions.c:1724:	     E->control.data_prefix);
Instructions.c:1726:    if (E->control.restart || E->control.post_p ||
Instructions.c:1727:        (E->convection.tic_method == -1) ||
Instructions.c:1728:        (E->control.tracer && (E->trace.ic_method == 2))) {
Instructions.c:1729:	expand_datadir(E, E->control.data_dir_old);
Instructions.c:1730:	snprintf(E->control.old_P_file, 200, "%s/%s", E->control.data_dir_old,
Instructions.c:1731:		 E->control.data_prefix_old);
Instructions.c:1738:    if (strcmp(E->output.format, "ascii") == 0) {
Instructions.c:1739:        E->problem_output = output;
Instructions.c:1741:    else if (strcmp(E->output.format, "hdf5") == 0)
Instructions.c:1742:        E->problem_output = h5output;
Instructions.c:1743:    else if (strcmp(E->output.format, "vtk") == 0)
Instructions.c:1744:        E->problem_output = vtk_output;
Instructions.c:1746:    else if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:1747:        E->problem_output = gzdir_output;
Instructions.c:1750:        if (E->parallel.me == 0) {
Instructions.c:1752:            fprintf(E->fp, "wrong output_format, must be  'ascii', 'hdf5' 'ascii-gz', or 'vtk'\n");
Instructions.c:1759:        if (E->parallel.me == 0) {
Instructions.c:1761:            fprintf(E->fp, "wrong output_format, must be 'ascii', 'hdf5', or 'vtk' (USE_GZDIR undefined)\n");
Instructions.c:1775:  if (E->fp)
Instructions.c:1776:    fclose(E->fp);
Instructions.c:1777:  if (E->fptime)
Instructions.c:1778:    fclose(E->fptime);
Instructions.c:1779:  if (E->fp_out)
Instructions.c:1780:    fclose(E->fp_out);
Instructions.c:1781:  if (E->trace.fpt)
Instructions.c:1782:    fclose(E->trace.fpt);
Instructions.c:1783:  if(E->output.fpqt)
Instructions.c:1784:    fclose(E->output.fpqt);
Instructions.c:1785:  if(E->output.fpqb)
Instructions.c:1786:    fclose(E->output.fpqb);
Instructions.c:1792:  if((E->output.gzdir.vtk_io != 0) &&
Instructions.c:1793:     (strcmp(E->output.format, "ascii-gz") == 0)){
Instructions.c:1794:    if((E->output.gzdir.vtk_io == 3)||(E->parallel.me == 0)){
Instructions.c:1798:      if(E->parallel.me == 0){
Instructions.c:1800:	if(E->output.gzdir.vtk_fp)
Instructions.c:1801:	  fclose(E->output.gzdir.vtk_fp);
Lith_age.c:44:  int m = E->parallel.me;
Lith_age.c:46:  E->control.lith_age = 0;
Lith_age.c:47:  E->control.lith_age_time = 0;
Lith_age.c:48:  E->control.temperature_bound_adj = 0;
Lith_age.c:50:  input_int("lith_age",&(E->control.lith_age),"0",m);
Lith_age.c:52:  input_int("ggrd_age_control",&(E->control.ggrd.age_control),"0",m); /* if > 0, will use top  E->control.ggrd.mat_control layers and assign a prefactor for the viscosity */
Lith_age.c:53:  if(E->control.ggrd.age_control){
Lith_age.c:54:    E->control.lith_age = 1;	
Lith_age.c:58:  if (E->control.lith_age) {
Lith_age.c:59:    input_int("lith_age_time",&(E->control.lith_age_time),"0",m);
Lith_age.c:60:    input_string("lith_age_file",E->control.lith_age_file,"",m);
Lith_age.c:61:    input_float("lith_age_depth",&(E->control.lith_age_depth),"0.0471",m);
Lith_age.c:63:    input_int("temperature_bound_adj",&(E->control.temperature_bound_adj),"0",m);
Lith_age.c:64:    if (E->control.temperature_bound_adj) {
Lith_age.c:65:      input_float("depth_bound_adj",&(E->control.depth_bound_adj),"0.1570",m);
Lith_age.c:66:      input_float("width_bound_adj",&(E->control.width_bound_adj),"0.08727",m);
Lith_age.c:80:  gnox=E->mesh.nox;
Lith_age.c:81:  gnoy=E->mesh.noy;
Lith_age.c:83:  if (E->parallel.me == 0 ) fprintf(stderr,"INSIDE lith_age_init\n");
Lith_age.c:84:  E->age_t=(float*) malloc((gnox*gnoy+1)*sizeof(float));
Lith_age.c:86:  if(E->control.lith_age_time==1)   {
Lith_age.c:88:    E->control.lith_age_old_cycles = E->monitor.solution_cycles;
Lith_age.c:90:    (E->solver.lith_age_read_files)(E,output);
Lith_age.c:95:    sprintf(output_file,"%s",E->control.lith_age_file);
Lith_age.c:98:      fprintf(E->fp,"(Boundary_conditions #1) Can't open %s\n",output_file);
Lith_age.c:104:	if(fscanf(fp1,"%f",&(E->age_t[node])) != 1) {
Lith_age.c:108:	E->age_t[node]=E->age_t[node]*E->data.scalet;
Lith_age.c:111:  } /* end E->control.lith_age_time == false */
Lith_age.c:123:  noy=E->lmesh.noy;
Lith_age.c:124:  nox=E->lmesh.nox;
Lith_age.c:125:  noz=E->lmesh.noz;
Lith_age.c:127:  gnox=E->mesh.nox;
Lith_age.c:128:  gnoy=E->mesh.noy;
Lith_age.c:129:  gnoz=E->mesh.noz;
Lith_age.c:134:        nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:136:        r1=E->sx[3][node];
Lith_age.c:137:        E->T[node] = E->control.mantle_temp;
Lith_age.c:138:        if( r1 >= E->sphere.ro-E->control.lith_age_depth )
Lith_age.c:140:            temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:141:            E->T[node] = E->control.mantle_temp * erf(temp);
Lith_age.c:159:  noy = E->lmesh.noy;
Lith_age.c:160:  nox = E->lmesh.nox;
Lith_age.c:161:  noz = E->lmesh.noz;
Lith_age.c:162:  rout = E->sphere.ro;
Lith_age.c:163:  rin = E->sphere.ri;
Lith_age.c:169:        r1=E->sx[3][node];
Lith_age.c:172:          E->sphere.cap.TB[1][node]=E->T[node];
Lith_age.c:173:          E->sphere.cap.TB[2][node]=E->T[node];
Lith_age.c:174:          E->sphere.cap.TB[3][node]=E->T[node];
Lith_age.c:187:  nno=E->lmesh.nno;
Lith_age.c:194:  if (E->control.temperature_bound_adj) {
Lith_age.c:195:    ttt2=E->control.theta_min + E->control.width_bound_adj;
Lith_age.c:196:    ttt3=E->control.theta_max - E->control.width_bound_adj;
Lith_age.c:197:    fff2=E->control.fi_min + E->control.width_bound_adj;
Lith_age.c:198:    fff3=E->control.fi_max - E->control.width_bound_adj;
Lith_age.c:200:    if(lv==E->mesh.gridmax)
Lith_age.c:201:	for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:202:	  if( ((E->sx[1][node]<=ttt2) && (E->sx[3][node]>=E->sphere.ro-E->control.depth_bound_adj)) || ((E->sx[1][node]>=ttt3) && (E->sx[3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:205:	      E->node[node]=E->node[node] | TBX;
Lith_age.c:206:	      E->node[node]=E->node[node] & (~FBX);
Lith_age.c:207:	      E->node[node]=E->node[node] | TBY;
Lith_age.c:208:	      E->node[node]=E->node[node] & (~FBY);
Lith_age.c:209:	      E->node[node]=E->node[node] | TBZ;
Lith_age.c:210:	      E->node[node]=E->node[node] & (~FBZ);
Lith_age.c:213:	  if( ((E->sx[2][node]<=fff2) && (E->sx[3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:216:	      E->node[node]=E->node[node] | TBX;
Lith_age.c:217:	      E->node[node]=E->node[node] & (~FBX);
Lith_age.c:218:	      E->node[node]=E->node[node] | TBY;
Lith_age.c:219:	      E->node[node]=E->node[node] & (~FBY);
Lith_age.c:220:	      E->node[node]=E->node[node] | TBZ;
Lith_age.c:221:	      E->node[node]=E->node[node] & (~FBZ);
Lith_age.c:224:	  if( ((E->sx[2][node]>=fff3) && (E->sx[3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:227:	      E->node[node]=E->node[node] | TBX;
Lith_age.c:228:	      E->node[node]=E->node[node] & (~FBX);
Lith_age.c:229:	      E->node[node]=E->node[node] | TBY;
Lith_age.c:230:	      E->node[node]=E->node[node] & (~FBY);
Lith_age.c:231:	      E->node[node]=E->node[node] | TBZ;
Lith_age.c:232:	      E->node[node]=E->node[node] & (~FBZ);
Lith_age.c:236:  } /* end E->control.temperature_bound_adj */
Lith_age.c:238:  if (E->control.lith_age_time) {
Lith_age.c:239:    if(lv==E->mesh.gridmax)
Lith_age.c:240:      for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:241:        if(E->sx[3][node]>=E->sphere.ro-E->control.lith_age_depth){ 
Lith_age.c:243:          E->node[node]=E->node[node] | TBX;
Lith_age.c:244:          E->node[node]=E->node[node] & (~FBX);
Lith_age.c:245:          E->node[node]=E->node[node] | TBY;
Lith_age.c:246:          E->node[node]=E->node[node] & (~FBY);
Lith_age.c:247:          E->node[node]=E->node[node] | TBZ;
Lith_age.c:248:          E->node[node]=E->node[node] & (~FBZ);
Lith_age.c:252:  } /* end E->control.lith_age_time */
Lith_age.c:270:  gnox=E->mesh.nox;
Lith_age.c:271:  gnoy=E->mesh.noy;
Lith_age.c:272:  gnoz=E->mesh.noz;
Lith_age.c:273:  nox=E->lmesh.nox;
Lith_age.c:274:  noy=E->lmesh.noy;
Lith_age.c:275:  noz=E->lmesh.noz;
Lith_age.c:277:  if(E->control.lith_age_time==1)   {
Lith_age.c:279:    if (E->control.lith_age_old_cycles != E->monitor.solution_cycles) {
Lith_age.c:282:      E->control.lith_age_old_cycles = E->monitor.solution_cycles;
Lith_age.c:284:    if (E->parallel.me == 0) fprintf(stderr,"INSIDE lith_age_conform_tbc\n");
Lith_age.c:285:    (E->solver.lith_age_read_files)(E,output);
Lith_age.c:289:  if(E->monitor.solution_cycles>1 && E->control.temperature_bound_adj) {
Lith_age.c:290:    ttt2=E->control.theta_min + E->control.width_bound_adj;
Lith_age.c:291:    ttt3=E->control.theta_max - E->control.width_bound_adj;
Lith_age.c:292:    fff2=E->control.fi_min + E->control.width_bound_adj;
Lith_age.c:293:    fff3=E->control.fi_max - E->control.width_bound_adj;
Lith_age.c:298:        nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:300:        t1=E->sx[1][node];
Lith_age.c:301:        f1=E->sx[2][node];
Lith_age.c:302:        r1=E->sx[3][node];
Lith_age.c:304:        if(fabs(r1-E->sphere.ro)>=e_4 && fabs(r1-E->sphere.ri)>=e_4)  { /* if NOT right on the boundary */
Lith_age.c:305:          if( ((E->sx[1][node]<=ttt2) && (E->sx[3][node]>=E->sphere.ro-E->control.depth_bound_adj)) || ((E->sx[1][node]>=ttt3) && (E->sx[3][node]>=E->sphere.ro-E->control.depth_bound_adj)) ) {
Lith_age.c:307:            temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:308:            t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:311:            E->sphere.cap.TB[1][node]=t0;
Lith_age.c:312:            E->sphere.cap.TB[2][node]=t0;
Lith_age.c:313:            E->sphere.cap.TB[3][node]=t0;
Lith_age.c:316:          if( ((E->sx[2][node]<=fff2) || (E->sx[2][node]>=fff3)) && (E->sx[3][node]>=E->sphere.ro-E->control.depth_bound_adj) ) {
Lith_age.c:321:            temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:322:            t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:324:            E->sphere.cap.TB[1][node]=t0;
Lith_age.c:325:            E->sphere.cap.TB[2][node]=t0;
Lith_age.c:326:            E->sphere.cap.TB[3][node]=t0;
Lith_age.c:338:  if(E->monitor.solution_cycles>0 && E->control.lith_age_time)   {
Lith_age.c:342:	    nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:344:	    t1=E->sx[1][node];
Lith_age.c:345:	    f1=E->sx[2][node];
Lith_age.c:346:	    r1=E->sx[3][node];
Lith_age.c:348:	    if(fabs(r1-E->sphere.ro)>=e_4 && fabs(r1-E->sphere.ri)>=e_4)  { /* if NOT right on the boundary */
Lith_age.c:349:	      if(  E->sx[3][node]>=E->sphere.ro-E->control.lith_age_depth ) {
Lith_age.c:352:    depth=E->sphere.ro - E->sx[3][node];
Lith_age.c:355:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:356:		t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:358:		E->sphere.cap.TB[1][node]=t0;
Lith_age.c:359:		E->sphere.cap.TB[2][node]=t0;
Lith_age.c:360:		E->sphere.cap.TB[3][node]=t0;
Lith_age.c:374:  nno=E->lmesh.nno;
Lith_age.c:375:  gnox=E->mesh.nox;
Lith_age.c:376:  gnoy=E->mesh.noy;
Lith_age.c:377:  gnoz=E->mesh.noz;
Lith_age.c:378:  nox=E->lmesh.nox;
Lith_age.c:379:  noy=E->lmesh.noy;
Lith_age.c:380:  noz=E->lmesh.noz;
Lith_age.c:382:    for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:384:        type = (E->node[node] & (TBX | TBZ | TBY));
Lith_age.c:390:            assimilate_new_temp = E->sphere.cap.TB[1][node];
Lith_age.c:393:            assimilate_new_temp = E->sphere.cap.TB[3][node];
Lith_age.c:396:            assimilate_new_temp = E->sphere.cap.TB[2][node];
Lith_age.c:399:            assimilate_new_temp = 0.5 * (E->sphere.cap.TB[1][node] + E->sphere.cap.TB[3][node]);
Lith_age.c:402:            assimilate_new_temp = 0.5 * (E->sphere.cap.TB[1][node] + E->sphere.cap.TB[2][node]);
Lith_age.c:405:            assimilate_new_temp = 0.5 * (E->sphere.cap.TB[3][node] + E->sphere.cap.TB[2][node]);
Lith_age.c:408:            assimilate_new_temp = 0.3333333 * (E->sphere.cap.TB[1][node] + E->sphere.cap.TB[2][node] + E->sphere.cap.TB[3][node]);
Lith_age.c:412:        depth = E->sphere.ro - E->sx[3][node];
Lith_age.c:418:            if(depth <= E->control.lith_age_depth) {
Lith_age.c:420:                daf = 0.5*depth/E->control.lith_age_depth;
Lith_age.c:421:                E->T[node] = daf*E->T[node] + (1.0-daf)*assimilate_new_temp;
Lith_age.c:424:                E->T[node] = assimilate_new_temp;
Material_properties.c:48:    int noz = E->lmesh.noz;
Material_properties.c:49:    int nno = E->lmesh.nno;
Material_properties.c:50:    int nel = E->lmesh.nel;
Material_properties.c:53:    E->refstate.rho = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:56:    E->refstate.gravity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:59:    E->refstate.thermal_expansivity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:62:    E->refstate.heat_capacity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:65:    /*E->refstate.thermal_conductivity = (double *) malloc((noz+1)*sizeof(double));*/
Material_properties.c:68:    /*E->refstate.Tadi = (double *) malloc((noz+1)*sizeof(double));*/
Material_properties.c:81:    switch(E->refstate.choice) {
Material_properties.c:95:        if (E->parallel.me) {
Material_properties.c:97:            fprintf(E->fp, "Unknown option for reference state\n");
Material_properties.c:98:            fflush(E->fp);
Material_properties.c:103:    if(E->parallel.me == 0) {
Material_properties.c:106:    if(E->parallel.me < E->parallel.nprocz)
Material_properties.c:107:        for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:109:                    i+E->lmesh.nzs-1, E->sx[3][i], 1-E->sx[3][i],
Material_properties.c:110:                    E->refstate.rho[i],layers_r(E,E->sx[3][i]));
Material_properties.c:124:    fp = fopen(E->refstate.filename, "r");
Material_properties.c:127:                E->refstate.filename);
Material_properties.c:132:    for(i=1; i<E->lmesh.nzs; i++) {
Material_properties.c:136:    for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:139:                  &(E->refstate.rho[i]),
Material_properties.c:140:                  &(E->refstate.gravity[i]),
Material_properties.c:141:                  &(E->refstate.thermal_expansivity[i]),
Material_properties.c:142:                  &(E->refstate.heat_capacity[i]),
Material_properties.c:146:            fprintf(stderr,"Error while reading file '%s'\n", E->refstate.filename);
Material_properties.c:152:                E->refstate.rho[i],
Material_properties.c:153:                E->refstate.gravity[i],
Material_properties.c:154:                E->refstate.thermal_expansivity[i],
Material_properties.c:155:                E->refstate.heat_capacity[i]);
Material_properties.c:169:    beta = E->control.disptn_number * E->control.inv_gruneisen;
Material_properties.c:171:    for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:172:	r = E->sx[3][i];
Material_properties.c:174:	E->refstate.rho[i] = exp(beta*z);
Material_properties.c:175:	E->refstate.gravity[i] = 1;
Material_properties.c:176:	E->refstate.thermal_expansivity[i] = 1;
Material_properties.c:177:	E->refstate.heat_capacity[i] = 1;
Material_properties.c:178:	/*E->refstate.thermal_conductivity[i] = 1;*/
Material_properties.c:179:	/*E->refstate.Tadi[i] = (E->control.adiabaticT0 + E->control.surface_temp) * exp(E->control.disptn_number * z) - E->control.surface_temp;*/
Material_properties.c:209:    const double beta = E->control.disptn_number * E->control.inv_gruneisen;
Material_properties.c:212:    const int gnoz = E->mesh.noz;
Material_properties.c:232:    r = E->sphere.gr;
Material_properties.c:251:    if(E->parallel.me == 0) {
Material_properties.c:259:    for(i=1, j=E->lmesh.nzs; i<=E->lmesh.noz; i++, j++) {
Material_properties.c:261:	E->refstate.rho[i] = rho[j];
Material_properties.c:262:	E->refstate.gravity[i] = 1;
Material_properties.c:263:	E->refstate.heat_capacity[i] = 1;
Material_properties.c:266:	E->refstate.thermal_expansivity[i] = rho[j] / ks;
Material_properties.c:268:	/*E->refstate.thermal_conductivity[i] = 1;*/
Material_properties.c:269:	/*E->refstate.Tadi[i] = (E->control.adiabaticT0 + E->control.surface_temp) * exp(E->control.disptn_number * z) - E->control.surface_temp;*/
Mineral_physics_models.c:174:    if(!E->output.horiz_avg)
Mineral_physics_models.c:179:    rhor = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:180:    vpr = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:181:    vsr = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:182:    depthkm = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:184:    for(nz=1; nz<=E->lmesh.noz; nz++) {
Mineral_physics_models.c:185:        get_prem(E->sx[3][nz], &vpr[nz], &vsr[nz], &rhor[nz]);
Mineral_physics_models.c:186:        depthkm[nz] = (1.0 - E->sx[3][nz]) * E->data.radius_km;
Mineral_physics_models.c:191:    for(i=0; i<E->lmesh.nno; i++) {
Mineral_physics_models.c:192:        nz = (i % E->lmesh.noz) + 1;
Mineral_physics_models.c:196:        dT = (E->T[i+1] - E->Have.T[nz]) * E->data.ref_temperature;
Mineral_physics_models.c:198:        drho = -dT * E->refstate.thermal_expansivity[nz] * E->data.therm_exp;
Mineral_physics_models.c:203:        if(E->control.tracer && E->composition.on && E->composition.ichemical_buoyancy)
Mineral_physics_models.c:204:            for(j=0; j<E->composition.ncomp; j++) {
Mineral_physics_models.c:205:                dC = E->composition.comp_node[j][i+1] - E->Have.C[j][nz];
Mineral_physics_models.c:207:                drho += dC * E->composition.buoyancy_ratio[j]
Mineral_physics_models.c:208:                    * E->data.ref_temperature * E->data.therm_exp / E->refstate.rho[nz];
Mineral_physics_models.c:239:    switch(E->control.mineral_physics_model) {
Mineral_physics_models.c:244:                E->control.mineral_physics_model);
Mineral_physics_models.c:252:                E->control.mineral_physics_model);
Mineral_physics_models.c:260:                E->control.mineral_physics_model);
Mineral_physics_models.c:283:                E->control.mineral_physics_model);
Mineral_physics_models.c:290:                E->control.mineral_physics_model);
Nodal_mesh.c:43:    const int nno = E->lmesh.nno;
Nodal_mesh.c:46:            E->sphere.cap.V[1][node] = E->U[E->id[node].doff[1]];
Nodal_mesh.c:47:            E->sphere.cap.V[2][node] = E->U[E->id[node].doff[2]];
Nodal_mesh.c:48:            E->sphere.cap.V[3][node] = E->U[E->id[node].doff[3]];
Nodal_mesh.c:49:            if (E->node[node] & VBX)
Nodal_mesh.c:50:                E->sphere.cap.V[1][node] = E->sphere.cap.VB[1][node];
Nodal_mesh.c:51:            if (E->node[node] & VBY)
Nodal_mesh.c:52:                E->sphere.cap.V[2][node] = E->sphere.cap.VB[2][node];
Nodal_mesh.c:53:            if (E->node[node] & VBZ)
Nodal_mesh.c:54:                E->sphere.cap.V[3][node] = E->sphere.cap.VB[3][node];
Nodal_mesh.c:62:    const int nno = E->lmesh.nno;
Nodal_mesh.c:65:        E->U[E->id[node].doff[1]] =  E->sphere.cap.V[1][node];
Nodal_mesh.c:66:        E->U[E->id[node].doff[2]] =  E->sphere.cap.V[2][node];
Nodal_mesh.c:67:        E->U[E->id[node].doff[3]] =  E->sphere.cap.V[3][node];
Nodal_mesh.c:76:    const int nno = E->lmesh.nno;
Nodal_mesh.c:81:            E->sphere.cap.Vprev[1][node] = E->sphere.cap.V[1][node];
Nodal_mesh.c:82:            E->sphere.cap.Vprev[2][node] = E->sphere.cap.V[2][node];
Nodal_mesh.c:83:            E->sphere.cap.Vprev[3][node] = E->sphere.cap.V[3][node];
Nodal_mesh.c:85:            E->sphere.cap.V[1][node] = E->U[E->id[node].doff[1]];
Nodal_mesh.c:86:            E->sphere.cap.V[2][node] = E->U[E->id[node].doff[2]];
Nodal_mesh.c:87:            E->sphere.cap.V[3][node] = E->U[E->id[node].doff[3]];
Nodal_mesh.c:88:            if (E->node[node] & VBX)
Nodal_mesh.c:89:                E->sphere.cap.V[1][node] = E->sphere.cap.VB[1][node];
Nodal_mesh.c:90:            if (E->node[node] & VBY)
Nodal_mesh.c:91:                E->sphere.cap.V[2][node] = E->sphere.cap.VB[2][node];
Nodal_mesh.c:92:            if (E->node[node] & VBZ)
Nodal_mesh.c:93:                E->sphere.cap.V[3][node] = E->sphere.cap.VB[3][node];
Nodal_mesh.c:95:            sum_dV += (E->sphere.cap.V[1][node] - E->sphere.cap.Vprev[1][node])*(E->sphere.cap.V[1][node] - E->sphere.cap.Vprev[1][node])
Nodal_mesh.c:96:                + (E->sphere.cap.V[2][node] - E->sphere.cap.Vprev[2][node])*(E->sphere.cap.V[2][node] - E->sphere.cap.Vprev[2][node])
Nodal_mesh.c:97:                + (E->sphere.cap.V[3][node] - E->sphere.cap.Vprev[3][node])*(E->sphere.cap.V[3][node] - E->sphere.cap.Vprev[3][node]);
Nodal_mesh.c:98:            sum_V += E->sphere.cap.V[1][node]*E->sphere.cap.V[1][node]
Nodal_mesh.c:99:                + E->sphere.cap.V[2][node]*E->sphere.cap.V[2][node]
Nodal_mesh.c:100:                + E->sphere.cap.V[3][node]*E->sphere.cap.V[3][node];
Nodal_mesh.c:103:        MPI_Allreduce(&rel_error,&global_max_error,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Nodal_mesh.c:104:        if(global_max_error <= tol_error) E->monitor.stop_topo_loop = 1;
Nodal_mesh.c:105:        if(E->parallel.me==0)
Nodal_mesh.c:106:            fprintf(stderr,"global_max_error=%e stop_topo_loop=%d\n",global_max_error,E->monitor.stop_topo_loop);
Nodal_mesh.c:119:    const int ends=enodes[E->mesh.nsd];
Nodal_mesh.c:120:    const int lev=E->mesh.levmax;
Nodal_mesh.c:124:            node = E->ien[el].node[a];
Nodal_mesh.c:125:            VV[1][a] = E->sphere.cap.V[1][node];
Nodal_mesh.c:126:            VV[2][a] = E->sphere.cap.V[2][node];
Nodal_mesh.c:127:            VV[3][a] = E->sphere.cap.V[3][node];
Nodal_mesh.c:131:            node = E->ien[el].node[a];
Nodal_mesh.c:133:            sint = E->SinCos[lev][0][node]; 
Nodal_mesh.c:134:            sinf = E->SinCos[lev][1][node];
Nodal_mesh.c:135:            cost = E->SinCos[lev][2][node];
Nodal_mesh.c:136:            cosf = E->SinCos[lev][3][node];
Nodal_mesh.c:138:            VV[1][a] = E->sphere.cap.V[1][node]*cost*cosf
Nodal_mesh.c:139:                - E->sphere.cap.V[2][node]*sinf
Nodal_mesh.c:140:                + E->sphere.cap.V[3][node]*sint*cosf;
Nodal_mesh.c:141:            VV[2][a] = E->sphere.cap.V[1][node]*cost*sinf
Nodal_mesh.c:142:                + E->sphere.cap.V[2][node]*cosf
Nodal_mesh.c:143:                + E->sphere.cap.V[3][node]*sint*sinf;
Nodal_mesh.c:144:            VV[3][a] = -E->sphere.cap.V[1][node]*sint
Nodal_mesh.c:145:                + E->sphere.cap.V[3][node]*cost;
Nodal_mesh.c:159:    const int dims=E->mesh.nsd;
Nodal_mesh.c:160:    const int ends=enodes[E->mesh.nsd];
Nodal_mesh.c:161:    const int nno=E->lmesh.nno;
Nodal_mesh.c:162:    const int lev=E->mesh.levmax;
Nodal_mesh.c:166:            node = E->ien[el].node[a];
Nodal_mesh.c:167:            VV[1][a] = E->sphere.cap.V[1][node];
Nodal_mesh.c:168:            VV[2][a] = E->sphere.cap.V[2][node];
Nodal_mesh.c:169:            VV[3][a] = E->sphere.cap.V[3][node];
Nodal_mesh.c:173:            node = E->ien[el].node[a];
Nodal_mesh.c:175:            sint = E->SinCos[lev][0][node];
Nodal_mesh.c:176:            sinf = E->SinCos[lev][1][node];
Nodal_mesh.c:177:            cost = E->SinCos[lev][2][node];
Nodal_mesh.c:178:            cosf = E->SinCos[lev][3][node];
Nodal_mesh.c:180:            VV[1][a] = E->sphere.cap.V[1][node]*cost*cosf
Nodal_mesh.c:181:                - E->sphere.cap.V[2][node]*sinf
Nodal_mesh.c:182:                + E->sphere.cap.V[3][node]*sint*cosf;
Nodal_mesh.c:183:            VV[2][a] = E->sphere.cap.V[1][node]*cost*sinf
Nodal_mesh.c:184:                + E->sphere.cap.V[2][node]*cosf
Nodal_mesh.c:185:                + E->sphere.cap.V[3][node]*sint*sinf;
Nodal_mesh.c:186:            VV[3][a] = -E->sphere.cap.V[1][node]*sint
Nodal_mesh.c:187:                + E->sphere.cap.V[3][node]*cost;
Nodal_mesh.c:200:    for(node=1;node<=E->lmesh.NNO[lev];node++)
Nodal_mesh.c:203:    for(element=1;element<=E->lmesh.NEL[lev];element++)
Nodal_mesh.c:204:       for(j=1;j<=enodes[E->mesh.nsd];j++)  {
Nodal_mesh.c:205:          node = E->IEN[lev][element].node[j];
Nodal_mesh.c:206:          PN[node] += P[element] * E->TWW[lev][element].node[j] ;
Nodal_mesh.c:209:   (E->exchange_node_f)(E,PN,lev);
Nodal_mesh.c:211:   for(node=1;node<=E->lmesh.NNO[lev];node++)
Nodal_mesh.c:212:      PN[node] *= E->MASS[lev][node];
Nodal_mesh.c:222:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:227:  for(i=1;i<=E->lmesh.NNO[lev];i++)
Nodal_mesh.c:230:  for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Nodal_mesh.c:237:      n = E->IEN[lev][e].node[j];
Nodal_mesh.c:238:      VN[n] += E->TWW[lev][e].node[j] * temp_visc;
Nodal_mesh.c:242:  (E->exchange_node_f)(E,VN,lev);
Nodal_mesh.c:243:  for(n=1;n<=E->lmesh.NNO[lev];n++)
Nodal_mesh.c:244:    VN[n] *= E->MASS[lev][n];
Nodal_mesh.c:259:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:265:  for(e=1;e<=E->lmesh.NEL[lev];e++)
Nodal_mesh.c:269:  for(e=1;e<=E->lmesh.NEL[lev];e++)
Nodal_mesh.c:273:        temp_visc += E->N.vpt[GNVINDEX(j,i)]*VN[E->IEN[lev][e].node[j]];
Nodal_mesh.c:280:   visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv) 
Nodal_mesh.c:289:    const int nsd=E->mesh.nsd;
Nodal_mesh.c:294:    for(i=1;i<=E->lmesh.NEL[lev];i++)
Nodal_mesh.c:297:    for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Nodal_mesh.c:308:   visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus); 
Nodal_mesh.c:318:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:323:    for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:66:  const int dims=E->mesh.nsd;
Obsolete.c:82:          x[d] += E->X[lev][d][E->IEN[lev][el].node[i]]*
Obsolete.c:83:                E->N.vpt[GNVINDEX(i,k)];
Obsolete.c:88:            dxda[d][e] += E->X[lev][e][E->IEN[lev][el].node[i]]
Obsolete.c:89:               * E->Nx.vpt[GNVXINDEX(d-1,i,k)];
Obsolete.c:91:      jacobian = determinant(dxda,E->mesh.nsd);
Obsolete.c:106:                 E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Obsolete.c:125:                 E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Obsolete.c:143:          x[d] += E->X[lev][d][E->IEN[lev][el].node[i]]
Obsolete.c:144:                 *E->N.ppt[GNPINDEX(i,k)];
Obsolete.c:149:            dxda[d][e] += E->X[lev][e][E->IEN[lev][el].node[i]]
Obsolete.c:150:                     * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Obsolete.c:152:      jacobian = determinant(dxda,E->mesh.nsd);
Obsolete.c:157:          cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd);
Obsolete.c:166:                E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Obsolete.c:184:                E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Obsolete.c:210:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Obsolete.c:216:   for(k=1;k<=vpoints[E->mesh.nsd];k++)  {
Obsolete.c:222:            dxda[d][e] += E->NMx.vpt[GNVXINDEX(d-1,i,k)]
Obsolete.c:223:                * E->x[e][E->ien[el].node[i]];
Obsolete.c:234:        jacobian = sqrt(fabs(determinant(cof,E->mesh.nsd)))/cof[3][3];
Obsolete.c:266:  const int oned = onedvpoints[E->mesh.nsd];
Obsolete.c:267:  const int vpts = vpoints[E->mesh.nsd-1];
Obsolete.c:268:  const int ppts = ppoints[E->mesh.nsd-1];
Obsolete.c:269:  const int ends = enodes[E->mesh.nsd-1];
Obsolete.c:287:  to = E->eco[el].centre[1];
Obsolete.c:288:  fo = E->eco[el].centre[2];
Obsolete.c:289:  ro = E->eco[el].centre[3];
Obsolete.c:304:    node=E->ien[el].node[a];
Obsolete.c:305:    xx[1][i] = E->x[1][node]*dxdy[1][1]
Obsolete.c:306:      + E->x[2][node]*dxdy[1][2]
Obsolete.c:307:      + E->x[3][node]*dxdy[1][3];
Obsolete.c:308:    xx[2][i] = E->x[1][node]*dxdy[2][1]
Obsolete.c:309:      + E->x[2][node]*dxdy[2][2]
Obsolete.c:310:      + E->x[3][node]*dxdy[2][3];
Obsolete.c:311:    xx[3][i] = E->x[1][node]*dxdy[3][1]
Obsolete.c:312:      + E->x[2][node]*dxdy[3][2]
Obsolete.c:313:      + E->x[3][node]*dxdy[3][3];
Obsolete.c:317:    for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:318:      for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:324:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:325:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:326:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:333:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:334:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:335:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:342:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:343:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:344:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:349:    jacobian = determinant(dxda,E->mesh.nsd-1);
Obsolete.c:354:    for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:355:      for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:361:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:362:	  for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:363:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:369:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:370:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:372:	    node=E->ien[el].node[a];
Obsolete.c:373:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:380:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:381:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:383:	    node=E->ien[el].node[a];
Obsolete.c:384:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:389:    jacobian = determinant(dxda,E->mesh.nsd-1);
Obsolete.c:425:  for(i=1;i<=E->mesh.nsd;i++)
Obsolete.c:426:    { for(a=1;a<=enodes[E->mesh.nsd];a++)
Obsolete.c:427:	{ if (E->node[E->ien[el].node[a]] & type)
Obsolete.c:429:		{  get_elt_g(E,el,elt_g,E->mesh.levmax,m);
Obsolete.c:433:	      p=E->mesh.nsd*(a-1) + i - 1;
Obsolete.c:434:	      for(b=1;b<=pnodes[E->mesh.nsd];b++)
Obsolete.c:436:		  elt_h[q] -= elt_g[p][q] * E->sphere.cap.VB[i][E->ien[el].node[a]];
Obsolete.c:457:  const int nel=E->lmesh.nel;
Obsolete.c:458:  const int vpts=vpoints[E->mesh.nsd];
Obsolete.c:460:  lev = E->mesh.levmax;
Obsolete.c:462:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:466:        EV[el] +=  E->EVI[lev][(el-1)*vpts+j];
Obsolete.c:492:    E->sphere.con = (double *)malloc(E->sphere.hindice*sizeof(double));
Obsolete.c:493:    for (ll=0;ll<=E->output.llmax;ll++)
Obsolete.c:495:	    E->sphere.con[E->sphere.hindex[ll][mm]] =
Obsolete.c:500:    E->sphere.tablenplm   = (double **) malloc((E->sphere.nox+1)
Obsolete.c:502:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:503:	E->sphere.tablenplm[i]= (double *)malloc(E->sphere.hindice
Obsolete.c:506:    E->sphere.tablencosf  = (double **) malloc((E->sphere.noy+1)
Obsolete.c:508:    E->sphere.tablensinf  = (double **) malloc((E->sphere.noy+1)
Obsolete.c:510:    for (i=1;i<=E->sphere.noy;i++)   {
Obsolete.c:511:	E->sphere.tablencosf[i]= (double *)malloc((E->output.llmax+3)
Obsolete.c:513:	E->sphere.tablensinf[i]= (double *)malloc((E->output.llmax+3)
Obsolete.c:517:    E->sphere.sx[1] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Obsolete.c:518:    E->sphere.sx[2] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Obsolete.c:520:    dth = M_PI/E->sphere.elx;
Obsolete.c:521:    dfi = 2.0*M_PI/E->sphere.ely;
Obsolete.c:523:    for (j=1;j<=E->sphere.noy;j++)
Obsolete.c:524:	for (i=1;i<=E->sphere.nox;i++) {
Obsolete.c:525:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:526:	    E->sphere.sx[1][node] = dth*(i-1);
Obsolete.c:527:	    E->sphere.sx[2][node] = dfi*(j-1);
Obsolete.c:530:    for (j=1;j<=E->sphere.nox;j++)  {
Obsolete.c:531:	t=E->sphere.sx[1][j];
Obsolete.c:532:	for (ll=0;ll<=E->output.llmax;ll++)
Obsolete.c:534:		p = E->sphere.hindex[ll][mm];
Obsolete.c:535:		E->sphere.tablenplm[j][p] = modified_plgndr_a(ll,mm,t) ;
Obsolete.c:538:    for (j=1;j<=E->sphere.noy;j++)  {
Obsolete.c:539:	node = 1+(j-1)*E->sphere.nox;
Obsolete.c:540:	f=E->sphere.sx[2][node];
Obsolete.c:541:	for (mm=0;mm<=E->output.llmax;mm++)   {
Obsolete.c:542:	    E->sphere.tablencosf[j][mm] = cos( (double)(mm)*f );
Obsolete.c:543:	    E->sphere.tablensinf[j][mm] = sin( (double)(mm)*f );
Obsolete.c:565:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:566:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:567:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:568:	    E->sphere.int_cap[node]=0;
Obsolete.c:569:	    E->sphere.int_ele[node]=0;
Obsolete.c:573:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:574:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:575:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:578:	    t = E->sphere.sx[1][node];
Obsolete.c:579:	    f = E->sphere.sx[2][node];
Obsolete.c:586:	    fprintf(E->fp,"mmm0=%d\n",node);
Obsolete.c:590:	    fprintf(E->fp,"mmm=%d\n",m);
Obsolete.c:596:		    fprintf(stderr,"!!! Processor %d cannot find the right element in cap %d\n",E->parallel.me,m);
Obsolete.c:600:		E->sphere.int_cap[node]=m;
Obsolete.c:601:		E->sphere.int_ele[node]=el;
Obsolete.c:629:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Obsolete.c:631:	ia[2] = E->lmesh.noz*E->lmesh.nox-E->lmesh.noz+1;
Obsolete.c:632:	ia[3] = E->lmesh.nno-E->lmesh.noz+1;
Obsolete.c:633:	ia[4] = ia[3]-E->lmesh.noz*(E->lmesh.nox-1);
Obsolete.c:636:	    xx[1] = E->x[1][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:637:	    xx[2] = E->x[2][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:638:	    xx[3] = E->x[3][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:640:	    angle1[i]=E->sphere.angle[i];
Obsolete.c:648:	if ( fabs ((area1-E->sphere.area)/E->sphere.area) <e_7 ) {
Obsolete.c:678:    level=E->mesh.levmin;
Obsolete.c:679:    for (es=1;es<=E->lmesh.SNEL[level];es++)              {
Obsolete.c:681:	el = (es-1)*E->lmesh.ELZ[level]+1;
Obsolete.c:683:	area = E->sphere.area1[level][es];
Obsolete.c:686:	    for (lev=E->mesh.levmin;lev<E->mesh.levmax;lev++)  {
Obsolete.c:691:		    el_plus = E->EL[lev][el].sub[j];
Obsolete.c:693:		    es_plus = (el_plus-1)/E->lmesh.ELZ[lev_plus]+1;
Obsolete.c:696:		    area = E->sphere.area1[lev_plus][es_plus];
Obsolete.c:744:    es = (el-1)/E->lmesh.elz+1;
Obsolete.c:746:    to = E->eco[el].centre[1];
Obsolete.c:747:    fo = E->eco[el].centre[2];
Obsolete.c:760:	node = E->ien[el].node[i];
Obsolete.c:761:	snode = E->sien[es].node[i];
Obsolete.c:763:	for (j=1;j<=E->mesh.nsd;j++)
Obsolete.c:764:	    yy[j][i] = E->x[1][node]*dxdy[j][1]
Obsolete.c:765:                + E->x[2][node]*dxdy[j][2]
Obsolete.c:766:                + E->x[3][node]*dxdy[j][3];
Obsolete.c:769:    for (j=1;j<=E->mesh.nsd;j++)
Obsolete.c:807:    /*if(fabs(xx1)>1.5 || fabs(yy1)>1.5)fprintf(E->fp_out,"ME= %d %d %d %g %g %g %g %g %g %g\n",ne,m,es,t[1],t[2],t[3],t[4],ta,xx1,yy1);
Obsolete.c:832:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:833:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:834:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:838:	    m = E->sphere.int_cap[node];
Obsolete.c:839:	    el = E->sphere.int_ele[node];
Obsolete.c:842:		t = E->sphere.sx[1][node];
Obsolete.c:843:		f = E->sphere.sx[2][node];
Obsolete.c:845:		x[1] = E->sx[1][3][1]*sin(t)*cos(f);
Obsolete.c:846:		x[2] = E->sx[1][3][1]*sin(t)*sin(f);
Obsolete.c:847:		x[3] = E->sx[1][3][1]*cos(t);
Obsolete.c:876:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:877:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:878:      e_pressure = (E->sphere.ro-E->sx[3][i])-E->viscosity.z410-
Obsolete.c:879:            E->control.clapeyron410*(E->T[i]-E->control.transT410);
Obsolete.c:881:      B[i] = pt5*(one+tanh(E->control.width410*e_pressure));
Obsolete.c:885:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:886:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:889:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:890:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:892:            B_b[ns]=(E->sx[3][n+1]-E->sx[3][n])*(pt5-B[n])/(B[n+1]-B[n])+E->sx[3][n];
Obsolete.c:911:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:912:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:913:      e_pressure = (E->sphere.ro-E->sx[3][i])-E->viscosity.zlm-
Obsolete.c:914:            E->control.clapeyron670*(E->T[i]-E->control.transT670);
Obsolete.c:916:      B[i] = pt5*(one+tanh(E->control.width670*e_pressure));
Obsolete.c:920:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:921:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:924:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:925:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:927:            B_b[ns]=(E->sx[3][n+1]-E->sx[3][n])*(pt5-B[n])/(B[n+1]-B[n])+E->sx[3][n];
Obsolete.c:946:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:947:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:948:      e_pressure = (E->sphere.ro-E->sx[3][i])-E->viscosity.zcmb-
Obsolete.c:949:            E->control.clapeyroncmb*(E->T[i]-E->control.transTcmb);
Obsolete.c:951:      B[i] = pt5*(one+tanh(E->control.widthcmb*e_pressure));
Obsolete.c:955:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:956:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:959:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:960:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:962:            B_b[ns]=(E->sx[3][n+1]-E->sx[3][n])*(pt5-B[n])/(B[n+1]-B[n])+E->sx[3][n];
Obsolete.c:995:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:996:    for(p=1;p<=E->lmesh.NEL[lev];p++)
Obsolete.c:999:   weight=1.0/((double)enodes[E->mesh.nsd]) ;
Obsolete.c:1001:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1002:    for(p=1;p<=E->lmesh.NEL[lev];p++)
Obsolete.c:1003:      for(j=1;j<=enodes[E->mesh.nsd];j++)
Obsolete.c:1004:        P[p] += PN[E->IEN[lev][p].node[j]] * weight;
Obsolete.c:1017:   const int nsd=E->mesh.nsd;
Obsolete.c:1021: for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1022:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:1026:          VE[(e-1)*vpts + i] += VN[E->IEN[lev][e].node[j]]*E->N.vpt[GNVINDEX(j,i)];
Obsolete.c:1040:   const int nsd=E->mesh.nsd;
Obsolete.c:1044: for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1045:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:1049:          VE[(e-1)*vpts + i] += log(VN[E->IEN[lev][e].node[j]]) *  E->N.vpt[GNVINDEX(j,i)];
Obsolete.c:1163:    if(!input_string(input_token,filename,"initialize",E->parallel.me)) {
Obsolete.c:1164:	fprintf(E->fp,"No previous %s information found in input file\n",name);fflush(E->fp);
Obsolete.c:1169:    fprintf(E->fp,"Previous %s information is in file %s\n",name,filename);fflush(E->fp);
Obsolete.c:1174:	fprintf(E->fp,"Unable to open the required file `%s' (this is fatal)",filename);
Obsolete.c:1175:	fflush(E->fp);
Obsolete.c:1187:	fprintf(E->fp,"File %s is not in the correct format\n",filename);fflush(E->fp);
Obsolete.c:1198:	fprintf(E->fp,"Unable to deciphre the columns in the input file");fflush(E->fp);
Obsolete.c:1212:	fprintf(E->fp,"\t%s (%s) found in column %d\n",name,abbr,column);fflush(E->fp);
Obsolete.c:1215:	fprintf(E->fp,"\t%s (%s) not found in file: %s\n",name,abbr,filename);fflush(E->fp);
Obsolete.c:1222:    if(((3!= E->mesh.nsd) && (fnodesy !=1)) || ((3==E->mesh.nsd) && (1==fnodesy))) {
Obsolete.c:1223:	fprintf(E->fp,"Input data for file `%s'  is of inappropriate dimension (not %dD)\n",filename,E->mesh.nsd);fflush(E->fp);
Obsolete.c:1227:    if(fnodesx != E->lmesh.nox || fnodesz != E->lmesh.noz || fnodesy != E->lmesh.noy) {
Obsolete.c:1244:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1392:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1490:  n = loc_mat_size[E->mesh.nsd];
Obsolete.c:1573:    const int dims=E->mesh.nsd;
Obsolete.c:1575:    const int n=loc_mat_size[E->mesh.nsd];
Obsolete.c:1576:    const int neq=E->lmesh.NEQ[level];
Obsolete.c:1577:    const int num_nodes=E->lmesh.NNO[level];
Obsolete.c:1578:    const int nox=E->lmesh.NOX[level];
Obsolete.c:1579:    const int noz=E->lmesh.NOY[level];
Obsolete.c:1580:    const int noy=E->lmesh.NOZ[level];
Obsolete.c:1583:    gneq = E->mesh.NEQ[level];
Obsolete.c:1587:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1588:      r1[m] = (double *)malloc(E->lmesh.neq*sizeof(double));
Obsolete.c:1591:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1596:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1601:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1609:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1610: 	for(i=1;i<=E->lmesh.NNO[level];i++)  {
Obsolete.c:1611:	    eqn1=E->ID[level][m][i].doff[1];
Obsolete.c:1612:	    eqn2=E->ID[level][m][i].doff[2];
Obsolete.c:1613:	    eqn3=E->ID[level][m][i].doff[3];
Obsolete.c:1614:            d0[m][eqn1] += r1[m][eqn1]*E->BI[level][m][eqn1];
Obsolete.c:1615:            d0[m][eqn2] += r1[m][eqn2]*E->BI[level][m][eqn2];
Obsolete.c:1616:            d0[m][eqn3] += r1[m][eqn3]*E->BI[level][m][eqn3];
Obsolete.c:1619:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1623:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1624: 	for(i=1;i<=E->lmesh.NNO[level];i++)  {
Obsolete.c:1625:	    eqn1=E->ID[level][m][i].doff[1];
Obsolete.c:1626:	    eqn2=E->ID[level][m][i].doff[2];
Obsolete.c:1627:	    eqn3=E->ID[level][m][i].doff[3];
Obsolete.c:1632:            C=E->Node_map[level][m]+(i-1)*max_eqn;
Obsolete.c:1633:	    B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
Obsolete.c:1634:	    B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
Obsolete.c:1635: 	    B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
Obsolete.c:1648:      (E->solver.exchange_id_d)(E, Ad, level);
Obsolete.c:1650:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:1656:   if(E->parallel.me==0)fprintf(stderr,"residuall =%.5e for %d\n",residual,count);
Obsolete.c:1662:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Output.c:73:    int m = E->parallel.me;
Output.c:75:    input_string("output_format", E->output.format, "ascii",m);
Output.c:76:    input_string("output_optional", E->output.optional, "surf,botm,tracer",m);
Output.c:79:    E->output.gzdir.vtk_io = 0;
Output.c:80:    E->output.gzdir.rnr = 0;
Output.c:81:    if(strcmp(E->output.format, "ascii-gz") == 0){
Output.c:88:      input_int("gzdir_vtkio",&(E->output.gzdir.vtk_io),"1",m);
Output.c:90:      input_boolean("gzdir_rnr",&(E->output.gzdir.rnr),"off",m);
Output.c:91:      E->output.gzdir.vtk_base_init = 0;
Output.c:92:      E->output.gzdir.vtk_base_save = 1; /* should we save the basis vectors? (memory!) */
Output.c:94:      //      E->output.gzdir.vtk_io,E->output.gzdir.vtk_base_save);
Output.c:97:    if(strcmp(E->output.format, "vtk") == 0) {
Output.c:98:        input_string("vtk_format", E->output.vtk_format, "ascii",m);
Output.c:99:        if (strcmp(E->output.vtk_format, "binary") != 0 &&
Output.c:100:            strcmp(E->output.vtk_format, "ascii") != 0) {
Output.c:101:            if(E->parallel.me == 0) {
Output.c:102:                fprintf(stderr, "Unknown vtk_format: %s\n", E->output.vtk_format);
Output.c:119:    if (E->output.coord_bin)
Output.c:136:  if (E->output.geoid)		/* this needs to be called after the
Output.c:141:  if (E->output.stress){
Output.c:144:  if (E->output.pressure)
Output.c:147:  if (E->output.horiz_avg)
Output.c:150:  if (E->output.seismic)
Output.c:153:  if(E->output.tracer && E->control.tracer)
Output.c:156:  if (E->output.comp_nd && E->composition.on)
Output.c:159:  if (E->output.comp_el && E->composition.on)
Output.c:162:  if(E->output.heating && E->control.disptn_number != 0)
Output.c:195:  sprintf(output_file,"%s.coord.%d",E->control.data_file,E->parallel.me);
Output.c:198:    fprintf(fp1,"%7d\n",E->lmesh.nno);
Output.c:199:    for(i=1;i<=E->lmesh.nno;i++)
Output.c:200:      fprintf(fp1,"%.6e %.6e %.6e\n",E->sx[1][i],E->sx[2][i],E->sx[3][i]);
Output.c:216:    const int nox = E->lmesh.nox;
Output.c:217:    const int noy = E->lmesh.noy;
Output.c:218:    const int noz = E->lmesh.noz;
Output.c:230:    buffer[0] = E->sx[3][1];
Output.c:231:    buffer[1] = E->sx[3][noz];
Output.c:232:    buffer[2] = E->sx[1][corner_nodes[0]];
Output.c:233:    buffer[3] = E->sx[2][corner_nodes[0]];
Output.c:234:    buffer[4] = E->sx[1][corner_nodes[1]];
Output.c:235:    buffer[5] = E->sx[2][corner_nodes[1]];
Output.c:236:    buffer[6] = E->sx[1][corner_nodes[2]];
Output.c:237:    buffer[7] = E->sx[2][corner_nodes[2]];
Output.c:238:    buffer[8] = E->sx[1][corner_nodes[3]];
Output.c:239:    buffer[9] = E->sx[2][corner_nodes[3]];
Output.c:241:    if(E->parallel.me == 0) {
Output.c:248:        sprintf(output_file,"%s.domain",E->control.data_file);
Output.c:252:        header[0] = E->parallel.nproc;
Output.c:262:        for(rank=1; rank<E->parallel.nproc; rank++) {
Output.c:263:            MPI_Recv(buffer, ncolumns, MPI_DOUBLE, rank, tag, E->parallel.world, &status);
Output.c:270:        MPI_Send(buffer, ncolumns, MPI_DOUBLE, receiver, tag, E->parallel.world);
Output.c:284:  sprintf(output_file,"%s.coord_bin.%d",E->control.data_file,E->parallel.me);
Output.c:288:      header[0] = E->lmesh.nox;
Output.c:289:      header[1] = E->lmesh.noy;
Output.c:290:      header[2] = E->lmesh.noz;
Output.c:294:      fwrite(&(E->x[1][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:295:      fwrite(&(E->x[2][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:296:      fwrite(&(E->x[3][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:307:  int lev = E->mesh.levmax;
Output.c:309:  sprintf(output_file,"%s.visc.%d.%d", E->control.data_file,
Output.c:310:          E->parallel.me, cycles);
Output.c:314:  fprintf(fp1,"%7d\n",E->lmesh.nno);
Output.c:315:  for(i=1;i<=E->lmesh.nno;i++)
Output.c:316:    fprintf(fp1,"%.4e\n",E->VI[lev][i]);
Output.c:327:  int lev = E->mesh.levmax;
Output.c:328:  if(E->viscosity.allow_anisotropic_viscosity){
Output.c:329:    sprintf(output_file,"%s.avisc.%d.%d", E->control.data_file,
Output.c:330:	    E->parallel.me, cycles);
Output.c:332:      fprintf(fp1,"%7d\n",E->lmesh.nno);
Output.c:333:      for(i=1;i<=E->lmesh.nno;i++)
Output.c:334:	fprintf(fp1,"%.4e %.4e %.4e %.4e\n",E->VI2[lev][i],E->VIn1[lev][i],E->VIn2[lev][i],E->VIn3[lev][i]);
Output.c:348:  sprintf(output_file,"%s.velo.%d.%d", E->control.data_file,
Output.c:349:          E->parallel.me, cycles);
Output.c:352:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:354:    fprintf(fp1,"%7d\n",E->lmesh.nno);
Output.c:355:    for(i=1;i<=E->lmesh.nno;i++) {
Output.c:356:        fprintf(fp1,"%.6e %.6e %.6e %.6e\n",E->sphere.cap.V[1][i],E->sphere.cap.V[2][i],E->sphere.cap.V[3][i],E->T[i]);
Output.c:370:  if((E->output.write_q_files == 0) || (cycles == 0) ||
Output.c:371:     (cycles % E->output.write_q_files)!=0)
Output.c:375:  if(E->control.use_cbf_topo){
Output.c:376:    get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Output.c:379:    get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Output.c:382:  if (E->output.surf && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) {
Output.c:383:    sprintf(output_file,"%s.surf.%d.%d", E->control.data_file,
Output.c:384:            E->parallel.me, cycles);
Output.c:388:        if(E->control.pseudo_free_surf)
Output.c:389:            topo = E->slice.freesurf;
Output.c:391:            topo = E->slice.tpg;
Output.c:393:        fprintf(fp2,"%7d\n",E->lmesh.nsf);
Output.c:394:        for(i=1;i<=E->lmesh.nsf;i++)   {
Output.c:395:            s = i*E->lmesh.noz;
Output.c:397:		    topo[i],E->slice.shflux[i],E->sphere.cap.V[1][s],E->sphere.cap.V[2][s]);
Output.c:403:  if (E->output.botm && (E->parallel.me_loc[3]==0)) {
Output.c:404:    sprintf(output_file,"%s.botm.%d.%d", E->control.data_file,
Output.c:405:            E->parallel.me, cycles);
Output.c:408:      fprintf(fp2,"%7d\n",E->lmesh.nsf);
Output.c:409:      for(i=1;i<=E->lmesh.nsf;i++)  {
Output.c:410:        s = (i-1)*E->lmesh.noz + 1;
Output.c:412:		E->slice.tpgb[i],E->slice.bhflux[i],E->sphere.cap.V[1][s],E->sphere.cap.V[2][s]);
Output.c:430:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Output.c:431:        sprintf(output_file, "%s.geoid.%d.%d", E->control.data_file,
Output.c:432:                E->parallel.me, cycles);
Output.c:436:        fprintf(fp1, "%d %d %.5e\n", cycles, E->output.llmax,
Output.c:437:                E->monitor.elapsed_time);
Output.c:440:        for (ll=0; ll<=E->output.llmax; ll++)
Output.c:442:                p = E->sphere.hindex[ll][mm];
Output.c:445:                        E->sphere.harm_geoid[0][p],
Output.c:446:                        E->sphere.harm_geoid[1][p],
Output.c:447:                        E->sphere.harm_geoid_from_tpgt[0][p],
Output.c:448:                        E->sphere.harm_geoid_from_tpgt[1][p],
Output.c:449:                        E->sphere.harm_geoid_from_bncy[0][p],
Output.c:450:                        E->sphere.harm_geoid_from_bncy[1][p]);
Output.c:473:  if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output.c:478:  sprintf(output_file,"%s.stress.%d.%d", E->control.data_file,
Output.c:479:          E->parallel.me, cycles);
Output.c:482:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:484:  fprintf(fp1,"%7d\n",E->lmesh.nno);
Output.c:486:  for (node=1;node<=E->lmesh.nno;node++)
Output.c:488:            E->gstress[(node-1)*6+1],
Output.c:489:            E->gstress[(node-1)*6+2],
Output.c:490:            E->gstress[(node-1)*6+3],
Output.c:491:            E->gstress[(node-1)*6+4],
Output.c:492:            E->gstress[(node-1)*6+5],
Output.c:493:            E->gstress[(node-1)*6+6]);
Output.c:512:  if (E->parallel.me<E->parallel.nprocz)  {
Output.c:513:    sprintf(output_file,"%s.horiz_avg.%d.%d", E->control.data_file,
Output.c:514:            E->parallel.me, cycles);
Output.c:516:    for(j=1;j<=E->lmesh.noz;j++)  {
Output.c:517:        fprintf(fp1,"%.4e %.4e %.4e %.4e",E->sx[3][j],
Output.c:518:		E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]);
Output.c:520:        if (E->composition.on) {
Output.c:522:            for(n=0; n<E->composition.ncomp; n++)
Output.c:523:                fprintf(fp1," %.4e", E->Have.C[n][j]);
Output.c:542:    const int len = E->lmesh.nno;
Output.c:556:    sprintf(output_file,"%s.seismic.%d.%d", E->control.data_file, E->parallel.me, cycles);
Output.c:559:    fwrite(rho, sizeof(double), E->lmesh.nno, fp);
Output.c:560:    fwrite(vp, sizeof(double), E->lmesh.nno, fp);
Output.c:561:    fwrite(vs, sizeof(double), E->lmesh.nno, fp);
Output.c:577:  sprintf(output_file,"%s.mat.%d", E->control.data_file,E->parallel.me);
Output.c:580:  for(el=1;el<=E->lmesh.nel;el++)
Output.c:581:    fprintf(fp,"%d %d %f\n", el,E->mat[el],E->VIP[el]);
Output.c:592:  sprintf(output_file,"%s.pressure.%d.%d", E->control.data_file,
Output.c:593:          E->parallel.me, cycles);
Output.c:596:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:598:    fprintf(fp1,"%7d\n",E->lmesh.nno);
Output.c:599:    for(i=1;i<=E->lmesh.nno;i++)
Output.c:600:      fprintf(fp1,"%.6e\n",E->NP[i]);
Output.c:612:  sprintf(output_file,"%s.tracer.%d.%d", E->control.data_file,
Output.c:613:          E->parallel.me, cycles);
Output.c:616:  ncolumns = 3 + E->trace.number_of_extra_quantities;
Output.c:618:      fprintf(fp1,"%d %d %d %.5e\n", cycles, E->trace.ntracers,
Output.c:619:              ncolumns, E->monitor.elapsed_time);
Output.c:621:      for(n=1;n<=E->trace.ntracers;n++) {
Output.c:624:                  E->trace.basicq[0][n],
Output.c:625:                  E->trace.basicq[1][n],
Output.c:626:                  E->trace.basicq[2][n]);
Output.c:629:          for (i=0; i<E->trace.number_of_extra_quantities; i++) {
Output.c:630:              fprintf(fp1," %.12e", E->trace.extraq[i][n]);
Output.c:645:    sprintf(output_file,"%s.comp_nd.%d.%d", E->control.data_file,
Output.c:646:            E->parallel.me, cycles);
Output.c:650:                E->lmesh.nel,
Output.c:651:                E->monitor.elapsed_time, E->composition.ncomp);
Output.c:652:        for(i=0;i<E->composition.ncomp;i++) {
Output.c:654:                    E->composition.initial_bulk_composition[i],
Output.c:655:                    E->composition.bulk_composition[i]);
Output.c:659:        for(i=1;i<=E->lmesh.nno;i++) {
Output.c:660:            for(k=0;k<E->composition.ncomp;k++) {
Output.c:661:                fprintf(fp1,"%.6e ",E->composition.comp_node[k][i]);
Output.c:676:    sprintf(output_file,"%s.comp_el.%d.%d", E->control.data_file,
Output.c:677:            E->parallel.me, cycles);
Output.c:681:                E->lmesh.nel,
Output.c:682:                E->monitor.elapsed_time, E->composition.ncomp);
Output.c:683:        for(i=0;i<E->composition.ncomp;i++) {
Output.c:685:                    E->composition.initial_bulk_composition[i],
Output.c:686:                    E->composition.bulk_composition[i]);
Output.c:690:        for(i=1;i<=E->lmesh.nel;i++) {
Output.c:691:            for(k=0;k<E->composition.ncomp;k++) {
Output.c:693:			E->composition.comp_el[k][i]);
Output.c:707:    sprintf(output_file,"%s.heating.%d.%d", E->control.data_file,
Output.c:708:            E->parallel.me, cycles);
Output.c:711:    fprintf(fp1,"%.5e\n",E->monitor.elapsed_time);
Output.c:713:    fprintf(fp1,"%7d\n", E->lmesh.nel);
Output.c:714:    for(e=1; e<=E->lmesh.nel; e++)
Output.c:715:        fprintf(fp1, "%.4e %.4e %.4e\n", E->heating_adi[e],
Output.c:716:                E->heating_visc[e], E->heating_latent[e]);
Output.c:727:  if (E->parallel.me == 0) {
Output.c:728:    fprintf(E->fptime,"%d %.4e %.4e %.4e %.4e\n",
Output.c:730:            E->monitor.elapsed_time,
Output.c:731:            E->advection.timestep,
Output.c:732:            current_time - E->monitor.cpu_time_at_start,
Output.c:733:            current_time - E->monitor.cpu_time_at_last_cycle);
Output.c:735:    fflush(E->fptime);
Output.c:738:  E->monitor.cpu_time_at_last_cycle = current_time;
Output_gzdir.c:147:    if (E->output.coord_bin)
Output_gzdir.c:159:  snprintf(output_dir,255,"%s/%d",E->control.data_dir,out_cycles);
Output_gzdir.c:178:  if (E->output.geoid)
Output_gzdir.c:181:  if (E->output.stress){
Output_gzdir.c:184:  if (E->output.pressure)
Output_gzdir.c:187:  if (E->output.horiz_avg)
Output_gzdir.c:190:  if(E->control.tracer){
Output_gzdir.c:191:    if(E->output.tracer ||
Output_gzdir.c:192:       (out_cycles == E->advection.max_timesteps))
Output_gzdir.c:196:  if (E->output.comp_nd && E->composition.on)
Output_gzdir.c:199:  if (E->output.comp_el && E->composition.on)
Output_gzdir.c:202:  if(E->output.heating && E->control.disptn_number != 0)
Output_gzdir.c:241:  if((E->output.gzdir.vtk_io == 2)||(E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:245:    if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:252:    E->output.gzdir.vtk_ocount = -1;
Output_gzdir.c:254:    if(E->parallel.me == 0){
Output_gzdir.c:256:      snprintf(message,255,"%s/vtk_time.log",E->control.data_dir);
Output_gzdir.c:257:      E->output.gzdir.vtk_fp = output_open(message,"w");
Output_gzdir.c:259:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:271:      if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:273:		E->lmesh.nno * E->parallel.nproc);
Output_gzdir.c:275:	sprintf(message,"POINTS %i float\n", E->lmesh.nno);
Output_gzdir.c:279:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:285:      for(i=1;i <= E->lmesh.nno;i++) {
Output_gzdir.c:287:        x[0]=E->x[1][i];x[1]=E->x[2][i];x[2]=E->x[3][i];
Output_gzdir.c:292:    if(E->output.gzdir.vtk_io == 2){ /* serial output, close and have
Output_gzdir.c:295:      if(E->parallel.me <  E->parallel.nproc-1){/* send to next if not last*/
Output_gzdir.c:296:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:303:    if((E->output.gzdir.vtk_io == 3) || (E->parallel.me == 0)){ /* in first CPU, or parallel output */
Output_gzdir.c:304:      if(E->output.gzdir.vtk_io == 2){ /* need to reopen, serial */
Output_gzdir.c:306:	j = E->parallel.nproc * E->lmesh.nel; /* total number of elements */
Output_gzdir.c:308:	j = E->lmesh.nel;
Output_gzdir.c:314:	      j,j*(enodes[E->mesh.nsd]+1));
Output_gzdir.c:318:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:324:    if(enodes[E->mesh.nsd] != 8)
Output_gzdir.c:326:    if(E->output.gzdir.vtk_io == 2){ /* serial, global node numbers */
Output_gzdir.c:327:      offset = E->lmesh.nno * E->parallel.me - 1;
Output_gzdir.c:331:    ix[0] = enodes[E->mesh.nsd];
Output_gzdir.c:332:      for(i=1;i <= E->lmesh.nel;i++) {
Output_gzdir.c:337:	ix[1]= E->ien[i].node[1]+offset;ix[2] = E->ien[i].node[2]+offset;
Output_gzdir.c:338:	ix[3]= E->ien[i].node[3]+offset;ix[4] = E->ien[i].node[4]+offset;
Output_gzdir.c:339:	ix[5]= E->ien[i].node[5]+offset;ix[6] = E->ien[i].node[6]+offset;
Output_gzdir.c:340:	ix[7]= E->ien[i].node[7]+offset;ix[8] = E->ien[i].node[8]+offset;
Output_gzdir.c:344:    if(E->output.gzdir.vtk_io == 2){ /* serial IO */
Output_gzdir.c:346:      if(E->parallel.me <  E->parallel.nproc-1)
Output_gzdir.c:347:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:350:    if((E->output.gzdir.vtk_io==3) || (E->parallel.me == 0) ){
Output_gzdir.c:351:      if(E->output.gzdir.vtk_io == 2){ /* serial */
Output_gzdir.c:353:	j=E->parallel.nproc*E->lmesh.nel;
Output_gzdir.c:355:	j = E->lmesh.nel;
Output_gzdir.c:363:      if(E->parallel.me == 0)
Output_gzdir.c:377:	   E->control.data_dir,E->parallel.me);
Output_gzdir.c:381:      gzprintf(gz1,"%7d\n",E->lmesh.nno);
Output_gzdir.c:382:      for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:384:                 E->sx[1][i],E->sx[2][i],E->sx[3][i]);
Output_gzdir.c:387:    if(E->output.gzdir.vtk_io == 1){
Output_gzdir.c:398:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:400:      for(i=1;i <= E->lmesh.nno;i++) {
Output_gzdir.c:402:           E->x[1][i],E->x[2][i],E->x[3][i]);
Output_gzdir.c:408:      offset = E->lmesh.nno * E->parallel.me - 1;
Output_gzdir.c:410:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:412:	for(i=1;i <= E->lmesh.nel;i++) {
Output_gzdir.c:413:	  gzprintf(gz1,"%2i\t",enodes[E->mesh.nsd]);
Output_gzdir.c:414:	  if(enodes[E->mesh.nsd] != 8){
Output_gzdir.c:423:		   E->ien[i].node[1]+offset,E->ien[i].node[2]+offset,
Output_gzdir.c:424:		   E->ien[i].node[3]+offset,E->ien[i].node[4]+offset,
Output_gzdir.c:425:		   E->ien[i].node[5]+offset,E->ien[i].node[6]+offset,
Output_gzdir.c:426:		   E->ien[i].node[7]+offset,E->ien[i].node[8]+offset);
Output_gzdir.c:455:  if(E->output.gzdir.vtk_io){	/* all VTK modes need basis vectors */
Output_gzdir.c:456:    os = E->lmesh.nno*9;
Output_gzdir.c:457:    if((!E->output.gzdir.vtk_base_init) ||(!E->output.gzdir.vtk_base_save)){
Output_gzdir.c:459:      if(!E->output.gzdir.vtk_base_init) /* init space */
Output_gzdir.c:460:	E->output.gzdir.vtk_base = (float *)safe_malloc(sizeof(float)*os);
Output_gzdir.c:463:      for(i=1;i <= E->lmesh.nno;i++,k += 9){
Output_gzdir.c:465:        calc_cbase_at_node(i,(E->output.gzdir.vtk_base+k),E);
Output_gzdir.c:467:      E->output.gzdir.vtk_base_init = 1;
Output_gzdir.c:471:  if(E->output.gzdir.rnr){	/* remove the whole model net rotation */
Output_gzdir.c:472:    if((E->control.remove_rigid_rotation || E->control.remove_angular_momentum) &&
Output_gzdir.c:473:       (E->parallel.me == 0))	/* that's not too terrible but wastes time */
Output_gzdir.c:476:    if(E->parallel.me == 0)
Output_gzdir.c:480:  if((E->output.gzdir.vtk_io == 2) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:486:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:489:    E->output.gzdir.vtk_ocount++; /* regular output file name */
Output_gzdir.c:497:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:502:      if(E->parallel.me == 0){
Output_gzdir.c:504:	fprintf(E->output.gzdir.vtk_fp,"%12i %12i %12.6e %s\n",
Output_gzdir.c:505:		E->output.gzdir.vtk_ocount,cycles,E->monitor.elapsed_time,output_file);
Output_gzdir.c:508:      if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:509:	sprintf(message,"POINT_DATA %i\n",E->lmesh.nno*E->parallel.nproc);
Output_gzdir.c:511:	sprintf(message,"POINT_DATA %i\n",E->lmesh.nno);
Output_gzdir.c:517:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 7, E->parallel.world, &mpi_stat);
Output_gzdir.c:521:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:522:        cvec[0] = E->T[i];
Output_gzdir.c:526:    if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:528:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:529:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 7, E->parallel.world);
Output_gzdir.c:531:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, 0, 6, E->parallel.world); /* tell m=0 to go ahead */
Output_gzdir.c:537:    if((E->output.gzdir.vtk_io == 3) || (E->parallel.me == 0)){
Output_gzdir.c:538:      if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:539:	mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, E->parallel.nproc-1 , 6, E->parallel.world, &mpi_stat);
Output_gzdir.c:544:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 5, E->parallel.world, &mpi_stat);
Output_gzdir.c:548:      if(E->output.gzdir.rnr){
Output_gzdir.c:550:	for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:551:	  vcorr[0] = E->sphere.cap.V[1][i]; /* vtheta */
Output_gzdir.c:552:	  vcorr[1] = E->sphere.cap.V[2][i]; /* vphi */
Output_gzdir.c:556:	  sub_netr(E->sx[3][i],E->sx[1][i],E->sx[2][i],(vcorr+0),(vcorr+1),omega);
Output_gzdir.c:558:	  convert_pvec_to_cvec(E->sphere.cap.V[3][i],vcorr[0],vcorr[1],
Output_gzdir.c:559:			       (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:565:	for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:566:	  convert_pvec_to_cvec(E->sphere.cap.V[3][i],E->sphere.cap.V[1][i],E->sphere.cap.V[2][i],
Output_gzdir.c:567:			       (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:573:    if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:574:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:575:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 5, E->parallel.world);
Output_gzdir.c:580:      if(E->parallel.me == 0)
Output_gzdir.c:599:    if(E->output.gzdir.vtk_io == 1) {
Output_gzdir.c:604:	       E->control.data_dir,
Output_gzdir.c:605:	       cycles,E->parallel.me,cycles);
Output_gzdir.c:608:	       E->control.data_dir,cycles,
Output_gzdir.c:609:	       E->parallel.me,cycles);
Output_gzdir.c:615:	     cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:616:      gzprintf(gzout,"%7d\n",E->lmesh.nno);
Output_gzdir.c:617:      if(E->output.gzdir.vtk_io){
Output_gzdir.c:619:	for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:620:	  gzprintf(gzout,"%.6e\n",E->T[i]);
Output_gzdir.c:623:	if(E->output.gzdir.rnr){
Output_gzdir.c:625:	  for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:626:	    vcorr[0] = E->sphere.cap.V[1][i]; /* vt */
Output_gzdir.c:627:	    vcorr[1] = E->sphere.cap.V[2][i]; /* vphi */
Output_gzdir.c:628:	    sub_netr(E->sx[3][i],E->sx[1][i],E->sx[2][i],(vcorr+0),(vcorr+1),omega);
Output_gzdir.c:631:		     E->sphere.cap.V[3][i],E->T[i]);
Output_gzdir.c:635:	  for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:637:		     E->sphere.cap.V[1][i],
Output_gzdir.c:638:		     E->sphere.cap.V[2][i],
Output_gzdir.c:639:		     E->sphere.cap.V[3][i],E->T[i]);
Output_gzdir.c:643:    if(E->output.gzdir.vtk_io){
Output_gzdir.c:648:	       E->control.data_dir,cycles,E->parallel.me,cycles);
Output_gzdir.c:651:      if(E->output.gzdir.rnr){
Output_gzdir.c:653:          for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:654:            vcorr[0] = E->sphere.cap.V[1][i];
Output_gzdir.c:655:            vcorr[1] = E->sphere.cap.V[2][i];
Output_gzdir.c:656:            sub_netr(E->sx[3][i],E->sx[1][i],E->sx[2][i],
Output_gzdir.c:658:            convert_pvec_to_cvec(E->sphere.cap.V[3][i],vcorr[0],vcorr[1],
Output_gzdir.c:659:                                 (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:664:        for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:666:          convert_pvec_to_cvec(E->sphere.cap.V[3][i],
Output_gzdir.c:667:             E->sphere.cap.V[1][i],
Output_gzdir.c:668:             E->sphere.cap.V[2][i],
Output_gzdir.c:669:             (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:679:  if(E->output.gzdir.vtk_io){	/* all VTK modes */
Output_gzdir.c:681:    if(!E->output.gzdir.vtk_base_save)
Output_gzdir.c:682:      free(E->output.gzdir.vtk_base);
Output_gzdir.c:696:  int lev = E->mesh.levmax;
Output_gzdir.c:704:  if(E->output.gzdir.vtk_io < 2){
Output_gzdir.c:706:	     "%s/%d/visc.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:707:	     cycles,E->parallel.me, cycles);
Output_gzdir.c:709:      gzprintf(gz1,"%7d\n",E->lmesh.nno);
Output_gzdir.c:710:      for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:711:        gzprintf(gz1,"%.4e\n",E->VI[lev][i]);
Output_gzdir.c:715:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:719:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:725:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:729:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:730:        ftmp = log10(E->VI[lev][i]);
Output_gzdir.c:736:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:737:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:738:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:754:  int lev = E->mesh.levmax;
Output_gzdir.c:760:  if(E->viscosity.allow_anisotropic_viscosity){
Output_gzdir.c:762:    if(E->output.gzdir.vtk_io < 2){
Output_gzdir.c:764:	       "%s/%d/avisc.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:765:	       cycles,E->parallel.me, cycles);
Output_gzdir.c:767:	gzprintf(gz1,"%7d\n",E->lmesh.nno);
Output_gzdir.c:768:	for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:769:	  gzprintf(gz1,"%.4e %.4e %.4e %.4e\n",E->VI2[lev][i],E->VIn1[lev][i],E->VIn2[lev][i],E->VIn3[lev][i]);
Output_gzdir.c:773:      if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:777:      if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:783:	mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:787:	for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:788:	  ftmp = E->VI2[lev][i];
Output_gzdir.c:793:      if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:794:	if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:795:	  mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:810:  if((E->output.write_q_files == 0) || (cycles == 0) ||
Output_gzdir.c:811:     (cycles % E->output.write_q_files)!=0)
Output_gzdir.c:815:  if(E->control.use_cbf_topo){
Output_gzdir.c:816:    get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Output_gzdir.c:818:    get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Output_gzdir.c:822:  if (E->output.surf && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) {
Output_gzdir.c:823:    snprintf(output_file,255,"%s/%d/surf.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:824:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:828:    if(E->control.pseudo_free_surf)
Output_gzdir.c:829:        topo = E->slice.freesurf;
Output_gzdir.c:831:        topo = E->slice.tpg;
Output_gzdir.c:833:    gzprintf(fp2,"%7d\n",E->lmesh.nsf);
Output_gzdir.c:834:    for(i=1;i<=E->lmesh.nsf;i++)   {
Output_gzdir.c:835:      s = i*E->lmesh.noz;
Output_gzdir.c:837:      topo[i],E->slice.shflux[i],E->sphere.cap.V[1][s],E->sphere.cap.V[2][s]);
Output_gzdir.c:843:  if (E->output.botm && (E->parallel.me_loc[3]==0)) {
Output_gzdir.c:844:    snprintf(output_file,255,"%s/%d/botm.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:845:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:848:      gzprintf(fp2,"%7d\n",E->lmesh.nsf);
Output_gzdir.c:849:      for(i=1;i<=E->lmesh.nsf;i++)  {
Output_gzdir.c:850:        s = (i-1)*E->lmesh.noz + 1;
Output_gzdir.c:852:		                  E->slice.tpgb[i],
Output_gzdir.c:853:                      E->slice.bhflux[i],
Output_gzdir.c:854:                      E->sphere.cap.V[1][s],
Output_gzdir.c:855:                      E->sphere.cap.V[2][s]);
Output_gzdir.c:870:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Output_gzdir.c:872:		 "%s/%d/geoid.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:873:		cycles,E->parallel.me, cycles);
Output_gzdir.c:877:        gzprintf(fp1, "%d %d %.5e\n", cycles, E->output.llmax,
Output_gzdir.c:878:                E->monitor.elapsed_time);
Output_gzdir.c:881:        for (ll=0; ll<=E->output.llmax; ll++)
Output_gzdir.c:883:                p = E->sphere.hindex[ll][mm];
Output_gzdir.c:886:                        E->sphere.harm_geoid[0][p],
Output_gzdir.c:887:                        E->sphere.harm_geoid[1][p],
Output_gzdir.c:888:                        E->sphere.harm_geoid_from_tpgt[0][p],
Output_gzdir.c:889:                        E->sphere.harm_geoid_from_tpgt[1][p],
Output_gzdir.c:890:                        E->sphere.harm_geoid_from_bncy[0][p],
Output_gzdir.c:891:                        E->sphere.harm_geoid_from_bncy[1][p]);
Output_gzdir.c:913:  if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output_gzdir.c:919:  snprintf(output_file,255,"%s/%d/stress.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:920:	  cycles,E->parallel.me, cycles);
Output_gzdir.c:923:  gzprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:925:  gzprintf(fp1,"%7d\n",E->lmesh.nno);
Output_gzdir.c:926:  for (node=1;node<=E->lmesh.nno;node++)
Output_gzdir.c:928:            E->gstress[(node-1)*6+1], /*  stt */
Output_gzdir.c:929:            E->gstress[(node-1)*6+2], /*  spp */
Output_gzdir.c:930:            E->gstress[(node-1)*6+3], /*  srr */
Output_gzdir.c:931:            E->gstress[(node-1)*6+4], /*  stp */
Output_gzdir.c:932:            E->gstress[(node-1)*6+5], /*  str */
Output_gzdir.c:933:            E->gstress[(node-1)*6+6]); /* srp */
Output_gzdir.c:952:  if (E->parallel.me<E->parallel.nprocz)  {
Output_gzdir.c:953:    snprintf(output_file,255,"%s/%d/horiz_avg.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:954:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:956:    for(j=1;j<=E->lmesh.noz;j++)  { /* format: r <T> <vh> <vr> (<C>) */
Output_gzdir.c:957:        gzprintf(fp1,"%.4e %.4e %.4e %.4e",E->sx[3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]);
Output_gzdir.c:959:        if (E->composition.on) {
Output_gzdir.c:961:            for(n=0; n<E->composition.ncomp; n++)
Output_gzdir.c:962:                gzprintf(fp1," %.4e", E->Have.C[n][j]);
Output_gzdir.c:978:  snprintf(output_file,255,"%s/mat.%d.gz", E->control.data_dir,E->parallel.me);
Output_gzdir.c:981:  for(el=1;el<=E->lmesh.nel;el++)
Output_gzdir.c:982:    gzprintf(fp,"%d %d %f\n", el,E->mat[el],E->VIP[el]);
Output_gzdir.c:999:  if(E->output.gzdir.vtk_io < 2){ /* old */
Output_gzdir.c:1000:    snprintf(output_file,255,"%s/%d/pressure.%d.%d.gz", E->control.data_dir,cycles,
Output_gzdir.c:1001:	     E->parallel.me, cycles);
Output_gzdir.c:1003:    gzprintf(gz1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:1004:    gzprintf(gz1,"%7d\n",E->lmesh.nno);
Output_gzdir.c:1005:    for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:1006:      gzprintf(gz1,"%.6e\n",E->NP[i]);
Output_gzdir.c:1009:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:1012:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:1017:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:1020:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:1021:        ftmp = E->NP[i];
Output_gzdir.c:1026:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:1027:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:1028:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:1040:	   E->control.data_dir,cycles,
Output_gzdir.c:1041:	   E->parallel.me, cycles);
Output_gzdir.c:1044:  ncolumns = 3 + E->trace.number_of_extra_quantities;
Output_gzdir.c:1046:      gzprintf(fp1,"%d %d %d %.5e\n", cycles, E->trace.ntracers,
Output_gzdir.c:1047:              ncolumns, E->monitor.elapsed_time);
Output_gzdir.c:1049:      for(n=1;n<=E->trace.ntracers;n++) {
Output_gzdir.c:1052:                  E->trace.basicq[0][n],
Output_gzdir.c:1053:                  E->trace.basicq[1][n],
Output_gzdir.c:1054:                  E->trace.basicq[2][n]);
Output_gzdir.c:1057:          for (i=0; i<E->trace.number_of_extra_quantities; i++) {
Output_gzdir.c:1058:              gzprintf(fp1," %9.5e", E->trace.extraq[i][n]);
Output_gzdir.c:1078:  if(E->output.gzdir.vtk_io < 2){
Output_gzdir.c:1080:	     E->control.data_dir,cycles,
Output_gzdir.c:1081:	     E->parallel.me, cycles);
Output_gzdir.c:1084:	       E->lmesh.nel,
Output_gzdir.c:1085:	       E->monitor.elapsed_time,
Output_gzdir.c:1086:	       E->composition.initial_bulk_composition,
Output_gzdir.c:1087:	       E->composition.bulk_composition);
Output_gzdir.c:1088:      for(i=1;i<=E->lmesh.nno;i++) {
Output_gzdir.c:1089:	for(k=0;k < E->composition.ncomp;k++)
Output_gzdir.c:1090:	  gzprintf(gz1,"%.6e ",E->composition.comp_node[k][i]);
Output_gzdir.c:1095:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:1098:    if((E->output.gzdir.vtk_io==3) || (E->parallel.me == 0)){
Output_gzdir.c:1100:      if(E->composition.ncomp > 4)
Output_gzdir.c:1102:      sprintf(message,"SCALARS composition float %d\n",E->composition.ncomp);
Output_gzdir.c:1106:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:1109:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:1110:        for(k=0;k<E->composition.ncomp;k++){
Output_gzdir.c:1111:          ftmp = E->composition.comp_node[k][i];
Output_gzdir.c:1117:    if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:1118:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:1119:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:1130:    snprintf(output_file,255,"%s/%d/comp_el.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:1131:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:1135:                E->lmesh.nel,
Output_gzdir.c:1136:                E->monitor.elapsed_time,
Output_gzdir.c:1137:                E->composition.initial_bulk_composition,
Output_gzdir.c:1138:                E->composition.bulk_composition);
Output_gzdir.c:1140:        for(i=1;i<=E->lmesh.nel;i++) {
Output_gzdir.c:1141:          for(k=0;k<E->composition.ncomp;k++)
Output_gzdir.c:1142:            gzprintf(fp1,"%.6e ",E->composition.comp_el[k][i]);
Output_gzdir.c:1155:    snprintf(output_file,255,"%s/%d/heating.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:1156:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:1159:    gzprintf(fp1,"%.5e\n",E->monitor.elapsed_time);
Output_gzdir.c:1161:        gzprintf(fp1,"%7d\n", E->lmesh.nel);
Output_gzdir.c:1162:        for(e=1; e<=E->lmesh.nel; e++)
Output_gzdir.c:1163:            gzprintf(fp1, "%.4e %.4e %.4e\n", E->heating_adi[e],
Output_gzdir.c:1164:                      E->heating_visc[e], E->heating_latent[e]);
Output_gzdir.c:1184:  ii = E->monitor.solution_cycles_init;
Output_gzdir.c:1185:  switch(E->output.gzdir.vtk_io){
Output_gzdir.c:1193:	     E->control.data_dir_old,
Output_gzdir.c:1194:	     ii,E->parallel.me,ii);
Output_gzdir.c:1198:	     E->control.data_dir_old,ii,
Output_gzdir.c:1199:	     E->parallel.me,ii);
Output_gzdir.c:1204:  if (E->parallel.me==0){
Output_gzdir.c:1207:    fprintf(E->fp,"restart_tic_from_gzdir_file: using  %s for restarted temperature\n",
Output_gzdir.c:1212:  if(mm != E->lmesh.nno){
Output_gzdir.c:1213:    fprintf(stderr,"%i %i\n",mm, E->lmesh.nno);
Output_gzdir.c:1217:  switch(E->output.gzdir.vtk_io) {
Output_gzdir.c:1221:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:1228:	E->T[i] = g;
Output_gzdir.c:1233:      for(i=1;i<=E->lmesh.nno;i++)  {
Output_gzdir.c:1236:	/*  E->sphere.cap.V[1][i] = v1;
Output_gzdir.c:1237:	    E->sphere.cap.V[1][i] = v2;
Output_gzdir.c:1238:	    E->sphere.cap.V[1][i] = v3;  */
Output_gzdir.c:1240:	//E->T[i] = max(0.0,min(g,1.0));
Output_gzdir.c:1241:	E->T[i] = g;
Output_gzdir.c:1319:  if(E->output.gzdir.vtk_io == 2){ /* serial */
Output_gzdir.c:1322:	       E->control.data_dir);
Output_gzdir.c:1325:	       E->control.data_dir, E->output.gzdir.vtk_ocount);
Output_gzdir.c:1329:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:1332:	       E->control.data_dir,cycles,
Output_gzdir.c:1333:	       E->output.gzdir.vtk_ocount,
Output_gzdir.c:1334:	       E->parallel.me);
Output_h5.c:163:    int nprocx = E->parallel.nprocx;
Output_h5.c:164:    int nprocy = E->parallel.nprocy;
Output_h5.c:165:    int nprocz = E->parallel.nprocz;
Output_h5.c:168:    E->hdf5.cap = (E->parallel.me) / (nprocx * nprocy * nprocz);
Output_h5.c:191:    if (E->output.stress == 1)
Output_h5.c:192:        E->hdf5.data = (float *)malloc((tensor3d->n) * sizeof(float));
Output_h5.c:194:        E->hdf5.data = (float *)malloc((vector3d->n) * sizeof(float));
Output_h5.c:197:    tensor3d->data = E->hdf5.data;
Output_h5.c:198:    vector3d->data = E->hdf5.data;
Output_h5.c:199:    vector2d->data = E->hdf5.data;
Output_h5.c:200:    scalar3d->data = E->hdf5.data;
Output_h5.c:201:    scalar2d->data = E->hdf5.data;
Output_h5.c:202:    scalar1d->data = E->hdf5.data;
Output_h5.c:204:    E->hdf5.tensor3d = tensor3d;
Output_h5.c:205:    E->hdf5.vector3d = vector3d;
Output_h5.c:206:    E->hdf5.vector2d = vector2d;
Output_h5.c:207:    E->hdf5.scalar3d = scalar3d;
Output_h5.c:208:    E->hdf5.scalar2d = scalar2d;
Output_h5.c:209:    E->hdf5.scalar1d = scalar1d;
Output_h5.c:218: * These represent possible choices for (E->output) function pointer.       *
Output_h5.c:224:    if(E->parallel.me == 0)
Output_h5.c:233:        if (E->output.coord_bin)
Output_h5.c:249:    int m = E->parallel.me;
Output_h5.c:253:    input_int("cb_block_size", &(E->output.cb_block_size), "1048576", m);
Output_h5.c:254:    input_int("cb_buffer_size", &(E->output.cb_buffer_size), "4194304", m);
Output_h5.c:256:    input_int("sieve_buf_size", &(E->output.sieve_buf_size), "1048576", m);
Output_h5.c:258:    input_int("output_alignment", &(E->output.alignment), "262144", m);
Output_h5.c:259:    input_int("output_alignment_threshold", &(E->output.alignment_threshold), "524288", m);
Output_h5.c:261:    input_int("cache_mdc_nelmts", &(E->output.cache_mdc_nelmts), "10330", m);
Output_h5.c:262:    input_int("cache_rdcc_nelmts", &(E->output.cache_rdcc_nelmts), "521", m);
Output_h5.c:263:    input_int("cache_rdcc_nbytes", &(E->output.cache_rdcc_nbytes), "1048576", m);
Output_h5.c:276:    snprintf(filename, (size_t)100, "%s.h5", E->control.data_file);
Output_h5.c:294:             E->control.data_file, cycles);
Output_h5.c:306:    if(E->control.tracer == 1)
Output_h5.c:310:    if(E->output.geoid == 1)
Output_h5.c:313:    if(E->output.stress == 1){
Output_h5.c:316:    if(E->output.pressure == 1)
Output_h5.c:319:    if (E->output.horiz_avg == 1)
Output_h5.c:340:    MPI_Comm comm = E->parallel.world;
Output_h5.c:372:    snprintf(tmp, (size_t)100, "%d", E->output.cb_block_size);
Output_h5.c:374:    snprintf(tmp, (size_t)100, "%d", E->output.cb_buffer_size);
Output_h5.c:380:    status = H5Pset_sieve_buf_size(fapl_id, (size_t)(E->output.sieve_buf_size));
Output_h5.c:381:    status = H5Pset_alignment(fapl_id, (hsize_t)(E->output.alignment_threshold),
Output_h5.c:382:                                       (hsize_t)(E->output.alignment));
Output_h5.c:383:    status = H5Pset_cache(fapl_id, E->output.cache_mdc_nelmts,
Output_h5.c:384:                                   (size_t)(E->output.cache_rdcc_nelmts),
Output_h5.c:385:                                   (size_t)(E->output.cache_rdcc_nbytes),
Output_h5.c:399:    E->hdf5.file_id = file_id;
Output_h5.c:411:    status = H5Fclose(E->hdf5.file_id);
Output_h5.c:435:    field = E->hdf5.vector3d;
Output_h5.c:437:    nx = E->lmesh.nox;
Output_h5.c:438:    ny = E->lmesh.noy;
Output_h5.c:439:    nz = E->lmesh.noz;
Output_h5.c:454:                field->data[3*m+0] = E->sx[1][n+1];
Output_h5.c:455:                field->data[3*m+1] = E->sx[2][n+1];
Output_h5.c:456:                field->data[3*m+2] = E->sx[3][n+1];
Output_h5.c:461:    h5create_field(E->hdf5.file_id, field, "coord", "coordinates of nodes");
Output_h5.c:464:    dataset = H5Dopen(E->hdf5.file_id, "/coord");
Output_h5.c:481:    field = E->hdf5.vector3d;
Output_h5.c:483:    nx = E->lmesh.nox;
Output_h5.c:484:    ny = E->lmesh.noy;
Output_h5.c:485:    nz = E->lmesh.noz;
Output_h5.c:500:                field->data[3*m+0] = E->sphere.cap.V[1][n+1];
Output_h5.c:501:                field->data[3*m+1] = E->sphere.cap.V[2][n+1];
Output_h5.c:502:                field->data[3*m+2] = E->sphere.cap.V[3][n+1];
Output_h5.c:507:    h5create_field(E->hdf5.file_id, field, "velocity", "velocity values on nodes");
Output_h5.c:510:    dataset = H5Dopen(E->hdf5.file_id, "/velocity");
Output_h5.c:527:    field = E->hdf5.scalar3d;
Output_h5.c:529:    nx = E->lmesh.nox;
Output_h5.c:530:    ny = E->lmesh.noy;
Output_h5.c:531:    nz = E->lmesh.noz;
Output_h5.c:546:                field->data[m] = E->T[n+1];
Output_h5.c:551:    h5create_field(E->hdf5.file_id, field, "temperature", "temperature values on nodes");
Output_h5.c:553:    dataset = H5Dopen(E->hdf5.file_id, "/temperature");
Output_h5.c:571:    field = E->hdf5.scalar3d;
Output_h5.c:573:    lev = E->mesh.levmax;
Output_h5.c:575:    nx = E->lmesh.nox;
Output_h5.c:576:    ny = E->lmesh.noy;
Output_h5.c:577:    nz = E->lmesh.noz;
Output_h5.c:592:                field->data[m] = E->VI[lev][n+1];
Output_h5.c:597:    h5create_field(E->hdf5.file_id, field, "viscosity", "viscosity values on nodes");
Output_h5.c:599:    dataset = H5Dopen(E->hdf5.file_id, "/viscosity");
Output_h5.c:616:    field = E->hdf5.scalar3d;
Output_h5.c:618:    nx = E->lmesh.nox;
Output_h5.c:619:    ny = E->lmesh.noy;
Output_h5.c:620:    nz = E->lmesh.noz;
Output_h5.c:635:                field->data[m] = E->NP[n+1];
Output_h5.c:641:    h5create_field(E->hdf5.file_id, field, "pressure", "pressure values on nodes");
Output_h5.c:644:    dataset = H5Dopen(E->hdf5.file_id, "/pressure");
Output_h5.c:668:    if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output_h5.c:674:    field = E->hdf5.tensor3d;
Output_h5.c:676:    nx = E->lmesh.nox;
Output_h5.c:677:    ny = E->lmesh.noy;
Output_h5.c:678:    nz = E->lmesh.noz;
Output_h5.c:693:                field->data[6*m+0] = E->gstress[6*n+1];
Output_h5.c:694:                field->data[6*m+1] = E->gstress[6*n+2];
Output_h5.c:695:                field->data[6*m+2] = E->gstress[6*n+3];
Output_h5.c:696:                field->data[6*m+3] = E->gstress[6*n+4];
Output_h5.c:697:                field->data[6*m+4] = E->gstress[6*n+5];
Output_h5.c:698:                field->data[6*m+5] = E->gstress[6*n+6];
Output_h5.c:704:    h5create_field(E->hdf5.file_id, field, "stress", "stress values on nodes");
Output_h5.c:707:    dataset = H5Dopen(E->hdf5.file_id, "/stress");
Output_h5.c:736:    int pz = E->parallel.me_loc[3];
Output_h5.c:737:    int nprocz = E->parallel.nprocz;
Output_h5.c:739:    field = E->hdf5.vector2d;
Output_h5.c:741:    nx = E->lmesh.nox;
Output_h5.c:742:    ny = E->lmesh.noy;
Output_h5.c:743:    nz = E->lmesh.noz;
Output_h5.c:748:    if (E->output.surf == 1)
Output_h5.c:757:                field->data[2*m+0] = E->sx[1][n+1];
Output_h5.c:758:                field->data[2*m+1] = E->sx[2][n+1];
Output_h5.c:761:        dataset = H5Dopen(E->hdf5.file_id, "/surf/coord");
Output_h5.c:766:    if (E->output.botm == 1)
Output_h5.c:775:                field->data[2*m+0] = E->sx[1][n+1];
Output_h5.c:776:                field->data[2*m+1] = E->sx[2][n+1];
Output_h5.c:779:        dataset = H5Dopen(E->hdf5.file_id, "/botm/coord");
Output_h5.c:801:    int pz = E->parallel.me_loc[3];
Output_h5.c:802:    int nprocz = E->parallel.nprocz;
Output_h5.c:804:    file_id = E->hdf5.file_id;
Output_h5.c:806:    scalar = E->hdf5.scalar2d;
Output_h5.c:807:    vector = E->hdf5.vector2d;
Output_h5.c:809:    nx = E->lmesh.nox;
Output_h5.c:810:    ny = E->lmesh.noy;
Output_h5.c:811:    nz = E->lmesh.noz;
Output_h5.c:816:    if((E->output.write_q_files == 0) || (cycles == 0) ||
Output_h5.c:817:       (cycles % E->output.write_q_files)!=0)
Output_h5.c:823:    if(E->control.use_cbf_topo){
Output_h5.c:824:      get_CBF_topo(E, E->slice.tpg, E->slice.tpgb);
Output_h5.c:826:      get_STD_topo(E, E->slice.tpg, E->slice.tpgb, E->slice.divg, E->slice.vort, cycles);
Output_h5.c:832:    if (E->output.surf == 1)
Output_h5.c:836:        h5create_field(surf_group, E->hdf5.vector2d, "velocity",
Output_h5.c:838:        h5create_field(surf_group, E->hdf5.scalar2d, "heatflux",
Output_h5.c:840:        h5create_field(surf_group, E->hdf5.scalar2d, "topography",
Output_h5.c:854:                vector->data[2*m+0] = E->sphere.cap.V[1][n+1];
Output_h5.c:855:                vector->data[2*m+1] = E->sphere.cap.V[2][n+1];
Output_h5.c:869:                scalar->data[m] = E->slice.shflux[n+1];
Output_h5.c:878:        if (E->control.pseudo_free_surf)
Output_h5.c:879:            topo = E->slice.freesurf;
Output_h5.c:881:            topo = E->slice.tpg;
Output_h5.c:902:    if (E->output.botm == 1)
Output_h5.c:906:        h5create_field(botm_group, E->hdf5.vector2d, "velocity",
Output_h5.c:908:        h5create_field(botm_group, E->hdf5.scalar2d, "heatflux",
Output_h5.c:910:        h5create_field(botm_group, E->hdf5.scalar2d, "topography",
Output_h5.c:924:                vector->data[2*m+0] = E->sphere.cap.V[1][n+1];
Output_h5.c:925:                vector->data[2*m+1] = E->sphere.cap.V[2][n+1];
Output_h5.c:939:                scalar->data[m] = E->slice.bhflux[n+1];
Output_h5.c:947:        topo = E->slice.tpg;
Output_h5.c:979:    int px = E->parallel.me_loc[1];
Output_h5.c:980:    int py = E->parallel.me_loc[2];
Output_h5.c:982:    field = E->hdf5.scalar1d;
Output_h5.c:986:    if (E->output.horiz_avg == 1)
Output_h5.c:989:            field->data[k] = E->sx[3][k+1];
Output_h5.c:990:        dataset = H5Dopen(E->hdf5.file_id, "/horiz_avg/coord");
Output_h5.c:1012:    int px = E->parallel.me_loc[1];
Output_h5.c:1013:    int py = E->parallel.me_loc[2];
Output_h5.c:1016:    file_id = E->hdf5.file_id;
Output_h5.c:1018:    field = E->hdf5.scalar1d;
Output_h5.c:1027:    h5create_field(avg_group, E->hdf5.scalar1d, "temperature",
Output_h5.c:1029:    h5create_field(avg_group, E->hdf5.scalar1d, "velocity_xy",
Output_h5.c:1031:    h5create_field(avg_group, E->hdf5.scalar1d, "velocity_z",
Output_h5.c:1041:        field->data[k] = E->Have.T[k+1];
Output_h5.c:1048:        field->data[k] = E->Have.V[1][k+1];
Output_h5.c:1055:        field->data[k] = E->Have.V[2][k+1];
Output_h5.c:1087:    hsize_t dim = E->sphere.hindice;
Output_h5.c:1119:    dataset = H5Dcreate(E->hdf5.file_id, "geoid", datatype,
Output_h5.c:1157:    if (E->parallel.me == 0) {
Output_h5.c:1159:        row = (struct HDF5_GEOID *) malloc((E->sphere.hindice)
Output_h5.c:1162:        for(ll = 0; ll <= E->output.llmax; ll++)
Output_h5.c:1166:                row[i].total_sin = E->sphere.harm_geoid[0][i];
Output_h5.c:1167:                row[i].total_cos = E->sphere.harm_geoid[1][i];
Output_h5.c:1168:                row[i].tpgt_sin = E->sphere.harm_geoid_from_tpgt[0][i];
Output_h5.c:1169:                row[i].tpgt_cos = E->sphere.harm_geoid_from_tpgt[1][i];
Output_h5.c:1170:                row[i].bncy_sin = E->sphere.harm_geoid_from_bncy[0][i];
Output_h5.c:1171:                row[i].bncy_cos = E->sphere.harm_geoid_from_bncy[1][i];
Output_h5.c:1237:    int px = E->parallel.me_loc[1];
Output_h5.c:1238:    int py = E->parallel.me_loc[2];
Output_h5.c:1239:    int pz = E->parallel.me_loc[3];
Output_h5.c:1240:    int nprocx = E->parallel.nprocx;
Output_h5.c:1241:    int nprocy = E->parallel.nprocy;
Output_h5.c:1242:    int nprocz = E->parallel.nprocz;
Output_h5.c:1246:    int nel = E->lmesh.nel;
Output_h5.c:1251:    if (E->output.connectivity == 1)
Output_h5.c:1277:            ien = E->ien[e+1].node;
Output_h5.c:1289:        h5create_connectivity(E->hdf5.file_id, E->lmesh.nel * procs_per_cap);
Output_h5.c:1291:        dataset = H5Dopen(E->hdf5.file_id, "/connectivity");
Output_h5.c:1295:                                 0, (E->hdf5.cap == 0));
Output_h5.c:1314:    root = H5Gopen(E->hdf5.file_id, "/");
Output_h5.c:1315:    status = set_attribute_float(root, "time", E->monitor.elapsed_time);
Output_h5.c:1337:    input = h5create_group(E->hdf5.file_id, "input", (size_t)0);
Output_h5.c:1339:    status = set_attribute_int(input, "PID", E->control.PID);
Output_h5.c:1345:    status = set_attribute_int(input, "ADV", E->advection.ADVECTION);
Output_h5.c:1346:    status = set_attribute_int(input, "filter_temp", E->advection.filter_temperature);
Output_h5.c:1348:    status = set_attribute_float(input, "finetunedt", E->advection.fine_tune_dt);
Output_h5.c:1349:    status = set_attribute_float(input, "fixed_timestep", E->advection.fixed_timestep);
Output_h5.c:1350:    status = set_attribute_float(input, "inputdiffusivity", E->control.inputdiff);
Output_h5.c:1352:    status = set_attribute_int(input, "adv_sub_iterations", E->advection.temp_iterations);
Output_h5.c:1359:    status = set_attribute_int(input, "side_sbcs", E->control.side_sbcs);
Output_h5.c:1360:    status = set_attribute_int(input, "pseudo_free_surf", E->control.pseudo_free_surf);
Output_h5.c:1362:    status = set_attribute_int(input, "topvbc", E->mesh.topvbc);
Output_h5.c:1363:    status = set_attribute_float(input, "topvbxval", E->control.VBXtopval);
Output_h5.c:1364:    status = set_attribute_float(input, "topvbyval", E->control.VBYtopval);
Output_h5.c:1367:    status = set_attribute_int(input, "botvbc", E->mesh.botvbc);
Output_h5.c:1368:    status = set_attribute_float(input, "botvbxval", E->control.VBXbotval);
Output_h5.c:1369:    status = set_attribute_float(input, "botvbyval", E->control.VBYbotval);
Output_h5.c:1371:    status = set_attribute_int(input, "toptbc", E->mesh.toptbc);
Output_h5.c:1372:    status = set_attribute_float(input, "toptbcval", E->control.TBCtopval);
Output_h5.c:1374:    status = set_attribute_int(input, "bottbc", E->mesh.bottbc);
Output_h5.c:1375:    status = set_attribute_float(input, "bottbcval", E->control.TBCbotval);
Output_h5.c:1377:    status = set_attribute_int(input, "temperature_bound_adj", E->control.temperature_bound_adj);
Output_h5.c:1378:    status = set_attribute_float(input, "depth_bound_adj", E->control.depth_bound_adj);
Output_h5.c:1379:    status = set_attribute_float(input, "width_bound_adj", E->control.width_bound_adj);
Output_h5.c:1385:    status = set_attribute_float(input, "density", E->data.density);
Output_h5.c:1386:    status = set_attribute_float(input, "thermdiff", E->data.therm_diff);
Output_h5.c:1387:    status = set_attribute_float(input, "gravacc", E->data.grav_acc);
Output_h5.c:1388:    status = set_attribute_float(input, "thermexp", E->data.therm_exp);
Output_h5.c:1389:    status = set_attribute_float(input, "refvisc", E->data.ref_viscosity);
Output_h5.c:1390:    status = set_attribute_float(input, "cp", E->data.Cp);
Output_h5.c:1391:    status = set_attribute_float(input, "density_above", E->data.density_above);
Output_h5.c:1392:    status = set_attribute_float(input, "density_below", E->data.density_below);
Output_h5.c:1394:    status = set_attribute_float(input, "z_lith", E->viscosity.zlith);
Output_h5.c:1395:    status = set_attribute_float(input, "z_410", E->viscosity.z410);
Output_h5.c:1396:    status = set_attribute_float(input, "z_lmantle", E->viscosity.zlm);
Output_h5.c:1397:    status = set_attribute_float(input, "z_cmb", E->viscosity.zcmb);
Output_h5.c:1399:    status = set_attribute_float(input, "radius_km", E->data.radius_km);
Output_h5.c:1400:    status = set_attribute_float(input, "scalev", E->data.scalev);
Output_h5.c:1401:    status = set_attribute_float(input, "scalet", E->data.scalet);
Output_h5.c:1407:    status = set_attribute_int(input, "restart", E->control.restart);
Output_h5.c:1408:    status = set_attribute_int(input, "post_p", E->control.post_p);
Output_h5.c:1409:    status = set_attribute_int(input, "solution_cycles_init", E->monitor.solution_cycles_init);
Output_h5.c:1410:    status = set_attribute_int(input, "zero_elapsed_time", E->control.zero_elapsed_time);
Output_h5.c:1412:    status = set_attribute_int(input, "tic_method", E->convection.tic_method);
Output_h5.c:1414:    n = E->convection.number_of_perturbations;
Output_h5.c:1416:    status = set_attribute_int_vector(input, "perturbl", n, E->convection.perturb_ll);
Output_h5.c:1417:    status = set_attribute_int_vector(input, "perturbm", n, E->convection.perturb_mm);
Output_h5.c:1418:    status = set_attribute_int_vector(input, "perturblayer", n, E->convection.load_depth);
Output_h5.c:1419:    status = set_attribute_float_vector(input, "perturbmag", n, E->convection.perturb_mag);
Output_h5.c:1421:    status = set_attribute_float(input, "half_space_age", E->convection.half_space_age);
Output_h5.c:1422:    status = set_attribute_float(input, "mantle_temp", E->control.mantle_temp);
Output_h5.c:1424:    if (E->convection.tic_method == 2)
Output_h5.c:1426:        status = set_attribute_float_vector(input, "blob_center", 3, E->convection.blob_center);
Output_h5.c:1427:        status = set_attribute_float(input, "blob_radius", E->convection.blob_radius);
Output_h5.c:1428:        status = set_attribute_float(input, "blob_dT", E->convection.blob_dT);
Output_h5.c:1435:    status = set_attribute_int(input, "file_vbcs", E->control.vbcs_file);
Output_h5.c:1436:    status = set_attribute_string(input, "vel_bound_file", E->control.velocity_boundary_file);
Output_h5.c:1438:    status = set_attribute_int(input, "file_tbcs", E->control.tbcs_file);
Output_h5.c:1439:    status = set_attribute_string(input, "temp_bound_file", E->control.temperature_boundary_file);
Output_h5.c:1441:    status = set_attribute_int(input, "mat_control", E->control.mat_control);
Output_h5.c:1442:    status = set_attribute_string(input, "mat_file", E->control.mat_file);
Output_h5.c:1444:    status = set_attribute_int(input, "lith_age", E->control.lith_age);
Output_h5.c:1445:    status = set_attribute_string(input, "lith_age_file", E->control.lith_age_file);
Output_h5.c:1446:    status = set_attribute_int(input, "lith_age_time", E->control.lith_age_time);
Output_h5.c:1447:    status = set_attribute_float(input, "lith_age_depth", E->control.lith_age_depth);
Output_h5.c:1449:    status = set_attribute_float(input, "start_age", E->control.start_age);
Output_h5.c:1450:    status = set_attribute_int(input, "reset_startage", E->control.reset_startage);
Output_h5.c:1456:    status = set_attribute_float(input, "Ra_410", E->control.Ra_410);
Output_h5.c:1457:    status = set_attribute_float(input, "clapeyron410", E->control.clapeyron410);
Output_h5.c:1458:    status = set_attribute_float(input, "transT410", E->control.transT410);
Output_h5.c:1460:                                 (E->control.inv_width410 == 0)?
Output_h5.c:1461:                                 E->control.inv_width410 :
Output_h5.c:1462:				 1.0/E->control.inv_width410);
Output_h5.c:1464:    status = set_attribute_float(input, "Ra_670", E->control.Ra_670);
Output_h5.c:1465:    status = set_attribute_float(input, "clapeyron670", E->control.clapeyron670);
Output_h5.c:1466:    status = set_attribute_float(input, "transT670", E->control.transT670);
Output_h5.c:1468:                                 (E->control.inv_width670 == 0)?
Output_h5.c:1469:                                 E->control.inv_width670 :
Output_h5.c:1470:				 1.0/E->control.inv_width670);
Output_h5.c:1472:    status = set_attribute_float(input, "Ra_cmb", E->control.Ra_cmb);
Output_h5.c:1473:    status = set_attribute_float(input, "clapeyroncmb", E->control.clapeyroncmb);
Output_h5.c:1474:    status = set_attribute_float(input, "transTcmb", E->control.transTcmb);
Output_h5.c:1476:                                 (E->control.inv_widthcmb == 0)?
Output_h5.c:1477:                                 E->control.inv_widthcmb :
Output_h5.c:1478:				 1.0/E->control.inv_widthcmb);
Output_h5.c:1484:    status = set_attribute_string(input, "datadir", E->control.data_dir);
Output_h5.c:1485:    status = set_attribute_string(input, "datafile", E->control.data_file);
Output_h5.c:1486:    status = set_attribute_string(input, "datadir_old", E->control.data_dir_old);
Output_h5.c:1487:    status = set_attribute_string(input, "datafile_old", E->control.old_P_file);
Output_h5.c:1489:    status = set_attribute_float(input, "rayleigh", E->control.Atemp);
Output_h5.c:1490:    status = set_attribute_float(input, "dissipation_number", E->control.disptn_number);
Output_h5.c:1492:                                 (E->control.inv_gruneisen == 0)?
Output_h5.c:1493:                                  1.0/E->control.inv_gruneisen :
Output_h5.c:1494:				 E->control.inv_gruneisen);
Output_h5.c:1495:    status = set_attribute_float(input, "surfaceT", E->control.surface_temp);
Output_h5.c:1496:    status = set_attribute_float(input, "Q0", E->control.Q0);
Output_h5.c:1498:    status = set_attribute_int(input, "stokes_flow_only", E->control.stokes);
Output_h5.c:1500:    status = set_attribute_string(input, "output_format", E->output.format);
Output_h5.c:1501:    status = set_attribute_string(input, "output_optional", E->output.optional);
Output_h5.c:1502:    status = set_attribute_int(input, "output_ll_max", E->output.llmax);
Output_h5.c:1504:    status = set_attribute_int(input, "verbose", E->control.verbose);
Output_h5.c:1505:    status = set_attribute_int(input, "see_convergence", E->control.print_convergence);
Output_h5.c:1511:    status = set_attribute_int(input, "nproc_surf", E->parallel.nprocxy);
Output_h5.c:1513:    status = set_attribute_int(input, "nprocx", E->parallel.nprocx);
Output_h5.c:1514:    status = set_attribute_int(input, "nprocy", E->parallel.nprocy);
Output_h5.c:1515:    status = set_attribute_int(input, "nprocz", E->parallel.nprocz);
Output_h5.c:1517:    status = set_attribute_int(input, "coor", E->control.coor);
Output_h5.c:1518:    status = set_attribute_string(input, "coor_file", E->control.coor_file);
Output_h5.c:1520:    status = set_attribute_int(input, "nodex", E->mesh.nox);
Output_h5.c:1521:    status = set_attribute_int(input, "nodey", E->mesh.noy);
Output_h5.c:1522:    status = set_attribute_int(input, "nodez", E->mesh.noz);
Output_h5.c:1524:    status = set_attribute_int(input, "levels", E->mesh.levels);
Output_h5.c:1525:    status = set_attribute_int(input, "mgunitx", E->mesh.mgunitx);
Output_h5.c:1526:    status = set_attribute_int(input, "mgunity", E->mesh.mgunity);
Output_h5.c:1527:    status = set_attribute_int(input, "mgunitz", E->mesh.mgunitz);
Output_h5.c:1529:    status = set_attribute_double(input, "radius_outer", E->sphere.ro);
Output_h5.c:1530:    status = set_attribute_double(input, "radius_inner", E->sphere.ri);
Output_h5.c:1532:    status = set_attribute_int(input, "caps", E->sphere.caps);
Output_h5.c:1536:    dims[0] = E->sphere.caps;
Output_h5.c:1542:    What is E->sphere.caps ? 1 for regional and 12 for full? 
Output_h5.c:1544:    for(n = 1; n <= E->sphere.caps; n++)
Output_h5.c:1546:        data[4*(n-1) + 0] = E->sphere.cap.theta[1];
Output_h5.c:1547:        data[4*(n-1) + 1] = E->sphere.cap.theta[2];
Output_h5.c:1548:        data[4*(n-1) + 2] = E->sphere.cap.theta[3];
Output_h5.c:1549:        data[4*(n-1) + 3] = E->sphere.cap.theta[4];
Output_h5.c:1553:    for(n = 1; n <= E->sphere.caps; n++)
Output_h5.c:1555:        data[4*(n-1) + 0] = E->sphere.cap.fi[1];
Output_h5.c:1556:        data[4*(n-1) + 1] = E->sphere.cap.fi[2];
Output_h5.c:1557:        data[4*(n-1) + 2] = E->sphere.cap.fi[3];
Output_h5.c:1558:        data[4*(n-1) + 3] = E->sphere.cap.fi[4];
Output_h5.c:1565:    if (E->sphere.caps == 1)
Output_h5.c:1567:        status = set_attribute_double(input, "theta_min", E->control.theta_min);
Output_h5.c:1568:        status = set_attribute_double(input, "theta_max", E->control.theta_max);
Output_h5.c:1569:        status = set_attribute_double(input, "fi_min", E->control.fi_min);
Output_h5.c:1570:        status = set_attribute_double(input, "fi_max", E->control.fi_max);
Output_h5.c:1577:    status = set_attribute_int(input, "tracer", E->control.tracer);
Output_h5.c:1578:    status = set_attribute_string(input, "tracer_file", E->trace.tracer_file);
Output_h5.c:1584:    status = set_attribute_string(input, "Viscosity", E->viscosity.STRUCTURE);
Output_h5.c:1585:    status = set_attribute_int(input, "visc_smooth_method", E->viscosity.smooth_cycles);
Output_h5.c:1586:    status = set_attribute_int(input, "VISC_UPDATE", E->viscosity.update_allowed);
Output_h5.c:1588:    n = E->viscosity.num_mat;
Output_h5.c:1590:    status = set_attribute_float_vector(input, "visc0", n, E->viscosity.N0);
Output_h5.c:1591:    status = set_attribute_int(input, "TDEPV", E->viscosity.TDEPV);
Output_h5.c:1592:    status = set_attribute_int(input, "rheol", E->viscosity.RHEOL);
Output_h5.c:1593:    status = set_attribute_float_vector(input, "viscE", n, E->viscosity.E);
Output_h5.c:1594:    status = set_attribute_float_vector(input, "viscT", n, E->viscosity.T);
Output_h5.c:1595:    status = set_attribute_float_vector(input, "viscZ", n, E->viscosity.Z);
Output_h5.c:1597:    status = set_attribute_int(input, "SDEPV", E->viscosity.SDEPV);
Output_h5.c:1598:    status = set_attribute_float(input, "sdepv_misfit", E->viscosity.sdepv_misfit);
Output_h5.c:1599:    status = set_attribute_float_vector(input, "sdepv_expt", n, E->viscosity.sdepv_expt);
Output_h5.c:1601:    status = set_attribute_int(input, "VMIN", E->viscosity.MIN);
Output_h5.c:1602:    status = set_attribute_float(input, "visc_min", E->viscosity.min_value);
Output_h5.c:1604:    status = set_attribute_int(input, "VMAX", E->viscosity.MAX);
Output_h5.c:1605:    status = set_attribute_float(input, "visc_max", E->viscosity.max_value);
Output_h5.c:1611:    status = set_attribute_string(input, "Solver", E->control.SOLVER_TYPE);
Output_h5.c:1612:    status = set_attribute_int(input, "node_assemble", E->control.NASSEMBLE);
Output_h5.c:1613:    status = set_attribute_int(input, "precond", E->control.precondition);
Output_h5.c:1615:    status = set_attribute_double(input, "accuracy", E->control.accuracy);
Output_h5.c:1617:    status = set_attribute_int(input, "mg_cycle", E->control.mg_cycle);
Output_h5.c:1618:    status = set_attribute_int(input, "down_heavy", E->control.down_heavy);
Output_h5.c:1619:    status = set_attribute_int(input, "up_heavy", E->control.up_heavy);
Output_h5.c:1621:    status = set_attribute_int(input, "vlowstep", E->control.v_steps_low);
Output_h5.c:1622:    status = set_attribute_int(input, "vhighstep", E->control.v_steps_high);
Output_h5.c:1623:    status = set_attribute_int(input, "piterations", E->control.p_iterations);
Output_h5.c:1625:    status = set_attribute_int(input, "aug_lagr", E->control.augmented_Lagr);
Output_h5.c:1626:    status = set_attribute_double(input, "aug_number", E->control.augmented);
Output_h5.c:1628:    /* status = set_attribute(input, "", H5T_NATIVE_, &(E->)); */
Output_h5.c:1797:    px = E->parallel.me_loc[1];
Output_h5.c:1798:    py = E->parallel.me_loc[2];
Output_h5.c:1799:    pz = E->parallel.me_loc[3];
Output_h5.c:1802:    nprocx = E->parallel.nprocx;
Output_h5.c:1803:    nprocy = E->parallel.nprocy;
Output_h5.c:1804:    nprocz = E->parallel.nprocz;
Output_h5.c:1807:    nodex = E->mesh.nox;
Output_h5.c:1808:    nodey = E->mesh.noy;
Output_h5.c:1809:    nodez = E->mesh.noz;
Output_h5.c:1812:    nx = E->lmesh.nox;
Output_h5.c:1813:    ny = E->lmesh.noy;
Output_h5.c:1814:    nz = E->lmesh.noz;
Output_h5.c:1883:            (*field)->dims[s] = E->sphere.caps;
Output_h5.c:1884:            (*field)->maxdims[s] = E->sphere.caps;
Output_h5.c:1887:            (*field)->offset[s] = E->hdf5.cap;
Output_h5.c:1951:        if(E->control.verbose) {
Output_h5.c:1952:            fprintf(E->fp_out, "creating dataset: rank=%d  size=%d\n",
Output_h5.c:1954:            fprintf(E->fp_out, "  s=%d  x=%d  y=%d  z=%d  c=%d\n",
Output_h5.c:1956:            fprintf(E->fp_out, "\tdim\tmaxdim\toffset\tstride\tcount\tblock\n");
Output_h5.c:1958:                fprintf(E->fp_out, "\t%d\t%d\t%d\t%d\t%d\t%d\n",
Output_vtk.c:60:             E->lmesh.ezs, E->lmesh.ezs + E->lmesh.elz,
Output_vtk.c:61:             E->lmesh.exs, E->lmesh.exs + E->lmesh.elx,
Output_vtk.c:62:             E->lmesh.eys, E->lmesh.eys + E->lmesh.ely);
Output_vtk.c:115:    int nodes = E->lmesh.nno;
Output_vtk.c:118:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"temperature\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:121:        floattemp[i] =  (float) *(E->T+i+1);
Output_vtk.c:123:    if (strcmp(E->output.vtk_format,"binary") == 0) {
Output_vtk.c:135:    int nodes=E->lmesh.nno;
Output_vtk.c:138:    const int lev = E->mesh.levmax;
Output_vtk.c:141:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"velocity\" NumberOfComponents=\"3\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:143:    V[1] = E->sphere.cap.V[1];
Output_vtk.c:144:    V[2] = E->sphere.cap.V[2];
Output_vtk.c:145:    V[3] = E->sphere.cap.V[3];
Output_vtk.c:147:    for(i=1; i<=E->lmesh.nno; i++) {
Output_vtk.c:148:        sint = E->SinCos[lev][0][i];
Output_vtk.c:149:        sinf = E->SinCos[lev][1][i];
Output_vtk.c:150:        cost = E->SinCos[lev][2][i];
Output_vtk.c:151:        cosf = E->SinCos[lev][3][i];
Output_vtk.c:161:    if (strcmp(E->output.vtk_format, "binary") == 0)
Output_vtk.c:172:    int nodes = E->lmesh.nno;
Output_vtk.c:173:    int lev = E->mesh.levmax;
Output_vtk.c:175:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"viscosity\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:176:        if (strcmp(E->output.vtk_format, "binary") == 0) {
Output_vtk.c:177:            write_binary_array(nodes,&E->VI[lev][1],fp);
Output_vtk.c:179:            write_ascii_array(nodes,1,&E->VI[lev][1],fp);
Output_vtk.c:191:    int nodes = E->lmesh.nno;
Output_vtk.c:195:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"coordinate\" NumberOfComponents=\"3\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:197:    for(i=1; i<=E->lmesh.nno; i++){
Output_vtk.c:198:      floatpos[(i-1)*3+0]=(float)(E->x[1][i]);
Output_vtk.c:199:      floatpos[(i-1)*3+1]=(float)(E->x[2][i]);
Output_vtk.c:200:      floatpos[(i-1)*3+2]=(float)(E->x[3][i]);
Output_vtk.c:203:    if (strcmp(E->output.vtk_format, "binary") == 0)
Output_vtk.c:214:    int nodes = E->lmesh.nno;
Output_vtk.c:227:    fprintf(fp, "        <DataArray type=\"Float32\" Name=\"stress\" NumberOfComponents=\"6\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:229:    if (strcmp(E->output.vtk_format, "binary") == 0) {
Output_vtk.c:230:        write_binary_array(nodes*6,&E->gstress[1],fp);
Output_vtk.c:232:        write_ascii_array(nodes*6,6,&E->gstress[1],fp);
Output_vtk.c:243:    int nodes = E->lmesh.nno;
Output_vtk.c:246:    for(k=0;k<E->composition.ncomp;k++) {
Output_vtk.c:247:        fprintf(fp, "        <DataArray type=\"Float32\" Name=\"composition%d\" format=\"%s\">\n", k+1, E->output.vtk_format);
Output_vtk.c:249:        for(i=1; i<=E->lmesh.nno; i++) {
Output_vtk.c:250:          floatcompo[i-1] = (float) (E->composition.comp_node[k][i]);
Output_vtk.c:253:        if (strcmp(E->output.vtk_format, "binary") == 0)
Output_vtk.c:266:    int nodes = E->lmesh.nno;
Output_vtk.c:270:    if((E->output.write_q_files == 0) || (cycles == 0) ||
Output_vtk.c:271:      (cycles % E->output.write_q_files)!=0)
Output_vtk.c:275:    if(E->control.use_cbf_topo){
Output_vtk.c:276:        get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Output_vtk.c:279:        get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Output_vtk.c:282:    fprintf(fp,"        <DataArray type=\"Float32\" Name=\"surface\" format=\"%s\">\n", E->output.vtk_format);
Output_vtk.c:284:    for(i=1;i<=E->lmesh.nsf;i++){
Output_vtk.c:285:        for(k=1;k<=E->lmesh.noz;k++){
Output_vtk.c:286:            floattopo[(i-1)*E->lmesh.noz + k-1] = 0.0;
Output_vtk.c:289:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Output_vtk.c:292:            if(E->control.pseudo_free_surf)
Output_vtk.c:293:            floattopo[i*E->lmesh.noz-1] = E->slice.freesurf[i];
Output_vtk.c:295:            floattopo[i*E->lmesh.noz-1] = E->slice.tpg[i];
Output_vtk.c:300:    if (strcmp(E->output.vtk_format, "binary") == 0)
Output_vtk.c:321:             E->control.data_file, cycles);
Output_vtk.c:325:    for(n=0; n<E->parallel.nproc; n++) {
Output_vtk.c:327:                n, E->control.data_prefix, n, cycles);
Output_vtk.c:344:             E->control.data_file, cycles);
Output_vtk.c:346:    fprintf(fp, header, E->parallel.nproc);
Output_vtk.c:348:    for(n=0; n<E->parallel.nproc; n++) {
Output_vtk.c:350:                E->control.data_prefix, n, cycles);
Output_vtk.c:361:             E->control.data_file,cycles);
Output_vtk.c:376:        E->lmesh.ezs, E->lmesh.ezs + E->lmesh.elz*E->parallel.nprocz,
Output_vtk.c:377:        E->lmesh.exs, E->lmesh.exs + E->lmesh.elx*E->parallel.nprocx,
Output_vtk.c:378:        E->lmesh.eys, E->lmesh.eys + E->lmesh.ely*E->parallel.nprocy);
Output_vtk.c:380:    snprintf(header, 1024, format, extent, E->output.vtk_format,
Output_vtk.c:381:             E->output.vtk_format, E->output.vtk_format);
Output_vtk.c:384:    if (E->output.stress){
Output_vtk.c:385:        fprintf(fp,"      <DataArray type=\"Float32\" Name=\"stress\" NumberOfComponents=\"6\" format=\"%s\"/>\n", E->output.vtk_format);
Output_vtk.c:387:    if (E->output.comp_nd && E->composition.on){
Output_vtk.c:388:        fprintf(fp,"      <DataArray type=\"Float32\" Name=\"composition1\" format=\"%s\"/>\n", E->output.vtk_format);
Output_vtk.c:390:    if (E->output.surf){
Output_vtk.c:391:        fprintf(fp,"      <DataArray type=\"Float32\" Name=\"surface\" format=\"%s\"/>\n", E->output.vtk_format);
Output_vtk.c:401:    for(i=0; i < E->parallel.nprocy;i++){
Output_vtk.c:402:        for(j=0; j < E->parallel.nprocx;j++){
Output_vtk.c:403:            for(k=0; k < E->parallel.nprocz;k++){
Output_vtk.c:405:                    (k%E->parallel.nprocz)*E->lmesh.elz,
Output_vtk.c:406:                    (k%E->parallel.nprocz+1)*E->lmesh.elz,
Output_vtk.c:407:                    (j%E->parallel.nprocx)*E->lmesh.elx, (j%E->parallel.nprocx+1)*E->lmesh.elx,
Output_vtk.c:408:                    (i%E->parallel.nprocy)*E->lmesh.ely, (i%E->parallel.nprocy+1)*E->lmesh.ely,
Output_vtk.c:409:                    E->control.data_prefix,
Output_vtk.c:410:                    i*E->parallel.nprocx*E->parallel.nprocz+j*E->parallel.nprocz+k, cycles);
Output_vtk.c:680:             E->control.data_file, E->parallel.me, cycles);
Output_vtk.c:694:    if (E->output.stress)
Output_vtk.c:697:    if (E->output.comp_nd && E->composition.on)
Output_vtk.c:700:    if (E->output.surf)
Output_vtk.c:718:    if (E->parallel.me == 0) {
Output_vtk.c:719:        if (E->sphere.caps == 12) {
Pan_problem_misc_functions.c:90:   if (E->parallel.me==0) {
Pan_problem_misc_functions.c:91:    sprintf(unique_name,"%06d.%s-%s",E->control.PID,comment,name);
Pan_problem_misc_functions.c:103:  /* This function is called only when E->control.side_sbcs is true.
Pan_problem_misc_functions.c:112:  if(E->parallel.total_surf_proc==12) {
Pan_problem_misc_functions.c:117:  E->sbc.node = (int* ) malloc((E->lmesh.nno+1)*sizeof(int));
Pan_problem_misc_functions.c:120:  for(i=1; i<=E->lmesh.nno; i++) {
Pan_problem_misc_functions.c:121:    if(E->node[i] & sbc_flags) {
Pan_problem_misc_functions.c:122:      E->sbc.node[i] = n;
Pan_problem_misc_functions.c:126:      E->sbc.node[i] = 0;
Pan_problem_misc_functions.c:130:    for(d=1; d<=E->mesh.nsd; d++) {
Pan_problem_misc_functions.c:131:      E->sbc.SB[side][d] = (double *) malloc(n*sizeof(double));
Pan_problem_misc_functions.c:134:        E->sbc.SB[side][d][i] = 0;
Pan_problem_misc_functions.c:137:  for(d=1; d<=E->mesh.nsd; d++)
Pan_problem_misc_functions.c:138:    for(i=1; i<=E->lmesh.nno; i++)
Pan_problem_misc_functions.c:139:      if(E->node[i] & sbc_flag[d] && E->sphere.cap.VB[d][i] != 0) {
Pan_problem_misc_functions.c:140:        j = E->sbc.node[i];
Pan_problem_misc_functions.c:142:          E->sbc.SB[side][d][j] = E->sphere.cap.VB[d][i];
Pan_problem_misc_functions.c:150:    int lev = E->mesh.levmax;
Pan_problem_misc_functions.c:155:    nxny = E->lmesh.nox*E->lmesh.noy;
Pan_problem_misc_functions.c:157:    temp = E->control.Atemp;
Pan_problem_misc_functions.c:160:      for(i=1;i<=E->lmesh.nno;i++) {
Pan_problem_misc_functions.c:161:        nz = ((i-1) % E->lmesh.noz) + 1;
Pan_problem_misc_functions.c:165:        buoy[i] =  temp * E->refstate.rho[nz]
Pan_problem_misc_functions.c:166:          * E->refstate.thermal_expansivity[nz] * E->T[i];
Pan_problem_misc_functions.c:170:    if(E->control.tracer &&
Pan_problem_misc_functions.c:171:       (E->composition.ichemical_buoyancy)) {
Pan_problem_misc_functions.c:172:      for(j=0;j<E->composition.ncomp;j++) {
Pan_problem_misc_functions.c:174:        temp2 = E->composition.buoyancy_ratio[j] * temp;
Pan_problem_misc_functions.c:175:	      for(i=1;i<=E->lmesh.nno;i++)
Pan_problem_misc_functions.c:176:          buoy[i] -= temp2 * E->composition.comp_node[j][i];
Pan_problem_misc_functions.c:181:    if(E->control.ggrd.ray_control)
Pan_problem_misc_functions.c:193:    if(E->data.use_rotation_g){
Pan_problem_misc_functions.c:201:      rfac = E->data.ge*(5./2.*E->data.rotm-E->data.ellipticity);
Pan_problem_misc_functions.c:204:        for(i=1;i<=E->lmesh.noz;i++)
Pan_problem_misc_functions.c:205:          n = j*E->lmesh.noz + i; /* this could be improved by only
Pan_problem_misc_functions.c:208:          cost2 = cos(E->sx[1][n]);cost2 = cost2*cost2;	    /* cos^2(theta) */
Pan_problem_misc_functions.c:210:          buoy[n] *= E->refstate.gravity[i] * (E->data.ge+rfac*cost2);
Pan_problem_misc_functions.c:217:        for(i=1;i<=E->lmesh.noz;i++){
Pan_problem_misc_functions.c:218:          n = j*E->lmesh.noz + i;
Pan_problem_misc_functions.c:219:          buoy[n] *= E->refstate.gravity[i];
Pan_problem_misc_functions.c:280: * Then, the next E->mesh.nel lines are read into var array.
Pan_problem_misc_functions.c:299:            if(E->parallel.me == 0)
Pan_problem_misc_functions.c:310:    for(i=E->mesh.elz-1; i>=0; i--) {
Pan_problem_misc_functions.c:315:            fprintf(stderr,"Error while reading file '%s'\n", E->viscosity.layer_file);
Pan_problem_misc_functions.c:447:  lev = E->mesh.levmax;
Pan_problem_misc_functions.c:448:  st = E->SinCos[lev][0][node]; /* for elliptical, sincos would be  corrected */
Pan_problem_misc_functions.c:449:  sp = E->SinCos[lev][1][node];
Pan_problem_misc_functions.c:450:  ct = E->SinCos[lev][2][node];
Pan_problem_misc_functions.c:451:  cp = E->SinCos[lev][3][node];
Pan_problem_misc_functions.c:514:  E->control.verbose = 1;
Pan_problem_misc_functions.c:517:	  E->parallel.me,message);
Pan_problem_misc_functions.c:538:  brange = (double)E->control.coor_refine[0];
Pan_problem_misc_functions.c:539:  bfrac =  (double)E->control.coor_refine[1];
Pan_problem_misc_functions.c:540:  trange = (double)E->control.coor_refine[2];
Pan_problem_misc_functions.c:541:  tfrac = (double)E->control.coor_refine[3];
Pan_problem_misc_functions.c:543:  range = (double) E->sphere.ro - E->sphere.ri;		/* original range */
Pan_problem_misc_functions.c:553:  nb = E->mesh.noz * bfrac;
Pan_problem_misc_functions.c:554:  nt = E->mesh.noz * tfrac;
Pan_problem_misc_functions.c:555:  nm = E->mesh.noz - nb - nt;
Pan_problem_misc_functions.c:563:  for(r=E->sphere.ri,k=1;k<=nb;k++,r+=drb){
Pan_problem_misc_functions.c:566:  klim = E->mesh.noz - nt + 1;
Pan_problem_misc_functions.c:570:  for(;k <= E->mesh.noz;k++,r+=drt){
Pan_problem_misc_functions.c:580:rr[1...E->mesh.noz]
Pan_problem_misc_functions.c:595:  if(E->control.nrlayer[0] != 1)
Pan_problem_misc_functions.c:597:  if(E->control.nrlayer[E->control.rlayers-1] != E->mesh.noz)
Pan_problem_misc_functions.c:599:  if(fabs(E->control.rrlayer[0] -E->sphere.ri) > 1e-5)
Pan_problem_misc_functions.c:601:  if(fabs(E->control.rrlayer[ E->control.rlayers-1] - E->sphere.ro)>1e-6)
Pan_problem_misc_functions.c:603:  if(E->control.rlayers < 2)
Pan_problem_misc_functions.c:606:  rr[1] =  E->control.rrlayer[0];
Pan_problem_misc_functions.c:607:  for(j = 1; j < E->control.rlayers; j++){
Pan_problem_misc_functions.c:608:    ddr = (E->control.rrlayer[j] - E->control.rrlayer[j - 1]) /
Pan_problem_misc_functions.c:609:      (E->control.nrlayer[j] - E->control.nrlayer[j - 1]);
Pan_problem_misc_functions.c:610:    for(k = E->control.nrlayer[j-1]+1;k <= E->control.nrlayer[j];k++)
Pan_problem_misc_functions.c:679:  if(E->data.use_ellipse){
Pan_problem_misc_functions.c:681:    return M_PI_2 - atan2(tan(tmp),E->data.efac);
Parallel_util.c:60:  MPI_Barrier(E->parallel.world);
Parsing.c:98:    int m=E->parallel.me;
Phase_change.c:50:  int nno  = E->lmesh.nno;
Phase_change.c:51:  int nsf  = E->lmesh.nsf;
Phase_change.c:53:  E->Fas410   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:54:  E->Fas410_b = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:55:  E->Fas670   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:56:  E->Fas670_b = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:57:  E->Fascmb   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:58:  E->Fascmb_b = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:64:  int m = E->parallel.me;
Phase_change.c:68:  input_float("Ra_410",&(E->control.Ra_410),"0.0",m);
Phase_change.c:69:  input_float("clapeyron410",&(E->control.clapeyron410),"0.0",m);
Phase_change.c:70:  input_float("transT410",&(E->control.transT410),"0.0",m);
Phase_change.c:74:    E->control.inv_width410 = 1.0/width;
Phase_change.c:77:  input_float("Ra_670",&(E->control.Ra_670),"0.0",m);
Phase_change.c:78:  input_float("clapeyron670",&(E->control.clapeyron670),"0.0",m);
Phase_change.c:79:  input_float("transT670",&(E->control.transT670),"0.0",m);
Phase_change.c:83:    E->control.inv_width670 = 1.0/width;
Phase_change.c:86:  input_float("Ra_cmb",&(E->control.Ra_cmb),"0.0",m);
Phase_change.c:87:  input_float("clapeyroncmb",&(E->control.clapeyroncmb),"0.0",m);
Phase_change.c:88:  input_float("transTcmb",&(E->control.transTcmb),"0.0",m);
Phase_change.c:92:    E->control.inv_widthcmb = 1.0/width;
Phase_change.c:97:  if (E->control.Ra_410 != 0.0)
Phase_change.c:98:    phase_change_apply(E, buoy, E->Fas410, E->Fas410_b, E->control.Ra_410,
Phase_change.c:99:		       E->control.clapeyron410, E->viscosity.z410,
Phase_change.c:100:		       E->control.transT410, E->control.inv_width410);
Phase_change.c:106:  if (E->control.Ra_670 != 0.0)
Phase_change.c:107:    phase_change_apply(E, buoy, E->Fas670, E->Fas670_b, E->control.Ra_670,
Phase_change.c:108:		       E->control.clapeyron670, E->viscosity.zlm,
Phase_change.c:109:		       E->control.transT670, E->control.inv_width670);
Phase_change.c:115:  if (E->control.Ra_cmb != 0.0)
Phase_change.c:116:    phase_change_apply(E, buoy, E->Fascmb, E->Fascmb_b, E->control.Ra_cmb,
Phase_change.c:117:		       E->control.clapeyroncmb, E->viscosity.zcmb,
Phase_change.c:118:		       E->control.transTcmb, E->control.inv_widthcmb);
Phase_change.c:130:    for(i=1;i<=E->lmesh.nno;i++)
Phase_change.c:133:  if (E->control.verbose) {
Phase_change.c:134:    fprintf(E->fp_out, "Ra=%f, clapeyron=%f, depth=%f, transT=%f, inv_width=%f\n",
Phase_change.c:137:    fflush(E->fp_out);
Phase_change.c:155:    for(i=1;i<=E->lmesh.nno;i++)  {
Phase_change.c:156:        nz = ((i-1) % E->lmesh.noz) + 1;
Phase_change.c:157:        dz = (E->sphere.ro-E->sx[3][i]) - depth;
Phase_change.c:161:        e_pressure = dz * E->refstate.rho[nz] * E->refstate.gravity[nz]
Phase_change.c:162:            - clapeyron * (E->T[i] - transT);
Phase_change.c:169:    for (k=1;k<=E->lmesh.noy;k++)
Phase_change.c:170:      for (j=1;j<=E->lmesh.nox;j++)  {
Phase_change.c:173:        for (i=1;i<E->lmesh.noz;i++)   {
Phase_change.c:174:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Phase_change.c:176:            B_b[ns]=(E->sx[3][n+1]-E->sx[3][n])*(pt5-B[n])/(B[n+1]-B[n])+E->sx[3][n];
Phase_change.c:185:  fprintf(E->fp_out,"output_phase_change_buoyancy\n");
Phase_change.c:186:  fprintf(E->fp_out,"for cap %d\n",E->sphere.capid);
Phase_change.c:187:  for (j=1;j<=E->lmesh.nno;j++)
Phase_change.c:188:    fprintf(E->fp_out,"Z = %.6e T = %.6e B[%06d] = %.6e \n",
Phase_change.c:189:        E->sx[3][j],E->T[j],j,B[j]);
Phase_change.c:190:  fflush(E->fp_out);
Problem_related.c:44:    (E->solver.read_input_files_for_timesteps)(E,1,1); /* read velocity(1) and output(1) */
Problem_related.c:57:  (E->solver.read_input_files_for_timesteps)(E,4,1); /* read Rayleigh number for top layers */
Problem_related.c:68:    (E->solver.read_input_files_for_timesteps)(E,3,1); /* read element material(3) and output(1) */
Problem_related.c:79:    (E->solver.read_input_files_for_timesteps)(E,5,1); /* read temperature(5) and output(1) */
Problem_related.c:95:    E->monitor.elapsed_time = 0.0;
Problem_related.c:97:    if (E->convection.tic_method == -1) {
Problem_related.c:100:      if(strcmp(E->output.format, "ascii-gz") == 0){
Problem_related.c:101:	if(E->output.gzdir.vtk_io)
Problem_related.c:103:		  E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:106:		  E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:108:	sprintf(output_file, "%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:112:      sprintf(output_file, "%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:117:	fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file);
Problem_related.c:121:      if(sscanf(input_s,"%d %d %f",&ll,&mm,&E->monitor.elapsed_time) != 3) {
Problem_related.c:143:    if (E->control.zero_elapsed_time) /* set elapsed_time to zero */
Problem_related.c:144:	E->monitor.elapsed_time = 0.0;
Problem_related.c:158:    if (E->control.reset_startage)
Problem_related.c:159:	E->control.start_age = E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:180:   if (E->data.timedir >= 0) { /* forward convection */
Problem_related.c:181:      age_in_MY = E->control.start_age - E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:184:      age_in_MY = E->control.start_age + E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:187:      if (((age_in_MY+e_4) < 0.0) && (E->monitor.solution_cycles < 1)) {
Problem_related.c:188:        if (E->parallel.me == 0) fprintf(stderr,"Age = %g Ma, Initial age should not be negative!\n",age_in_MY);
Process_buoyancy.c:61:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Process_buoyancy.c:65:    const int nno=E->lmesh.nno;
Process_buoyancy.c:66:    const int lev = E->mesh.levmax;
Process_buoyancy.c:80:    for(e=1;e<=E->lmesh.nel;e++) {
Process_buoyancy.c:90:          nz = ((E->ien[e].node[j]-1) % E->lmesh.noz)+1;
Process_buoyancy.c:91:          rho[i] += E->refstate.rho[nz]*E->N.vpt[GNVINDEX(j,i)];
Process_buoyancy.c:92:          u[i] += VV[3][j]*E->N.vpt[GNVINDEX(j,i)];
Process_buoyancy.c:93:          T[i] += E->T[E->ien[e].node[j]]*E->N.vpt[GNVINDEX(j,i)];
Process_buoyancy.c:94:          dTdz[i] += -E->T[E->ien[e].node[j]]*E->gNX[e].vpt[GNVXINDEX(2,j,i)];
Process_buoyancy.c:102:        uT += rho[i]*u[i]*T[i]*E->gDA[e].vpt[i] + dTdz[i]*E->gDA[e].vpt[i];
Process_buoyancy.c:105:      uT /= E->eco[e].area;
Process_buoyancy.c:108:        flux[E->ien[e].node[j]] += uT*E->TWW[lev][e].node[j];
Process_buoyancy.c:113:  (E->exchange_node_f)(E,flux,lev);
Process_buoyancy.c:116:     flux[i] *= E->MASS[lev][i];
Process_buoyancy.c:118:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Process_buoyancy.c:119:    for(i=1;i<=E->lmesh.nsf;i++)
Process_buoyancy.c:120:      E->slice.shflux[i]=2*flux[E->surf_node[i]]-flux[E->surf_node[i]-1];
Process_buoyancy.c:122:  if (E->parallel.me_loc[3]==0)
Process_buoyancy.c:123:    for(i=1;i<=E->lmesh.nsf;i++)
Process_buoyancy.c:124:      E->slice.bhflux[i] = 2*flux[E->surf_node[i]-E->lmesh.noz+1]
Process_buoyancy.c:125:                           - flux[E->surf_node[i]-E->lmesh.noz+2];
Process_buoyancy.c:127:    for(e=1;e<=E->lmesh.snel;e++) {
Process_buoyancy.c:128:         uT =(E->slice.shflux[E->sien[e].node[1]] +
Process_buoyancy.c:129:              E->slice.shflux[E->sien[e].node[2]] +
Process_buoyancy.c:130:              E->slice.shflux[E->sien[e].node[3]] +
Process_buoyancy.c:131:              E->slice.shflux[E->sien[e].node[4]])*0.25;
Process_buoyancy.c:132:         el = e*E->lmesh.elz;
Process_buoyancy.c:133:         sum_h[0] += uT*E->eco[el].area;
Process_buoyancy.c:134:         sum_h[1] += E->eco[el].area;
Process_buoyancy.c:136:         uT =(E->slice.bhflux[E->sien[e].node[1]] +
Process_buoyancy.c:137:              E->slice.bhflux[E->sien[e].node[2]] +
Process_buoyancy.c:138:              E->slice.bhflux[E->sien[e].node[3]] +
Process_buoyancy.c:139:              E->slice.bhflux[E->sien[e].node[4]])*0.25;
Process_buoyancy.c:140:         el = (e-1)*E->lmesh.elz+1;
Process_buoyancy.c:141:         sum_h[2] += uT*E->eco[el].area;
Process_buoyancy.c:142:         sum_h[3] += E->eco[el].area;
Process_buoyancy.c:147:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Process_buoyancy.c:149:    /*     if (E->control.verbose && E->parallel.me==E->parallel.nprocz-1) {
Process_buoyancy.c:150:	     fprintf(E->fp_out,"surface heat flux= %f %f\n",sum_h[0],E->monitor.elapsed_time);
Process_buoyancy.c:151:             fflush(E->fp_out);
Process_buoyancy.c:153:    if (E->parallel.me==E->parallel.nprocz-1) {
Process_buoyancy.c:155:      //fprintf(E->fp,"surface heat flux= %f\n",sum_h[0]); //commented out because E->fp is only on CPU 0 
Process_buoyancy.c:157:      if(E->output.write_q_files > 0){
Process_buoyancy.c:159:	fprintf(E->output.fpqt,"%13.5e %13.5e %13.5e\n",E->monitor.elapsed_time,sum_h[0],sqrt(E->monitor.vdotv));
Process_buoyancy.c:160:	fflush(E->output.fpqt);
Process_buoyancy.c:165:  if (E->parallel.me_loc[3]==0)    {
Process_buoyancy.c:167:/*     if (E->control.verbose && E->parallel.me==0) fprintf(E->fp_out,"bottom heat flux= %f %f\n",sum_h[2],E->monitor.elapsed_time); */
Process_buoyancy.c:168:    if (E->parallel.me==0) {
Process_buoyancy.c:170:      fprintf(E->fp,"bottom heat flux= %f\n",sum_h[2]);
Process_buoyancy.c:171:      if(E->output.write_q_files > 0){
Process_buoyancy.c:172:	fprintf(E->output.fpqb,"%13.5e %13.5e %13.5e\n",
Process_buoyancy.c:173:		E->monitor.elapsed_time,sum_h[2],sqrt(E->monitor.vdotv));
Process_buoyancy.c:174:	fflush(E->output.fpqb);
Process_buoyancy.c:195:    S1 = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:196:    S2 = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:197:    S3 = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:199:    for(i=1;i<=E->lmesh.nno;i++) {
Process_buoyancy.c:200:        S1[i] = E->T[i];
Process_buoyancy.c:201:        S2[i] = E->sphere.cap.V[1][i]*E->sphere.cap.V[1][i]
Process_buoyancy.c:202:              + E->sphere.cap.V[2][i]*E->sphere.cap.V[2][i];
Process_buoyancy.c:203:        S3[i] = E->sphere.cap.V[3][i]*E->sphere.cap.V[3][i];
Process_buoyancy.c:206:    return_horiz_ave_f(E,S1,E->Have.T);
Process_buoyancy.c:207:    return_horiz_ave_f(E,S2,E->Have.V[1]);
Process_buoyancy.c:208:    return_horiz_ave_f(E,S3,E->Have.V[2]);
Process_buoyancy.c:210:    if (E->composition.on) {
Process_buoyancy.c:211:        for(n=0; n<E->composition.ncomp; n++) {
Process_buoyancy.c:212:            for(i=1;i<=E->lmesh.nno;i++)
Process_buoyancy.c:213:                S1[i] = E->composition.comp_node[n][i];
Process_buoyancy.c:214:            return_horiz_ave_f(E,S1,E->Have.C[n]);
Process_buoyancy.c:222:    for (i=1;i<=E->lmesh.noz;i++) {
Process_buoyancy.c:223:      E->Have.V[1][i] = sqrt(E->Have.V[1][i]);
Process_buoyancy.c:224:      E->Have.V[2][i] = sqrt(E->Have.V[2][i]);
Regional_boundary_conditions.c:56:  for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
Regional_boundary_conditions.c:57:      noz = E->lmesh.NOZ[lv];
Regional_boundary_conditions.c:59:      if(E->mesh.topvbc == 0) {
Regional_boundary_conditions.c:60:	horizontal_bc(E,E->sphere.cap.VB,noz,1,0.0,VBX,0,lv);
Regional_boundary_conditions.c:61:	horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,VBZ,1,lv);
Regional_boundary_conditions.c:62:	horizontal_bc(E,E->sphere.cap.VB,noz,2,0.0,VBY,0,lv);
Regional_boundary_conditions.c:63:	horizontal_bc(E,E->sphere.cap.VB,noz,1,E->control.VBXtopval,SBX,1,lv);
Regional_boundary_conditions.c:64:	horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,SBZ,0,lv);
Regional_boundary_conditions.c:65:	horizontal_bc(E,E->sphere.cap.VB,noz,2,E->control.VBYtopval,SBY,1,lv);
Regional_boundary_conditions.c:69:	if((lv==E->mesh.gridmax) && E->control.ggrd.vtop_control)
Regional_boundary_conditions.c:74:      else if(E->mesh.topvbc == 1) {
Regional_boundary_conditions.c:75:        horizontal_bc(E,E->sphere.cap.VB,noz,1,E->control.VBXtopval,VBX,1,lv);
Regional_boundary_conditions.c:76:        horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,VBZ,1,lv);
Regional_boundary_conditions.c:77:        horizontal_bc(E,E->sphere.cap.VB,noz,2,E->control.VBYtopval,VBY,1,lv);
Regional_boundary_conditions.c:78:        horizontal_bc(E,E->sphere.cap.VB,noz,1,0.0,SBX,0,lv);
Regional_boundary_conditions.c:79:        horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,SBZ,0,lv);
Regional_boundary_conditions.c:80:        horizontal_bc(E,E->sphere.cap.VB,noz,2,0.0,SBY,0,lv);
Regional_boundary_conditions.c:83:	if((lv==E->mesh.gridmax) && E->control.ggrd.vtop_control)
Regional_boundary_conditions.c:86:	if(E->control.vbcs_file)   {
Regional_boundary_conditions.c:87:	  if(lv == E->mesh.gridmin)
Regional_boundary_conditions.c:91:      else if(E->mesh.topvbc == 2) {
Regional_boundary_conditions.c:93:        horizontal_bc(E,E->sphere.cap.VB,noz,1,0.0,VBX,0,lv);
Regional_boundary_conditions.c:94:        horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,VBZ,0,lv);
Regional_boundary_conditions.c:95:        horizontal_bc(E,E->sphere.cap.VB,noz,2,0.0,VBY,0,lv);
Regional_boundary_conditions.c:96:        horizontal_bc(E,E->sphere.cap.VB,noz,1,E->control.VBXtopval,SBX,1,lv);
Regional_boundary_conditions.c:97:        horizontal_bc(E,E->sphere.cap.VB,noz,3,0.0,SBZ,1,lv);
Regional_boundary_conditions.c:98:        horizontal_bc(E,E->sphere.cap.VB,noz,2,E->control.VBYtopval,SBY,1,lv);
Regional_boundary_conditions.c:103:      if(E->mesh.botvbc == 0) {
Regional_boundary_conditions.c:104:        horizontal_bc(E,E->sphere.cap.VB,1,1,0.0,VBX,0,lv);
Regional_boundary_conditions.c:105:        horizontal_bc(E,E->sphere.cap.VB,1,3,0.0,VBZ,1,lv);
Regional_boundary_conditions.c:106:        horizontal_bc(E,E->sphere.cap.VB,1,2,0.0,VBY,0,lv);
Regional_boundary_conditions.c:107:        horizontal_bc(E,E->sphere.cap.VB,1,1,E->control.VBXbotval,SBX,1,lv);
Regional_boundary_conditions.c:108:        horizontal_bc(E,E->sphere.cap.VB,1,3,0.0,SBZ,0,lv);
Regional_boundary_conditions.c:109:        horizontal_bc(E,E->sphere.cap.VB,1,2,E->control.VBYbotval,SBY,1,lv);
Regional_boundary_conditions.c:111:      else if(E->mesh.botvbc == 1) {
Regional_boundary_conditions.c:112:        horizontal_bc(E,E->sphere.cap.VB,1,1,E->control.VBXbotval,VBX,1,lv);
Regional_boundary_conditions.c:113:        horizontal_bc(E,E->sphere.cap.VB,1,3,0.0,VBZ,1,lv);
Regional_boundary_conditions.c:114:        horizontal_bc(E,E->sphere.cap.VB,1,2,E->control.VBYbotval,VBY,1,lv);
Regional_boundary_conditions.c:115:        horizontal_bc(E,E->sphere.cap.VB,1,1,0.0,SBX,0,lv);
Regional_boundary_conditions.c:116:        horizontal_bc(E,E->sphere.cap.VB,1,3,0.0,SBZ,0,lv);
Regional_boundary_conditions.c:117:        horizontal_bc(E,E->sphere.cap.VB,1,2,0.0,SBY,0,lv);
Regional_boundary_conditions.c:124:      if(E->control.side_sbcs)
Regional_boundary_conditions.c:129:      anything at present, if E->mesh.toplayerbc != 0
Regional_boundary_conditions.c:133:      if(E->control.verbose) {
Regional_boundary_conditions.c:134:          for (node=1;node<=E->lmesh.nno;node++)
Regional_boundary_conditions.c:135:            fprintf(E->fp_out,"VB== %d %g %g %g flag %u %u %u\n",
Regional_boundary_conditions.c:137:                E->sphere.cap.VB[1][node],
Regional_boundary_conditions.c:138:                E->sphere.cap.VB[2][node],
Regional_boundary_conditions.c:139:                E->sphere.cap.VB[3][node],
Regional_boundary_conditions.c:140:                E->node[node]&VBX,
Regional_boundary_conditions.c:141:                E->node[node]&VBY,
Regional_boundary_conditions.c:142:                E->node[node]&VBZ);
Regional_boundary_conditions.c:143:            fflush(E->fp_out);
Regional_boundary_conditions.c:155:  lev = E->mesh.levmax;
Regional_boundary_conditions.c:160:    noz = E->lmesh.noz;
Regional_boundary_conditions.c:161:    if(E->mesh.toptbc == 1)    {
Regional_boundary_conditions.c:162:      horizontal_bc(E,E->sphere.cap.TB,noz,3,E->control.TBCtopval,TBZ,1,lev);
Regional_boundary_conditions.c:163:      horizontal_bc(E,E->sphere.cap.TB,noz,3,E->control.TBCtopval,FBZ,0,lev);
Regional_boundary_conditions.c:164:      if(E->control.tbcs_file)   {
Regional_boundary_conditions.c:169:      horizontal_bc(E,E->sphere.cap.TB,noz,3,E->control.TBCtopval,TBZ,0,lev);
Regional_boundary_conditions.c:170:      horizontal_bc(E,E->sphere.cap.TB,noz,3,E->control.TBCtopval,FBZ,1,lev);
Regional_boundary_conditions.c:173:    if(E->mesh.bottbc == 1)    {
Regional_boundary_conditions.c:174:      horizontal_bc(E,E->sphere.cap.TB,1,3,E->control.TBCbotval,TBZ,1,lev);
Regional_boundary_conditions.c:175:      horizontal_bc(E,E->sphere.cap.TB,1,3,E->control.TBCbotval,FBZ,0,lev);
Regional_boundary_conditions.c:178:      horizontal_bc(E,E->sphere.cap.TB,1,3,E->control.TBCbotval,TBZ,0,lev);
Regional_boundary_conditions.c:179:      horizontal_bc(E,E->sphere.cap.TB,1,3,E->control.TBCbotval,FBZ,1,lev);
Regional_boundary_conditions.c:182:    if((E->control.temperature_bound_adj==1) || (E->control.lith_age_time==1))  {
Regional_boundary_conditions.c:191:   E->temperatures_conform_bcs = temperatures_conform_bcs;
Regional_boundary_conditions.c:200:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:205:  if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1)
Regional_boundary_conditions.c:206:    for(j=1;j<=E->lmesh.noy;j++)
Regional_boundary_conditions.c:207:      for(i=1;i<=E->lmesh.noz;i++)  {
Regional_boundary_conditions.c:208:        node1 = i + (j-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:209:        node2 = node1 + (E->lmesh.nox-1)*E->lmesh.noz;
Regional_boundary_conditions.c:211:        ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:212:        if (E->parallel.me_loc[1]==0 )  {
Regional_boundary_conditions.c:213:           E->sphere.cap.VB[1][node1] = 0.0;
Regional_boundary_conditions.c:214:           if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:215:              E->sphere.cap.VB[3][node1] = 0.0;
Regional_boundary_conditions.c:217:        if (E->parallel.me_loc[1]==E->parallel.nprocx-1)  {
Regional_boundary_conditions.c:218:           E->sphere.cap.VB[1][node2] = 0.0;
Regional_boundary_conditions.c:219:           if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:220:              E->sphere.cap.VB[3][node2] = 0.0;
Regional_boundary_conditions.c:227:    if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:228:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:229:        for(i=1;i<=E->lmesh.noz;i++)       {
Regional_boundary_conditions.c:230:          node1 = i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:231:          ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:233:          E->sphere.cap.VB[2][node1] = 0.0;
Regional_boundary_conditions.c:234:          if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:235:            E->sphere.cap.VB[3][node1] = 0.0;
Regional_boundary_conditions.c:238:    if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:239:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:240:        for(i=1;i<=E->lmesh.noz;i++)       {
Regional_boundary_conditions.c:241:          node2 = (E->lmesh.noy-1)*E->lmesh.noz*E->lmesh.nox + i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:242:          ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:244:          E->sphere.cap.VB[2][node2] = 0.0;
Regional_boundary_conditions.c:245:          if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:246:            E->sphere.cap.VB[3][node2] = 0.0;
Regional_boundary_conditions.c:251:  for(level=E->mesh.levmax;level>=E->mesh.levmin;level--) {
Regional_boundary_conditions.c:253:    if ( (E->control.CONJ_GRAD && level==E->mesh.levmax) ||E->control.NMULTIGRID)  {
Regional_boundary_conditions.c:254:    noz = E->lmesh.NOZ[level] ;
Regional_boundary_conditions.c:255:    noy = E->lmesh.NOY[level] ;
Regional_boundary_conditions.c:256:    nox = E->lmesh.NOX[level] ;
Regional_boundary_conditions.c:258:    if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1) {
Regional_boundary_conditions.c:263:          ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:264:          if (E->parallel.me_loc[1]==0 )  {
Regional_boundary_conditions.c:265:            E->NODE[level][node1] = E->NODE[level][node1] | VBX;
Regional_boundary_conditions.c:266:            E->NODE[level][node1] = E->NODE[level][node1] & (~SBX);
Regional_boundary_conditions.c:267:            if((ii!=1) && (ii!=E->mesh.NOZ[level])) {
Regional_boundary_conditions.c:268:               E->NODE[level][node1] = E->NODE[level][node1] & (~VBY);
Regional_boundary_conditions.c:269:               E->NODE[level][node1] = E->NODE[level][node1] | SBY;
Regional_boundary_conditions.c:270:               E->NODE[level][node1] = E->NODE[level][node1] & (~VBZ);
Regional_boundary_conditions.c:271:               E->NODE[level][node1] = E->NODE[level][node1] | SBZ;
Regional_boundary_conditions.c:274:          if (E->parallel.me_loc[1]==E->parallel.nprocx-1)  {
Regional_boundary_conditions.c:275:            E->NODE[level][node2] = E->NODE[level][node2] | VBX;
Regional_boundary_conditions.c:276:            E->NODE[level][node2] = E->NODE[level][node2] & (~SBX);
Regional_boundary_conditions.c:277:            if((ii!=1) && (ii!=E->mesh.NOZ[level])) {
Regional_boundary_conditions.c:278:              E->NODE[level][node2] = E->NODE[level][node2] & (~VBY);
Regional_boundary_conditions.c:279:              E->NODE[level][node2] = E->NODE[level][node2] | SBY;
Regional_boundary_conditions.c:280:              E->NODE[level][node2] = E->NODE[level][node2] & (~VBZ);
Regional_boundary_conditions.c:281:              E->NODE[level][node2] = E->NODE[level][node2] | SBZ;
Regional_boundary_conditions.c:289:      if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:293:            ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:294:            jj = j + E->lmesh.NXS[level] - 1;
Regional_boundary_conditions.c:296:            E->NODE[level][node1] = E->NODE[level][node1] | VBY;
Regional_boundary_conditions.c:297:            E->NODE[level][node1] = E->NODE[level][node1] & (~SBY);
Regional_boundary_conditions.c:298:            if((ii!= 1) && (ii != E->mesh.NOZ[level]))  {
Regional_boundary_conditions.c:299:                E->NODE[level][node1] = E->NODE[level][node1] & (~VBZ);
Regional_boundary_conditions.c:300:                E->NODE[level][node1] = E->NODE[level][node1] | SBZ;
Regional_boundary_conditions.c:302:            if((jj!=1) && (jj!=E->mesh.NOX[level]) && (ii!=1) && (ii!=E->mesh.NOZ[level])){
Regional_boundary_conditions.c:303:                E->NODE[level][node1] = E->NODE[level][node1] & (~VBX);
Regional_boundary_conditions.c:304:                E->NODE[level][node1] = E->NODE[level][node1] | SBX;
Regional_boundary_conditions.c:308:      if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:312:            ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:313:            jj = j + E->lmesh.NXS[level] - 1;
Regional_boundary_conditions.c:314:            E->NODE[level][node2] = E->NODE[level][node2] | VBY;
Regional_boundary_conditions.c:315:            E->NODE[level][node2] = E->NODE[level][node2] & (~SBY);
Regional_boundary_conditions.c:316:            if((ii!= 1) && (ii != E->mesh.NOZ[level]))  {
Regional_boundary_conditions.c:317:                E->NODE[level][node2] = E->NODE[level][node2] & (~VBZ);
Regional_boundary_conditions.c:318:                E->NODE[level][node2] = E->NODE[level][node2] | SBZ;
Regional_boundary_conditions.c:320:            if((jj!=1) && (jj!=E->mesh.NOX[level]) && (ii!=1) && (ii!=E->mesh.NOZ[level])){
Regional_boundary_conditions.c:321:                E->NODE[level][node2] = E->NODE[level][node2] & (~VBX);
Regional_boundary_conditions.c:322:                E->NODE[level][node2] = E->NODE[level][node2] | SBX;
Regional_boundary_conditions.c:334:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:338:   if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1)
Regional_boundary_conditions.c:339:    for(j=1;j<=E->lmesh.noy;j++)
Regional_boundary_conditions.c:340:      for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:341:        node1 = i + (j-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:342:        node2 = node1 + (E->lmesh.nox-1)*E->lmesh.noz;
Regional_boundary_conditions.c:343:        if (E->parallel.me_loc[1]==0 )                   {
Regional_boundary_conditions.c:344:          E->node[node1] = E->node[node1] & (~TBX);
Regional_boundary_conditions.c:345:          E->node[node1] = E->node[node1] | FBX;
Regional_boundary_conditions.c:346:          E->sphere.cap.TB[1][node1] = 0.0;
Regional_boundary_conditions.c:348:        if (E->parallel.me_loc[1]==E->parallel.nprocx-1)   {
Regional_boundary_conditions.c:349:          E->node[node2] = E->node[node2] & (~TBX);
Regional_boundary_conditions.c:350:          E->node[node2] = E->node[node2] | FBX;
Regional_boundary_conditions.c:351:          E->sphere.cap.TB[1][node2] = 0.0;
Regional_boundary_conditions.c:355:    if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:356:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:357:        for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:358:          node1 = i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:359:          E->node[node1] = E->node[node1] & (~TBY);
Regional_boundary_conditions.c:360:              E->node[node1] = E->node[node1] | FBY;
Regional_boundary_conditions.c:361:              E->sphere.cap.TB[2][node1] = 0.0;
Regional_boundary_conditions.c:364:    if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:365:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:366:        for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:367:          node2 = i +(j-1)*E->lmesh.noz + (E->lmesh.noy-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:368:          E->node[node2] = E->node[node2] & (~TBY);
Regional_boundary_conditions.c:369:          E->node[node2] = E->node[node2] | FBY;
Regional_boundary_conditions.c:370:          E->sphere.cap.TB[2][node2] = 0.0;
Regional_boundary_conditions.c:383:  if(dirn > E->mesh.nsd)
Regional_boundary_conditions.c:389:      rowl = E->lmesh.NOZ[level];
Regional_boundary_conditions.c:391:  if ( ( (ROW==1) && (E->parallel.me_loc[3]==0) ) ||
Regional_boundary_conditions.c:392:       ( (ROW==E->lmesh.NOZ[level]) && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) ) {
Regional_boundary_conditions.c:396:      for(j=1;j<=E->lmesh.NOY[level];j++)
Regional_boundary_conditions.c:397:    	for(i=1;i<=E->lmesh.NOX[level];i++)     {
Regional_boundary_conditions.c:398:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+
Regional_boundary_conditions.c:399:          (j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Regional_boundary_conditions.c:400:    	  E->NODE[level][node] = E->NODE[level][node] & (~ mask);
Regional_boundary_conditions.c:406:      for(j=1;j<=E->lmesh.NOY[level];j++)
Regional_boundary_conditions.c:407:        for(i=1;i<=E->lmesh.NOX[level];i++)       {
Regional_boundary_conditions.c:408:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Regional_boundary_conditions.c:409:    	  E->NODE[level][node] = E->NODE[level][node] | (mask);
Regional_boundary_conditions.c:411:    	  if(level==E->mesh.levmax)   /* NB */
Regional_boundary_conditions.c:424:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:426:  fprintf(E->fp,"Periodic boundary conditions\n");
Regional_boundary_conditions.c:431:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:432:  fprintf(E->fp,"pERIodic temperature boundary conditions\n");
Regional_geometry_cartesian.c:36:  E->mesh.nsd = 2;
Regional_geometry_cartesian.c:37:  E->mesh.dof = 2;
Regional_geometry_cartesian.c:46:  E->mesh.nsd = 2;
Regional_geometry_cartesian.c:47:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:55:  E->mesh.nsd = 3;
Regional_geometry_cartesian.c:56:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:63:  E->mesh.nsd = 3;
Regional_geometry_cartesian.c:64:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:66:  E->sphere.caps = 1;
Regional_geometry_cartesian.c:67:  E->sphere.max_connections = 6;
Regional_obsolete.c:46:  E->parallel.me = 0;
Regional_obsolete.c:47:  E->parallel.nproc = 1;
Regional_obsolete.c:48:  E->parallel.me_loc[1] = 0;
Regional_obsolete.c:49:  E->parallel.me_loc[2] = 0;
Regional_obsolete.c:50:  E->parallel.me_loc[3] = 0;
Regional_obsolete.c:53:  MPI_Comm_rank(E->parallel.world, &(E->parallel.me) );
Regional_obsolete.c:54:  MPI_Comm_size(E->parallel.world, &(E->parallel.nproc) );
Regional_obsolete.c:81:  const int dims = E->mesh.nsd;
Regional_obsolete.c:89:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:90:    if (E->parallel.me==0) fprintf(stderr,"scatter_to_nlayer should not be called\n");
Regional_obsolete.c:95:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:97:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:99:    SD = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Regional_obsolete.c:102:    rootid = E->parallel.me_sph*E->parallel.nprocz; /* which is the bottom cpu */
Regional_obsolete.c:104:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:113:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:114:    if (E->parallel.me==rootid)
Regional_obsolete.c:115:      for (d=0;d<E->parallel.nprocz;d++)  {
Regional_obsolete.c:117:        for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:118:          k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:119:          for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:120:            for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:121:              node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:122:              node1= k1+ (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:130:	  MPI_Send(SD,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],rootid,E->parallel.world);
Regional_obsolete.c:133:	  for (i=0;i<=E->lmesh.NEQ[lev];i++)
Regional_obsolete.c:137:      MPI_Recv(AUo[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,rootid,E->parallel.world,&status);
Regional_obsolete.c:153:  const int dims = E->mesh.nsd;
Regional_obsolete.c:161:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:162:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:167:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:169:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:171:    RV = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Regional_obsolete.c:174:    rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Regional_obsolete.c:176:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:185:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:186:    if (E->parallel.me!=rootid)
Regional_obsolete.c:187:      MPI_Send(AUi[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:189:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:191:	  MPI_Recv(RV,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:193:	  for (node=0;node<E->lmesh.NEQ[lev];node++)
Regional_obsolete.c:196:	for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:197:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:198:	  for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:199:	    for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:200:	      node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:201:	      node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:229:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:230:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:235:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:236:    NNO = NOZ*E->lmesh.NOX[lev]*E->lmesh.NOY[lev];
Regional_obsolete.c:238:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:239:    RV = (float *)malloc((E->lmesh.NNO[lev]+2)*sizeof(float));
Regional_obsolete.c:242:    rootid = E->parallel.me_sph*E->parallel.nprocz; /* which is the bottom cpu */
Regional_obsolete.c:244:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:253:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:254:    if (E->parallel.me!=rootid) {
Regional_obsolete.c:255:      MPI_Send(AUi[m],E->lmesh.NNO[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:260:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:262:	  MPI_Recv(RV,E->lmesh.NNO[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:264:	  for (node=1;node<=E->lmesh.NNO[lev];node++)
Regional_obsolete.c:267:	for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:268:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:269:	  for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:270:	    for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:271:	      node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:272:	      node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:297:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:298:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:303:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz;
Regional_obsolete.c:304:    NNO = NOZ*E->lmesh.ELX[lev]*E->lmesh.ELY[lev];
Regional_obsolete.c:306:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:307:    RV = (float *)malloc((E->lmesh.NEL[lev]+2)*sizeof(float));
Regional_obsolete.c:310:    rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Regional_obsolete.c:312:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:321:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:322:    if (E->parallel.me!=rootid) {
Regional_obsolete.c:323:      MPI_Send(AUi[m],E->lmesh.NEL[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:328:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:330:	  MPI_Recv(RV,E->lmesh.NEL[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:332:	  for (e=1;e<=E->lmesh.NEL[lev];e++)
Regional_obsolete.c:335:	for (k=1;k<=E->lmesh.ELZ[lev];k++)   {
Regional_obsolete.c:336:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:337:	  for (j=1;j<=E->lmesh.ELY[lev];j++)
Regional_obsolete.c:338:	    for (i=1;i<=E->lmesh.ELX[lev];i++)   {
Regional_obsolete.c:339:	      e = k + (i-1)*E->lmesh.ELZ[lev] + (j-1)*E->lmesh.ELZ[lev]*E->lmesh.ELX[lev];
Regional_obsolete.c:340:	      e1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.ELX[lev];
Regional_obsolete.c:366:  if (E->parallel.nprocxy==1)   return;
Regional_obsolete.c:368:  nsl = E->sphere.nsf+1;
Regional_obsolete.c:369:  me = E->parallel.me;
Regional_obsolete.c:373:    for (i=1;i<E->parallel.nprocxy;i++)
Regional_obsolete.c:374:      RG[i] = ( float *)malloc((E->sphere.nsf+1)*sizeof(float));
Regional_obsolete.c:378:  for (i=1;i<=E->parallel.nprocxy;i++)  {
Regional_obsolete.c:379:    to_everyone = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Regional_obsolete.c:384:      MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Regional_obsolete.c:391:  for (i=1;i<=E->parallel.nprocxy;i++)  {
Regional_obsolete.c:392:    from_proc = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Regional_obsolete.c:396:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Regional_obsolete.c:402:  for (i=1;i<E->parallel.nprocxy;i++)
Regional_obsolete.c:403:    for (j=1;j<=E->sphere.nsf; j++)  {
Regional_obsolete.c:431:  nox=E->lmesh.nox;
Regional_obsolete.c:432:  noz=E->lmesh.noz;
Regional_obsolete.c:433:  noy=E->lmesh.noy;
Regional_obsolete.c:434:  lev=E->mesh.levmax;
Regional_obsolete.c:446:  if(E->advection.timesteps>1)  {
Regional_obsolete.c:447:    fxx1=fxx1+E->advection.timestep*vxx1;
Regional_obsolete.c:448:    fxx2=fxx2+E->advection.timestep*vxx1;
Regional_obsolete.c:458:  if (E->parallel.me_loc[3] == E->parallel.nprocz-1 ) {
Regional_obsolete.c:462:	fyy=E->SX[lev][1][1][nodel];
Regional_obsolete.c:464:	  E->sphere.cap.VB[1][nodel]=0.0;
Regional_obsolete.c:465:	  E->sphere.cap.VB[2][nodel]=-vvc;
Regional_obsolete.c:466:	  E->sphere.cap.VB[3][nodel]=0.0;
Regional_obsolete.c:469:	  if (E->SX[lev][1][2][nodel]>=0.00 && E->SX[lev][1][2][nodel]<= fxx1) {
Regional_obsolete.c:470:	    E->sphere.cap.VB[1][nodel]=0.0;
Regional_obsolete.c:471:	    E->sphere.cap.VB[2][nodel]=vvo;
Regional_obsolete.c:472:	    E->sphere.cap.VB[3][nodel]=0.0;
Regional_obsolete.c:474:	  else if ( E->SX[lev][1][2][nodel]>fxx1 && E->SX[lev][1][2][nodel]<fxx2) {
Regional_obsolete.c:475:	    E->sphere.cap.VB[1][nodel]=0.0;
Regional_obsolete.c:476:	    E->sphere.cap.VB[2][nodel]=vxx1;
Regional_obsolete.c:477:	    E->sphere.cap.VB[3][nodel]=0.0;
Regional_obsolete.c:479:	  else if ( E->SX[lev][1][2][nodel]>=fxx2) {
Regional_obsolete.c:480:	    E->sphere.cap.VB[1][nodel]=0.0;
Regional_obsolete.c:481:	    E->sphere.cap.VB[2][nodel]=vvc;
Regional_obsolete.c:482:	    E->sphere.cap.VB[3][nodel]=0.0;
Regional_obsolete.c:487:  }    /* end of E->parallel.me_loc[3]   */
Regional_obsolete.c:507:  size2= (E->lmesh.nno+1)*sizeof(float);
Regional_obsolete.c:509:  sprintf(output_file,"%s.%05d.SZZ",E->control.data_file,file_number);
Regional_obsolete.c:532:  if (E->parallel.me==proc_loc)  {
Regional_obsolete.c:534:    sprintf(output_file,"%s.%s_intp",E->control.data_file,filen);
Regional_obsolete.c:537:      fprintf(E->fp,"(Output.c #7) Cannot open %s\n",output_file);
Regional_obsolete.c:540:    for (i=E->sphere.nox;i>=1;i--)
Regional_obsolete.c:541:      for (j=1;j<=E->sphere.noy;j++)  {
Regional_obsolete.c:542:        node = i + (j-1)*E->sphere.nox;
Regional_obsolete.c:543:        t = 90-E->sphere.sx[1][node]*rad;
Regional_obsolete.c:544:        f = E->sphere.sx[2][node]*rad;
Regional_obsolete.c:550:    fprintf(E->fp,"lmaxx=%.4e lminx=%.4e for %s\n",maxx,minx,filen);
Regional_obsolete.c:553:    sprintf(output_file,"%s.%s_sharm",E->control.data_file,filen);
Regional_obsolete.c:556:      fprintf(E->fp,"(Output.c #8) Cannot open %s\n",output_file);
Regional_obsolete.c:561:    for (ll=0;ll<=E->output.llmax;ll++)
Regional_obsolete.c:563:        i = E->sphere.hindex[ll][mm];
Regional_obsolete.c:590:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)      {
Regional_obsolete.c:591:    sprintf(output_file,"%s.surf.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:594:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_obsolete.c:595:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Regional_obsolete.c:596:      for(i=1;i<=E->lmesh.nsf;i++)   {
Regional_obsolete.c:597:	s = i*E->lmesh.noz;
Regional_obsolete.c:598:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpg[j][i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Regional_obsolete.c:605:  if (E->parallel.me_loc[3]==0)      {
Regional_obsolete.c:606:    sprintf(output_file,"%s.botm.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:609:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_obsolete.c:610:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Regional_obsolete.c:611:      for(i=1;i<=E->lmesh.nsf;i++)  {
Regional_obsolete.c:612:	s = (i-1)*E->lmesh.noz + 1;
Regional_obsolete.c:613:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Regional_obsolete.c:620:/*    if (E->parallel.me<E->parallel.nprocz)  { */
Regional_obsolete.c:621:/*      sprintf(output_file,"%s.ave_r.%d.%d",E->control.data_file,E->parallel.me,cycles); */
Regional_obsolete.c:624:/*            fprintf(E->fp,"(Output.c #6) Cannot open %s\n",output_file); */
Regional_obsolete.c:627:/*      for(j=1;j<=E->lmesh.noz;j++)  { */
Regional_obsolete.c:628:/*          fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]); */
Regional_obsolete.c:656:  const int lev = E->mesh.levmax;
Regional_obsolete.c:657:  const int nsd = E->mesh.nsd;
Regional_obsolete.c:663:  // E->sphere.caps_per_proc. Later, when elemental viscosity is written
Regional_obsolete.c:670:  int size2 = (E->lmesh.nel+1)*sizeof(float);
Regional_obsolete.c:673:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:674:    VN[m]=(float *)malloc((1+E->lmesh.nel*vpts)*sizeof(float));
Regional_obsolete.c:679:  for(i=1;i<=E->lmesh.nel;i++)
Regional_obsolete.c:686:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:701:  sprintf(output_file,"%s.visc.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:704:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:705:    VE[m]=(float *)malloc((1+E->lmesh.nno)*sizeof(float));
Regional_obsolete.c:710:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Regional_obsolete.c:711:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Regional_obsolete.c:712:    for(i=1;i<=E->lmesh.nno;i++)
Regional_obsolete.c:716:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:740:    record_h = E->control.record_every/10;  */
Regional_obsolete.c:741:    record_h = E->control.record_every;
Regional_obsolete.c:744:/*    if ( ((ii % record_h) == 0) || E->control.DIRECTII)    { */
Regional_obsolete.c:746:    if ( (ii == 0) || ((ii % record_h) == 0) || E->control.DIRECTII)    {
Regional_obsolete.c:752:/*    if ( ((ii % E->control.record_every) == 0) || E->control.DIRECTII)  { */
Regional_obsolete.c:753:    if ( ((ii == 0) || ((ii % E->control.record_every) == 0))
Regional_obsolete.c:754:		|| E->control.DIRECTII)     {
Regional_obsolete.c:777:    if ( (ii == 0) || ((ii % E->control.record_every) == 0)
Regional_obsolete.c:778:		|| E->control.DIRECTII)     {
Regional_obsolete.c:779:      get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,ii);
Regional_obsolete.c:798:  const int dims=E->mesh.nsd;
Regional_obsolete.c:800:  const int nno=E->lmesh.nno;
Regional_obsolete.c:802:  lev = E->mesh.levmax;
Regional_obsolete.c:804:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_obsolete.c:806:      if (node%E->lmesh.noz==0)   {
Regional_obsolete.c:807:        i = node/E->lmesh.noz;
Regional_obsolete.c:808:        SV[(i-1)*2+1] = E->sphere.cap[m].V[1][node];
Regional_obsolete.c:809:        SV[(i-1)*2+2] = E->sphere.cap[m].V[2][node];
Regional_parallel_related.c:54:  me = E->parallel.me;
Regional_parallel_related.c:56:  surf_proc_per_cap = E->parallel.nprocx * E->parallel.nprocy;
Regional_parallel_related.c:57:  proc_per_cap = surf_proc_per_cap * E->parallel.nprocz;
Regional_parallel_related.c:58:  total_proc = E->sphere.caps * proc_per_cap;
Regional_parallel_related.c:59:  E->parallel.total_surf_proc = E->sphere.caps * surf_proc_per_cap;
Regional_parallel_related.c:61:  if ( total_proc != E->parallel.nproc ) {
Regional_parallel_related.c:62:    if (E->parallel.me==0) fprintf(stderr,"!!!! # of requested CPU is incorrect \n");
Regional_parallel_related.c:68:  j = me % E->parallel.nprocz;
Regional_parallel_related.c:69:  E->parallel.me_loc[3] = j;
Regional_parallel_related.c:72:  k = (me - j)/E->parallel.nprocz % E->parallel.nprocx;
Regional_parallel_related.c:73:  E->parallel.me_loc[1] = k;
Regional_parallel_related.c:76:  i = ((me - j)/E->parallel.nprocz - k)/E->parallel.nprocx % E->parallel.nprocy;
Regional_parallel_related.c:77:  E->parallel.me_loc[2] = i;
Regional_parallel_related.c:80:  pid_surf = me/E->parallel.nprocz;
Regional_parallel_related.c:83:  E->sphere.capid = 1;
Regional_parallel_related.c:86:  E->parallel.loc2proc_map = (int ****) malloc(E->sphere.caps*sizeof(int ***));
Regional_parallel_related.c:87:  for (m=0;m<E->sphere.caps;m++)  {
Regional_parallel_related.c:88:    E->parallel.loc2proc_map[m] = (int ***) malloc(E->parallel.nprocx*sizeof(int **));
Regional_parallel_related.c:89:    for (i=0;i<E->parallel.nprocx;i++) {
Regional_parallel_related.c:90:      E->parallel.loc2proc_map[m][i] = (int **) malloc(E->parallel.nprocy*sizeof(int *));
Regional_parallel_related.c:91:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:92:	E->parallel.loc2proc_map[m][i][j] = (int *) malloc(E->parallel.nprocz*sizeof(int));
Regional_parallel_related.c:96:  for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:97:    for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:98:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:99:        for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:100:          E->parallel.loc2proc_map[m][i][j][k] = m*proc_per_cap
Regional_parallel_related.c:101:            + j*E->parallel.nprocx*E->parallel.nprocz
Regional_parallel_related.c:102:            + i*E->parallel.nprocz + k;
Regional_parallel_related.c:105:  if (E->control.verbose) {
Regional_parallel_related.c:106:    fprintf(E->fp_out,"me=%d loc1=%d loc2=%d loc3=%d\n",me,
Regional_parallel_related.c:107:            E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3]);
Regional_parallel_related.c:108:    fprintf(E->fp_out,"capid=%d\n",j,E->sphere.capid);
Regional_parallel_related.c:109:    for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:110:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:111:        for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:112:          for (k=0;k<E->parallel.nprocz;k++)
Regional_parallel_related.c:113:            fprintf(E->fp_out,"loc2proc_map[cap=%d][x=%d][y=%d][z=%d] = %d\n",
Regional_parallel_related.c:114:                    m,i,j,k,E->parallel.loc2proc_map[m][i][j][k]);
Regional_parallel_related.c:116:    fflush(E->fp_out);
Regional_parallel_related.c:122:  E->exchange_node_d = exchange_node_d;
Regional_parallel_related.c:123:  E->exchange_node_f = exchange_node_f;
Regional_parallel_related.c:132:  processors = (int *) malloc((E->parallel.total_surf_proc+1)*sizeof(int));
Regional_parallel_related.c:134:  k = E->parallel.me_loc[3];
Regional_parallel_related.c:136:  for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:137:    for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:138:      for (j=0;j<E->parallel.nprocy;j++) {
Regional_parallel_related.c:139:        processors[n] = E->parallel.loc2proc_map[m][i][j][k];
Regional_parallel_related.c:143:  if (E->control.verbose) {
Regional_parallel_related.c:144:    fprintf(E->fp_out,"horizontal group of me=%d loc3=%d\n",E->parallel.me,E->parallel.me_loc[3]);
Regional_parallel_related.c:145:    for (j=0;j<E->parallel.total_surf_proc;j++) {
Regional_parallel_related.c:146:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Regional_parallel_related.c:148:    fflush(E->fp_out);
Regional_parallel_related.c:151:  MPI_Comm_group(E->parallel.world, &world_g);
Regional_parallel_related.c:152:  MPI_Group_incl(world_g, E->parallel.total_surf_proc, processors, &horizon_g);
Regional_parallel_related.c:153:  MPI_Comm_create(E->parallel.world, horizon_g, &(E->parallel.horizontal_comm));
Regional_parallel_related.c:169:  processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_parallel_related.c:173:  m = E->sphere.capid - 1;  /* assume 1 cap per proc. */
Regional_parallel_related.c:174:  i = E->parallel.me_loc[1];
Regional_parallel_related.c:175:  j = E->parallel.me_loc[2];
Regional_parallel_related.c:177:  for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:178:      processors[k] = E->parallel.loc2proc_map[m][i][j][k];
Regional_parallel_related.c:181:  if (E->control.verbose) {
Regional_parallel_related.c:182:    fprintf(E->fp_out,"vertical group of me=%d loc1=%d loc2=%d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2]);
Regional_parallel_related.c:183:    for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:184:      fprintf(E->fp_out,"%d proc=%d\n",k,processors[k]);
Regional_parallel_related.c:186:    fflush(E->fp_out);
Regional_parallel_related.c:189:  MPI_Comm_group(E->parallel.world, &world_g);
Regional_parallel_related.c:190:  MPI_Group_incl(world_g, E->parallel.nprocz, processors, &vertical_g);
Regional_parallel_related.c:191:  MPI_Comm_create(E->parallel.world, vertical_g, &(E->parallel.vertical_comm));
Regional_parallel_related.c:206:  me = E->parallel.me;
Regional_parallel_related.c:208:  E->lmesh.elx = E->mesh.elx/E->parallel.nprocx;
Regional_parallel_related.c:209:  E->lmesh.elz = E->mesh.elz/E->parallel.nprocz;
Regional_parallel_related.c:210:  E->lmesh.ely = E->mesh.ely/E->parallel.nprocy;
Regional_parallel_related.c:211:  E->lmesh.nox = E->lmesh.elx + 1;
Regional_parallel_related.c:212:  E->lmesh.noz = E->lmesh.elz + 1;
Regional_parallel_related.c:213:  E->lmesh.noy = E->lmesh.ely + 1;
Regional_parallel_related.c:215:  E->lmesh.exs = E->parallel.me_loc[1]*E->lmesh.elx;
Regional_parallel_related.c:216:  E->lmesh.eys = E->parallel.me_loc[2]*E->lmesh.ely;
Regional_parallel_related.c:217:  E->lmesh.ezs = E->parallel.me_loc[3]*E->lmesh.elz;
Regional_parallel_related.c:218:  E->lmesh.nxs = E->parallel.me_loc[1]*E->lmesh.elx+1;
Regional_parallel_related.c:219:  E->lmesh.nys = E->parallel.me_loc[2]*E->lmesh.ely+1;
Regional_parallel_related.c:220:  E->lmesh.nzs = E->parallel.me_loc[3]*E->lmesh.elz+1;
Regional_parallel_related.c:222:  E->lmesh.nno = E->lmesh.noz*E->lmesh.nox*E->lmesh.noy;
Regional_parallel_related.c:223:  E->lmesh.nel = E->lmesh.ely*E->lmesh.elx*E->lmesh.elz;
Regional_parallel_related.c:224:  E->lmesh.npno = E->lmesh.nel;
Regional_parallel_related.c:226:  E->lmesh.nsf = E->lmesh.nno/E->lmesh.noz;
Regional_parallel_related.c:227:  E->lmesh.snel = E->lmesh.elx*E->lmesh.ely;
Regional_parallel_related.c:230:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   {
Regional_parallel_related.c:232:     if (E->control.NMULTIGRID)  {
Regional_parallel_related.c:233:        nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:234:        noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:235:        noz = E->lmesh.elz/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Regional_parallel_related.c:236:        E->parallel.redundant[i]=0;
Regional_parallel_related.c:239:        { noz = E->lmesh.noz;
Regional_parallel_related.c:240:          noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:241:          nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:242:          if(i<E->mesh.levmax) noz=2;
Regional_parallel_related.c:245:     E->lmesh.ELX[i] = nox-1;
Regional_parallel_related.c:246:     E->lmesh.ELY[i] = noy-1;
Regional_parallel_related.c:247:     E->lmesh.ELZ[i] = noz-1;
Regional_parallel_related.c:248:     E->lmesh.NOZ[i] = noz;
Regional_parallel_related.c:249:     E->lmesh.NOY[i] = noy;
Regional_parallel_related.c:250:     E->lmesh.NOX[i] = nox;
Regional_parallel_related.c:251:     E->lmesh.NNO[i] = nox * noz * noy;
Regional_parallel_related.c:252:     E->lmesh.NNOV[i] = E->lmesh.NNO[i];
Regional_parallel_related.c:253:     E->lmesh.SNEL[i] = E->lmesh.ELX[i]*E->lmesh.ELY[i];
Regional_parallel_related.c:255:     E->lmesh.NEL[i] = (nox-1) * (noz-1) * (noy-1);
Regional_parallel_related.c:256:     E->lmesh.NPNO[i] = E->lmesh.NEL[i] ;
Regional_parallel_related.c:258:     E->lmesh.NEQ[i] = E->mesh.nsd * E->lmesh.NNOV[i] ;
Regional_parallel_related.c:260:     E->lmesh.EXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i];
Regional_parallel_related.c:261:     E->lmesh.EYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i];
Regional_parallel_related.c:262:     E->lmesh.EZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i];
Regional_parallel_related.c:263:     E->lmesh.NXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i]+1;
Regional_parallel_related.c:264:     E->lmesh.NYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i]+1;
Regional_parallel_related.c:265:     E->lmesh.NZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i]+1;
Regional_parallel_related.c:285:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)   {
Regional_parallel_related.c:286:      nel = E->lmesh.NEL[lev];
Regional_parallel_related.c:287:      elx = E->lmesh.ELX[lev];
Regional_parallel_related.c:288:      elz = E->lmesh.ELZ[lev];
Regional_parallel_related.c:289:      ely = E->lmesh.ELY[lev];
Regional_parallel_related.c:290:      nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:291:      noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:292:      noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:293:      nno = E->lmesh.NNO[lev];
Regional_parallel_related.c:301:        E->parallel.NODE[lev][++lnode].bound[ii] =  node;
Regional_parallel_related.c:302:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Regional_parallel_related.c:305:      E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Regional_parallel_related.c:313:        E->parallel.NODE[lev][++lnode].bound[ii] =  node;
Regional_parallel_related.c:314:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Regional_parallel_related.c:317:      E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Regional_parallel_related.c:326:        E->parallel.NODE[lev][++lnode].bound[ii] = node;
Regional_parallel_related.c:327:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Regional_parallel_related.c:330:      E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Regional_parallel_related.c:337:        E->parallel.NODE[lev][++lnode].bound[ii] = node;
Regional_parallel_related.c:338:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Regional_parallel_related.c:341:      E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Regional_parallel_related.c:350:        E->parallel.NODE[lev][++lnode].bound[ii] = node;
Regional_parallel_related.c:351:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Regional_parallel_related.c:354:      E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Regional_parallel_related.c:361:        E->parallel.NODE[lev][++lnode].bound[ii] = node;
Regional_parallel_related.c:362:        E->NODE[lev][node] = E->NODE[lev][node] | OFFSIDE;
Regional_parallel_related.c:365:      E->parallel.NUM_NNO[lev].bound[ii] = lnode;
Regional_parallel_related.c:369:    if (E->parallel.me_loc[1]!=E->parallel.nprocx-1)
Regional_parallel_related.c:370:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev].bound[2];lnode++) {
Regional_parallel_related.c:371:        node = E->parallel.NODE[lev][lnode].bound[2];
Regional_parallel_related.c:372:        E->NODE[lev][node] = E->NODE[lev][node] | SKIP;
Regional_parallel_related.c:375:    if (E->parallel.me_loc[2]!=E->parallel.nprocy-1)
Regional_parallel_related.c:376:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev].bound[4];lnode++) {
Regional_parallel_related.c:377:        node = E->parallel.NODE[lev][lnode].bound[4];
Regional_parallel_related.c:378:        E->NODE[lev][node] = E->NODE[lev][node] | SKIP;
Regional_parallel_related.c:381:    if (E->parallel.me_loc[3]!=E->parallel.nprocz-1)
Regional_parallel_related.c:382:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev].bound[6];lnode++) {
Regional_parallel_related.c:383:        node = E->parallel.NODE[lev][lnode].bound[6];
Regional_parallel_related.c:384:        E->NODE[lev][node] = E->NODE[lev][node] | SKIP;
Regional_parallel_related.c:390:if (E->control.verbose) {
Regional_parallel_related.c:391: fprintf(E->fp_out,"output_shared_nodes %d \n",E->parallel.me);
Regional_parallel_related.c:392: for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Regional_parallel_related.c:393:    fprintf(E->fp_out,"lev=%d  me=%d capid=%d \n",lev,E->parallel.me,E->sphere.capid);
Regional_parallel_related.c:395:      for (i=1;i<=E->parallel.NUM_NNO[lev].bound[ii];i++)
Regional_parallel_related.c:396:        fprintf(E->fp_out,"ii=%d   %d %d \n",ii,i,E->parallel.NODE[lev][i].bound[ii]);
Regional_parallel_related.c:399:    for (node=1;node<=E->lmesh.NNO[lev];node++)
Regional_parallel_related.c:400:      if((E->NODE[lev][node] & SKIP)) {
Regional_parallel_related.c:402:        fprintf(E->fp_out,"skip %d %d \n",lnode,node);
Regional_parallel_related.c:404: fflush(E->fp_out);
Regional_parallel_related.c:426:  const int dims=E->mesh.nsd;
Regional_parallel_related.c:428:  me = E->parallel.me;
Regional_parallel_related.c:429:  nproczl = E->parallel.nprocz;
Regional_parallel_related.c:430:  nprocyl = E->parallel.nprocy;
Regional_parallel_related.c:431:  nprocxl = E->parallel.nprocx;
Regional_parallel_related.c:432:  lx = E->parallel.me_loc[1];
Regional_parallel_related.c:433:  ly = E->parallel.me_loc[2];
Regional_parallel_related.c:434:  lz = E->parallel.me_loc[3];
Regional_parallel_related.c:437:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Regional_parallel_related.c:438:    nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:439:    noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:440:    noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:445:      cap = E->sphere.capid - 1;  /* which cap I am in (0~11) */
Regional_parallel_related.c:450:        E->parallel.NUM_PASS[lev].bound[ii] = 1;
Regional_parallel_related.c:451:        if(E->parallel.me_loc[1]==0 && i==1)
Regional_parallel_related.c:452:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:453:        else if(E->parallel.me_loc[1]==nprocxl-1 && i==2)
Regional_parallel_related.c:454:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:456:        if (E->parallel.NUM_PASS[lev].bound[ii] == 1)  {
Regional_parallel_related.c:460:          /*E->parallel.PROCESSOR[lev].pass[kkk]=me-((i==1)?1:-1)*nproczl; */
Regional_parallel_related.c:462:          E->parallel.PROCESSOR[lev].pass[kkk]=E->parallel.loc2proc_map[cap][lx-dir][ly][lz];
Regional_parallel_related.c:464:              E->parallel.NUM_NODE[lev].pass[kkk] = E->parallel.NUM_NNO[lev].bound[ii];
Regional_parallel_related.c:466:          for (k=1;k<=E->parallel.NUM_NODE[lev].pass[kkk];k++)   {
Regional_parallel_related.c:468:            node = E->parallel.NODE[lev][lnode].bound[ii];
Regional_parallel_related.c:469:            E->parallel.EXCHANGE_NODE[lev][k].pass[kkk] = node;
Regional_parallel_related.c:473:                         E->parallel.EXCHANGE_ID[lev][++jj].pass[kkk] = E->ID[lev][node].doff[doff];
Regional_parallel_related.c:476:              E->parallel.NUM_NEQ[lev].pass[kkk] = jj;
Regional_parallel_related.c:484:        E->parallel.NUM_PASS[lev].bound[ii] = 1;
Regional_parallel_related.c:485:        if(E->parallel.me_loc[2]==0 && k==1)
Regional_parallel_related.c:486:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:487:        else if(E->parallel.me_loc[2]==nprocyl-1 && k==2)
Regional_parallel_related.c:488:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:490:        if(E->parallel.NUM_PASS[lev].bound[ii] == 1)  {
Regional_parallel_related.c:495:          /*E->parallel.PROCESSOR[lev].pass[kkk]=me-((k==1)?1:-1)*nprocxl*nproczl; */
Regional_parallel_related.c:497:          E->parallel.PROCESSOR[lev].pass[kkk]=E->parallel.loc2proc_map[cap][lx][ly-dir][lz];
Regional_parallel_related.c:499:          E->parallel.NUM_NODE[lev].pass[kkk] = E->parallel.NUM_NNO[lev].bound[ii];
Regional_parallel_related.c:502:          for (kk=1;kk<=E->parallel.NUM_NODE[lev].pass[kkk];kk++)   {
Regional_parallel_related.c:504:            node = E->parallel.NODE[lev][lnode].bound[ii];
Regional_parallel_related.c:505:            E->parallel.EXCHANGE_NODE[lev][kk].pass[kkk] = node;
Regional_parallel_related.c:508:                         E->parallel.EXCHANGE_ID[lev][++jj].pass[kkk] = E->ID[lev][node].doff[doff];
Regional_parallel_related.c:511:              E->parallel.NUM_NEQ[lev].pass[kkk] = jj;
Regional_parallel_related.c:520:        E->parallel.NUM_PASS[lev].bound[ii] = 1;
Regional_parallel_related.c:521:        if(E->parallel.me_loc[3]==0 && j==1)
Regional_parallel_related.c:522:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:523:        else if(E->parallel.me_loc[3]==nproczl-1 && j==2)
Regional_parallel_related.c:524:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:526:        if(E->parallel.NUM_PASS[lev].bound[ii] == 1)  {
Regional_parallel_related.c:530:          /*E->parallel.PROCESSOR[lev].pass[kkk]=me-((j==1)?1:-1);*/
Regional_parallel_related.c:532:          E->parallel.PROCESSOR[lev].pass[kkk]=E->parallel.loc2proc_map[cap][lx][ly][lz-dir];
Regional_parallel_related.c:534:          E->parallel.NUM_NODE[lev].pass[kkk] = E->parallel.NUM_NNO[lev].bound[ii];
Regional_parallel_related.c:537:          for (kk=1;kk<=E->parallel.NUM_NODE[lev].pass[kkk];kk++)   {
Regional_parallel_related.c:539:            node = E->parallel.NODE[lev][lnode].bound[ii];
Regional_parallel_related.c:540:            E->parallel.EXCHANGE_NODE[lev][kk].pass[kkk] = node;
Regional_parallel_related.c:543:                         E->parallel.EXCHANGE_ID[lev][++jj].pass[kkk] = E->ID[lev][node].doff[doff];
Regional_parallel_related.c:546:              E->parallel.NUM_NEQ[lev].pass[kkk] = jj;
Regional_parallel_related.c:553:      E->parallel.TNUM_PASS[lev] = kkk;
Regional_parallel_related.c:558:  if(E->control.verbose) {
Regional_parallel_related.c:559:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Regional_parallel_related.c:560:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Regional_parallel_related.c:561:    fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid,E->parallel.TNUM_PASS[lev]);
Regional_parallel_related.c:562:    for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Regional_parallel_related.c:563:      fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d eqn and %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev].pass[k],E->parallel.NUM_NEQ[lev].pass[k],E->parallel.NUM_NODE[lev].pass[k]);
Regional_parallel_related.c:567:    fflush(E->fp_out);
Regional_parallel_related.c:587:  const int dims=E->mesh.nsd;
Regional_parallel_related.c:589:  me = E->parallel.me;
Regional_parallel_related.c:590:  nprocz = E->parallel.nprocz;
Regional_parallel_related.c:592:  nprocxl = E->parallel.nprocx;
Regional_parallel_related.c:593:  nprocyl = E->parallel.nprocy;
Regional_parallel_related.c:594:  nproczl = E->parallel.nprocz;
Regional_parallel_related.c:598:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Regional_parallel_related.c:599:    nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:600:    noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:601:    noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:609:        E->parallel.NUM_PASS[lev].bound[ii] = 1;
Regional_parallel_related.c:610:        if(E->parallel.me_loc[1]==0 && i==1)
Regional_parallel_related.c:611:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:612:        else if(E->parallel.me_loc[1]==nprocxl-1 && i==2)
Regional_parallel_related.c:613:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:615:        for (p=1;p<=E->parallel.NUM_PASS[lev].bound[ii];p++)  {
Regional_parallel_related.c:619:          E->parallel.sPROCESSOR[lev].pass[kkk]=me-((i==1)?1:-1)*nproczl;
Regional_parallel_related.c:621:              E->parallel.NUM_sNODE[lev].pass[kkk] =
Regional_parallel_related.c:622:                          E->parallel.NUM_NNO[lev].bound[ii]/noz;
Regional_parallel_related.c:623:          for (k=1;k<=E->parallel.NUM_sNODE[lev].pass[kkk];k++)   {
Regional_parallel_related.c:625:            node = (E->parallel.NODE[lev][lnode].bound[ii]-1)/noz+1;
Regional_parallel_related.c:626:            E->parallel.EXCHANGE_sNODE[lev][k].pass[kkk] = node;
Regional_parallel_related.c:636:        E->parallel.NUM_PASS[lev].bound[ii] = 1;
Regional_parallel_related.c:637:        if(E->parallel.me_loc[2]==0 && k==1)
Regional_parallel_related.c:638:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:639:        else if(E->parallel.me_loc[2]==nprocyl-1 && k==2)
Regional_parallel_related.c:640:          E->parallel.NUM_PASS[lev].bound[ii] = 0;
Regional_parallel_related.c:642:        for (p=1;p<=E->parallel.NUM_PASS[lev].bound[ii];p++)  {
Regional_parallel_related.c:647:          E->parallel.sPROCESSOR[lev].pass[kkk]=me-((k==1)?1:-1)*nprocxl*nproczl;
Regional_parallel_related.c:649:              E->parallel.NUM_sNODE[lev].pass[kkk] =
Regional_parallel_related.c:650:                          E->parallel.NUM_NNO[lev].bound[ii]/noz;
Regional_parallel_related.c:652:          for (kk=1;kk<=E->parallel.NUM_sNODE[lev].pass[kkk];kk++)   {
Regional_parallel_related.c:654:            node = (E->parallel.NODE[lev][lnode].bound[ii]-1)/noz+1;
Regional_parallel_related.c:655:            E->parallel.EXCHANGE_sNODE[lev][kk].pass[kkk] = node;
Regional_parallel_related.c:663:    E->parallel.sTNUM_PASS[lev] = kkk;
Regional_parallel_related.c:678:   for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Regional_parallel_related.c:679:     sizeofk = (1+E->parallel.NUM_NEQ[lev].pass[k])*sizeof(double);
Regional_parallel_related.c:684:   for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Regional_parallel_related.c:686:     for (j=1;j<=E->parallel.NUM_NEQ[lev].pass[k];j++)
Regional_parallel_related.c:687:       S[k][j-1] = U[ E->parallel.EXCHANGE_ID[lev][j].pass[k] ];
Regional_parallel_related.c:689:     MPI_Sendrecv(S[k],E->parallel.NUM_NEQ[lev].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:690:		  E->parallel.PROCESSOR[lev].pass[k],1,
Regional_parallel_related.c:691:		  R[k],E->parallel.NUM_NEQ[lev].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:692:		  E->parallel.PROCESSOR[lev].pass[k],1,
Regional_parallel_related.c:693:		  E->parallel.world,&status);
Regional_parallel_related.c:695:     for (j=1;j<=E->parallel.NUM_NEQ[lev].pass[k];j++)
Regional_parallel_related.c:696:       U[ E->parallel.EXCHANGE_ID[lev][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:700: for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Regional_parallel_related.c:716:   for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Regional_parallel_related.c:717:     sizeofk = (1+E->parallel.NUM_NODE[lev].pass[k])*sizeof(double);
Regional_parallel_related.c:722:   for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Regional_parallel_related.c:724:     for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Regional_parallel_related.c:725:       S[k][j-1] = U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ];
Regional_parallel_related.c:727:     MPI_Sendrecv(S[k],E->parallel.NUM_NODE[lev].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:728:		  E->parallel.PROCESSOR[lev].pass[k],1,
Regional_parallel_related.c:729:		  R[k],E->parallel.NUM_NODE[lev].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:730:		  E->parallel.PROCESSOR[lev].pass[k],1,
Regional_parallel_related.c:731:		  E->parallel.world,&status);
Regional_parallel_related.c:733:     for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Regional_parallel_related.c:734:       U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:737: for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Regional_parallel_related.c:752:   for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Regional_parallel_related.c:753:     sizeofk = (1+E->parallel.NUM_NODE[lev].pass[k])*sizeof(float);
Regional_parallel_related.c:759:   for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)   {
Regional_parallel_related.c:761:     for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Regional_parallel_related.c:762:       S[k][j-1] = U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ];
Regional_parallel_related.c:764:     MPI_Sendrecv(S[k],E->parallel.NUM_NODE[lev].pass[k],MPI_FLOAT,
Regional_parallel_related.c:765:		  E->parallel.PROCESSOR[lev].pass[k],1,
Regional_parallel_related.c:766:		  R[k],E->parallel.NUM_NODE[lev].pass[k],MPI_FLOAT,
Regional_parallel_related.c:767:		  E->parallel.PROCESSOR[lev].pass[k],1,
Regional_parallel_related.c:768:		  E->parallel.world,&status);
Regional_parallel_related.c:770:     for (j=1;j<=E->parallel.NUM_NODE[lev].pass[k];j++)
Regional_parallel_related.c:771:       U[ E->parallel.EXCHANGE_NODE[lev][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:775: for (k=1;k<=E->parallel.TNUM_PASS[lev];k++)  {
Regional_parallel_related.c:792:   for (k=1;k<=E->parallel.sTNUM_PASS[lev];k++)  {
Regional_parallel_related.c:793:     sizeofk = (1+2*E->parallel.NUM_sNODE[lev].pass[k])*sizeof(float);
Regional_parallel_related.c:798:   for (k=1;k<=E->parallel.sTNUM_PASS[lev];k++)  {
Regional_parallel_related.c:800:     for (j=1;j<=E->parallel.NUM_sNODE[lev].pass[k];j++)  {
Regional_parallel_related.c:801:       S[k][j-1] = U1[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ];
Regional_parallel_related.c:802:       S[k][j-1+E->parallel.NUM_sNODE[lev].pass[k]]
Regional_parallel_related.c:803:         = U2[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ];
Regional_parallel_related.c:806:     MPI_Sendrecv(S[k],2*E->parallel.NUM_sNODE[lev].pass[k],MPI_FLOAT,
Regional_parallel_related.c:807:		  E->parallel.sPROCESSOR[lev].pass[k],1,
Regional_parallel_related.c:808:		  R[k],2*E->parallel.NUM_sNODE[lev].pass[k],MPI_FLOAT,
Regional_parallel_related.c:809:		  E->parallel.sPROCESSOR[lev].pass[k],1,
Regional_parallel_related.c:810:		  E->parallel.world,&status);
Regional_parallel_related.c:812:     for (j=1;j<=E->parallel.NUM_sNODE[lev].pass[k];j++)   {
Regional_parallel_related.c:813:       U1[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:814:       U2[ E->parallel.EXCHANGE_sNODE[lev][j].pass[k] ] +=
Regional_parallel_related.c:815:         R[k][j-1+E->parallel.NUM_sNODE[lev].pass[k]];
Regional_parallel_related.c:820: for (k=1;k<=E->parallel.sTNUM_PASS[lev];k++)  {
Regional_read_input_from_files.c:57:    const int dims=E->mesh.nsd;
Regional_read_input_from_files.c:66:    /*if( E->parallel.me == 0)  
Regional_read_input_from_files.c:69:    nox=E->mesh.nox;
Regional_read_input_from_files.c:70:    noy=E->mesh.noy;
Regional_read_input_from_files.c:71:    noz=E->mesh.noz;
Regional_read_input_from_files.c:73:    nox1=E->lmesh.nox;
Regional_read_input_from_files.c:74:    noz1=E->lmesh.noz;
Regional_read_input_from_files.c:75:    noy1=E->lmesh.noy;
Regional_read_input_from_files.c:78:    elx=E->lmesh.elx;
Regional_read_input_from_files.c:79:    elz=E->lmesh.elz;
Regional_read_input_from_files.c:80:    ely=E->lmesh.ely;
Regional_read_input_from_files.c:82:    emax=E->mesh.elx*E->mesh.elz*E->mesh.ely;
Regional_read_input_from_files.c:102:      if(!E->control.ggrd.vtop_control){	/* regular input */
Regional_read_input_from_files.c:104:      sprintf(output_file1,"%s%0.0f",E->control.velocity_boundary_file,newage1);
Regional_read_input_from_files.c:105:      sprintf(output_file2,"%s%0.0f",E->control.velocity_boundary_file,newage2);
Regional_read_input_from_files.c:108:          fprintf(E->fp,"(Problem_related #4) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:114:          fprintf(E->fp,"(Problem_related #5) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:118:      if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:119:         fprintf(E->fp,"Velocity: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:120:         fprintf(E->fp,"Velocity: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:122:           fprintf(E->fp,"Velocity: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:124:           fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:133:      if(!E->control.ggrd.age_control){	/* regular input */
Regional_read_input_from_files.c:135:        sprintf(output_file1,"%s%0.0f",E->control.lith_age_file,newage1);
Regional_read_input_from_files.c:136:        sprintf(output_file2,"%s%0.0f",E->control.lith_age_file,newage2);
Regional_read_input_from_files.c:139:          fprintf(E->fp,"(Problem_related #6) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:145:            fprintf(E->fp,"(Problem_related #7) Cannot open %s\n",output_file2);            exit(8);
Regional_read_input_from_files.c:148:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:149:          fprintf(E->fp,"Age: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:150:          fprintf(E->fp,"Age: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:152:            fprintf(E->fp,"Age: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:154:            fprintf(E->fp,"Age: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:163:	if(E->control.ggrd.mat_control == 0 ){
Regional_read_input_from_files.c:165:        sprintf(output_file1,"%s%0.0f.0",E->control.mat_file,newage1);
Regional_read_input_from_files.c:166:        sprintf(output_file2,"%s%0.0f.0",E->control.mat_file,newage2);
Regional_read_input_from_files.c:169:          fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:175:            fprintf(E->fp,"(Problem_related #9) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:179:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:180:          fprintf(E->fp,"Mat: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:181:          fprintf(E->fp,"Mat: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:183:            fprintf(E->fp,"Mat: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:185:            fprintf(E->fp,"Mat: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:196:        sprintf(output_file1,"%s%0.0f",E->control.temperature_boundary_file,newage1);
Regional_read_input_from_files.c:197:        sprintf(output_file2,"%s%0.0f",E->control.temperature_boundary_file,newage2);
Regional_read_input_from_files.c:200:            fprintf(E->fp,"(Problem_related #10) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:206:            fprintf(E->fp,"(Problem_related #11) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:210:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:211:           fprintf(E->fp,"Surface Temperature: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:212:           fprintf(E->fp,"Surface Temperature: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:214:             fprintf(E->fp,"Surface Temperature: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:216:             fprintf(E->fp,"Surface Temperature: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:230:      if(!E->control.ggrd.vtop_control){ /* grd control is called from boundary condition file */
Regional_read_input_from_files.c:242:         VB1[1][i]=E->data.timedir*VB1[1][i];
Regional_read_input_from_files.c:243:         VB1[2][i]=E->data.timedir*VB1[2][i];
Regional_read_input_from_files.c:249:             VB2[1][i]=E->data.timedir*VB2[1][i];
Regional_read_input_from_files.c:250:             VB2[2][i]=E->data.timedir*VB2[2][i];
Regional_read_input_from_files.c:256:      if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Regional_read_input_from_files.c:259:                nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Regional_read_input_from_files.c:262:                    E->sphere.cap.VB[1][nodel] = (VB1[1][nodeg] + (VB2[1][nodeg]-VB1[1][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Regional_read_input_from_files.c:263:                    E->sphere.cap.VB[2][nodel] = (VB1[2][nodeg] + (VB2[2][nodeg]-VB1[2][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Regional_read_input_from_files.c:264:                    E->sphere.cap.VB[3][nodel] = 0.0;
Regional_read_input_from_files.c:267:                    E->sphere.cap.VB[1][nodel] = VB1[1][nodeg]*E->data.scalev;
Regional_read_input_from_files.c:268:                    E->sphere.cap.VB[2][nodel] = VB1[2][nodeg]*E->data.scalev;
Regional_read_input_from_files.c:269:                    E->sphere.cap.VB[3][nodel] = 0.0;
Regional_read_input_from_files.c:272:      }   /* end of E->parallel.me_loc[3]==E->parallel.nprocz-1   */
Regional_read_input_from_files.c:286:	if(E->control.ggrd.age_control){
Regional_read_input_from_files.c:302:              E->age_t[node] = (inputage1 + (inputage2-inputage1)/(newage2-newage1)*(age-newage1))/E->data.scalet;
Regional_read_input_from_files.c:305:              E->age_t[node] = inputage1;
Regional_read_input_from_files.c:317:	if(E->control.ggrd.mat_control != 0){
Regional_read_input_from_files.c:328:            nodea = E->ien[el].node[2];
Regional_read_input_from_files.c:331:              E->mat[el] = llayer;
Regional_read_input_from_files.c:353:                el = j + (i-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Regional_read_input_from_files.c:354:                elg = E->lmesh.ezs+j + (E->lmesh.exs+i-1)*E->mesh.elz + (E->lmesh.eys+k-1)*E->mesh.elz*E->mesh.elx;
Regional_read_input_from_files.c:356:                    E->VIP[el] = VIP1[elg]+(VIP2[elg]-VIP1[elg])/(newage2-newage1)*(age-newage1);
Regional_read_input_from_files.c:359:                    E->VIP[el] = VIP1[elg];
Regional_read_input_from_files.c:362:                /* E->mat[1][el] = LL1[elg]; */ /*use the mat numbers base on radius*/
Regional_read_input_from_files.c:378:      if(E->control.ggrd.ray_control)
Regional_read_input_from_files.c:395:         /* if( E->parallel.me == 0)  
Regional_read_input_from_files.c:407:      if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Regional_read_input_from_files.c:410:                nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Regional_read_input_from_files.c:413:                    E->sphere.cap.TB[1][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:414:                    E->sphere.cap.TB[2][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:415:                    E->sphere.cap.TB[3][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:418:                    E->sphere.cap.TB[1][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:419:                    E->sphere.cap.TB[2][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:420:                    E->sphere.cap.TB[3][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:423:      }   /* end of E->parallel.me_loc[3]==E->parallel.nprocz-1   */
Regional_solver.c:65:    E->solver.velocity_boundary_conditions = regional_velocity_boundary_conditions;
Regional_solver.c:66:    E->solver.temperature_boundary_conditions = regional_temperature_boundary_conditions;
Regional_solver.c:69:    E->solver.set_2dc_defaults = regional_set_2dc_defaults;
Regional_solver.c:70:    E->solver.set_2pt5dc_defaults = regional_set_2pt5dc_defaults;
Regional_solver.c:71:    E->solver.set_3dc_defaults = regional_set_3dc_defaults;
Regional_solver.c:72:    E->solver.set_3dsphere_defaults = regional_set_3dsphere_defaults;
Regional_solver.c:75:    E->solver.lith_age_read_files = regional_lith_age_read_files;
Regional_solver.c:78:    E->solver.parallel_processor_setup = regional_parallel_processor_setup;
Regional_solver.c:79:    E->solver.parallel_domain_decomp0 = regional_parallel_domain_decomp0;
Regional_solver.c:80:    E->solver.parallel_domain_boundary_nodes = regional_parallel_domain_boundary_nodes;
Regional_solver.c:81:    E->solver.parallel_communication_routs_v = regional_parallel_communication_routs_v;
Regional_solver.c:82:    E->solver.parallel_communication_routs_s = regional_parallel_communication_routs_s;
Regional_solver.c:83:    E->solver.exchange_id_d = regional_exchange_id_d;
Regional_solver.c:86:    E->solver.read_input_files_for_timesteps = regional_read_input_files_for_timesteps;
Regional_solver.c:89:    E->solver.node_locations = regional_node_locations;
Regional_solver.c:90:    E->solver.construct_boundary = regional_construct_boundary;
Regional_sphere_related.c:59:  gnox=E->mesh.nox;
Regional_sphere_related.c:60:  gnoy=E->mesh.noy;
Regional_sphere_related.c:61:  gnoz=E->mesh.noz;
Regional_sphere_related.c:62:  nox=E->lmesh.nox;
Regional_sphere_related.c:63:  noy=E->lmesh.noy;
Regional_sphere_related.c:64:  noz=E->lmesh.noz;
Regional_sphere_related.c:66:  nprocxl=E->parallel.nprocx;
Regional_sphere_related.c:67:  nprocyl=E->parallel.nprocy;
Regional_sphere_related.c:68:  nproczl=E->parallel.nprocz;
Regional_sphere_related.c:70:  temp = max(E->mesh.NOY[E->mesh.levmax],E->mesh.NOX[E->mesh.levmax]);
Regional_sphere_related.c:73:  E->sphere.cap.theta[1] = E->control.theta_min;
Regional_sphere_related.c:74:  E->sphere.cap.theta[2] = E->control.theta_max;
Regional_sphere_related.c:75:  E->sphere.cap.theta[3] = E->control.theta_max;
Regional_sphere_related.c:76:  E->sphere.cap.theta[4] = E->control.theta_min;
Regional_sphere_related.c:77:  E->sphere.cap.fi[1] = E->control.fi_min;
Regional_sphere_related.c:78:  E->sphere.cap.fi[2] = E->control.fi_min;
Regional_sphere_related.c:79:  E->sphere.cap.fi[3] = E->control.fi_max;
Regional_sphere_related.c:80:  E->sphere.cap.fi[4] = E->control.fi_max;
Regional_sphere_related.c:82:  if(E->control.coor==1) {
Regional_sphere_related.c:86:    for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)  {
Regional_sphere_related.c:91:    temp = E->mesh.NOY[E->mesh.levmax]*E->mesh.NOX[E->mesh.levmax];
Regional_sphere_related.c:93:    sprintf(output_file,"%s",E->control.coor_file);
Regional_sphere_related.c:96:      fprintf(E->fp,"(Sphere_related #1) Cannot open %s\n",output_file);
Regional_sphere_related.c:102:        if(fscanf(fp,"%d %e",&nn,&theta1[E->mesh.gridmax][i]) != 2) {
Regional_sphere_related.c:103:            fprintf(E->fp,"Error while reading coor_file '%s'\n",output_file);
Regional_sphere_related.c:107:    E->control.theta_min = theta1[E->mesh.gridmax][1];
Regional_sphere_related.c:108:    E->control.theta_max = theta1[E->mesh.gridmax][gnox];
Regional_sphere_related.c:112:        if(fscanf(fp,"%d %e",&nn,&fi1[E->mesh.gridmax][i]) != 2) {
Regional_sphere_related.c:113:            fprintf(E->fp,"Error while reading coor_file '%s'\n",output_file);
Regional_sphere_related.c:117:    E->control.fi_min = fi1[E->mesh.gridmax][1];
Regional_sphere_related.c:118:    E->control.fi_max = fi1[E->mesh.gridmax][gnoy];
Regional_sphere_related.c:123:    E->sphere.cap.theta[1] = E->control.theta_min;
Regional_sphere_related.c:124:    E->sphere.cap.theta[2] = E->control.theta_max;
Regional_sphere_related.c:125:    E->sphere.cap.theta[3] = E->control.theta_max;
Regional_sphere_related.c:126:    E->sphere.cap.theta[4] = E->control.theta_min;
Regional_sphere_related.c:127:    E->sphere.cap.fi[1] = E->control.fi_min;
Regional_sphere_related.c:128:    E->sphere.cap.fi[2] = E->control.fi_min;
Regional_sphere_related.c:129:    E->sphere.cap.fi[3] = E->control.fi_max;
Regional_sphere_related.c:130:    E->sphere.cap.fi[4] = E->control.fi_max;
Regional_sphere_related.c:132:    for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c:134:      if (E->control.NMULTIGRID)
Regional_sphere_related.c:135:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Regional_sphere_related.c:139:      for (i=1;i<=E->mesh.NOX[lev];i++)
Regional_sphere_related.c:140:	theta1[lev][i] = theta1[E->mesh.gridmax][(i-1)*step+1];
Regional_sphere_related.c:142:      for (i=1;i<=E->mesh.NOY[lev];i++)
Regional_sphere_related.c:143:	fi1[lev][i] = fi1[E->mesh.gridmax][(i-1)*step+1];
Regional_sphere_related.c:148:  for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c:149:     elx = E->lmesh.ELX[lev];
Regional_sphere_related.c:150:     ely = E->lmesh.ELY[lev];
Regional_sphere_related.c:151:     nox = E->lmesh.NOX[lev];
Regional_sphere_related.c:152:     noy = E->lmesh.NOY[lev];
Regional_sphere_related.c:153:     noz = E->lmesh.NOZ[lev];
Regional_sphere_related.c:160:             nodesx = E->lmesh.NXS[lev]+j-1;
Regional_sphere_related.c:161:             nodesy = E->lmesh.NYS[lev]+k-1;
Regional_sphere_related.c:167:                E->SX[lev][1][node] = theta1[lev][nodesx];
Regional_sphere_related.c:168:                E->SX[lev][2][node] = fi1[lev][nodesy];
Regional_sphere_related.c:169:                E->SX[lev][3][node] = E->sphere.R[lev][i];
Regional_sphere_related.c:172:                E->X[lev][1][node] =
Regional_sphere_related.c:173:                            E->sphere.R[lev][i]*sin(theta1[lev][nodesx])*cos(fi1[lev][nodesy]);
Regional_sphere_related.c:174:                E->X[lev][2][node] =
Regional_sphere_related.c:175:                            E->sphere.R[lev][i]*sin(theta1[lev][nodesx])*sin(fi1[lev][nodesy]);
Regional_sphere_related.c:176:                E->X[lev][3][node] =
Regional_sphere_related.c:177:                            E->sphere.R[lev][i]*cos(theta1[lev][nodesx]);
Regional_sphere_related.c:185:  for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c:192: else if((E->control.coor==0) || (E->control.coor==2)|| (E->control.coor==3))   {
Regional_sphere_related.c:196:  x[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:197:  y[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:198:  z[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:204:  temp = E->lmesh.NOY[E->mesh.levmax]*E->lmesh.NOX[E->mesh.levmax];
Regional_sphere_related.c:210:     tt[1] = E->sphere.cap.theta[1]+(E->sphere.cap.theta[2] -E->sphere.cap.theta[1])/nprocxl*(E->parallel.me_loc[1]);
Regional_sphere_related.c:211:     tt[2] = E->sphere.cap.theta[1]+(E->sphere.cap.theta[2] -E->sphere.cap.theta[1])/nprocxl*(E->parallel.me_loc[1]+1);
Regional_sphere_related.c:214:     ff[1] = E->sphere.cap.fi[1]+(E->sphere.cap.fi[4] -E->sphere.cap.fi[1])/nprocyl*(E->parallel.me_loc[2]);
Regional_sphere_related.c:216:     ff[3] = E->sphere.cap.fi[1]+(E->sphere.cap.fi[4] -E->sphere.cap.fi[1])/nprocyl*(E->parallel.me_loc[2]+1);
Regional_sphere_related.c:220:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Regional_sphere_related.c:222:     elx = E->lmesh.ELX[lev];
Regional_sphere_related.c:223:     ely = E->lmesh.ELY[lev];
Regional_sphere_related.c:224:     nox = E->lmesh.NOX[lev];
Regional_sphere_related.c:225:     noy = E->lmesh.NOY[lev];
Regional_sphere_related.c:226:     noz = E->lmesh.NOZ[lev];
Regional_sphere_related.c:250:                E->SX[lev][1][node] = SX[0][nodes];
Regional_sphere_related.c:251:                E->SX[lev][2][node] = SX[1][nodes];
Regional_sphere_related.c:252:                E->SX[lev][3][node] = E->sphere.R[lev][i];
Regional_sphere_related.c:255:                E->X[lev][1][node] =
Regional_sphere_related.c:256:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*cos(SX[1][nodes]);
Regional_sphere_related.c:257:                E->X[lev][2][node] =
Regional_sphere_related.c:258:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*sin(SX[1][nodes]);
Regional_sphere_related.c:259:                E->X[lev][3][node] =
Regional_sphere_related.c:260:                            E->sphere.R[lev][i]*cos(SX[0][nodes]);
Regional_tracer_advection.c:71:    sprintf(output_file,"%s.tracer_log.%d",E->control.data_file,E->parallel.me);
Regional_tracer_advection.c:72:    E->trace.fpt=fopen(output_file,"w");
Regional_tracer_advection.c:77:    E->trace.istat_isend=0;
Regional_tracer_advection.c:78:    E->trace.istat_iempty=0;
Regional_tracer_advection.c:79:    E->trace.istat_elements_checked=0;
Regional_tracer_advection.c:80:    E->trace.istat1=0;
Regional_tracer_advection.c:85:    E->trace.box_cushion=0.00001;
Regional_tracer_advection.c:90:    E->trace.number_of_basic_quantities=12;
Regional_tracer_advection.c:95:    E->trace.number_of_extra_quantities = 0;
Regional_tracer_advection.c:96:    if (E->trace.nflavors > 0)
Regional_tracer_advection.c:97:        E->trace.number_of_extra_quantities += 1;
Regional_tracer_advection.c:100:    E->trace.number_of_tracer_quantities =
Regional_tracer_advection.c:101:        E->trace.number_of_basic_quantities +
Regional_tracer_advection.c:102:        E->trace.number_of_extra_quantities;
Regional_tracer_advection.c:113:    if (E->trace.number_of_basic_quantities>99) {
Regional_tracer_advection.c:114:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of basic in tracer_defs.h\n");
Regional_tracer_advection.c:115:        fflush(E->trace.fpt);
Regional_tracer_advection.c:118:    if (E->trace.number_of_extra_quantities>99) {
Regional_tracer_advection.c:119:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of extraq in tracer_defs.h\n");
Regional_tracer_advection.c:120:        fflush(E->trace.fpt);
Regional_tracer_advection.c:123:    if (E->trace.number_of_tracer_quantities>99) {
Regional_tracer_advection.c:124:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of rlater in tracer_defs.h\n");
Regional_tracer_advection.c:125:        fflush(E->trace.fpt);
Regional_tracer_advection.c:136:    if (E->composition.on)
Regional_tracer_advection.c:139:    fprintf(E->trace.fpt, "Tracer intiailization takes %f seconds.\n",
Regional_tracer_advection.c:149:    fprintf(E->trace.fpt,"\nTracing Activated! (proc: %d)\n",E->parallel.me);
Regional_tracer_advection.c:150:    fprintf(E->trace.fpt,"   Allen K. McNamara 12-2003\n\n");
Regional_tracer_advection.c:152:    if (E->trace.ic_method==0) {
Regional_tracer_advection.c:153:        fprintf(E->trace.fpt,"Generating New Tracer Array\n");
Regional_tracer_advection.c:154:        fprintf(E->trace.fpt,"Tracers per element: %d\n",E->trace.itperel);
Regional_tracer_advection.c:156:    if (E->trace.ic_method==1) {
Regional_tracer_advection.c:157:        fprintf(E->trace.fpt,"Reading tracer file %s\n",E->trace.tracer_file);
Regional_tracer_advection.c:159:    if (E->trace.ic_method==2) {
Regional_tracer_advection.c:160:        fprintf(E->trace.fpt,"Read individual tracer files\n");
Regional_tracer_advection.c:163:    fprintf(E->trace.fpt,"Number of tracer flavors: %d\n", E->trace.nflavors);
Regional_tracer_advection.c:165:    if (E->trace.nflavors && E->trace.ic_method==0) {
Regional_tracer_advection.c:166:        fprintf(E->trace.fpt,"Initialized tracer flavors by: %d\n", E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:167:        if (E->trace.ic_method_for_flavors == 0) {
Regional_tracer_advection.c:168:            fprintf(E->trace.fpt,"Layered tracer flavors\n");
Regional_tracer_advection.c:169:            for (i=0; i<E->trace.nflavors-1; i++)
Regional_tracer_advection.c:170:                fprintf(E->trace.fpt,"Interface Height: %d %f\n",i,E->trace.z_interface[i]);
Regional_tracer_advection.c:173:	else if((E->trace.ic_method_for_flavors == 1)||(E->trace.ic_method_for_flavors == 99)) {
Regional_tracer_advection.c:176:          fprintf(E->trace.fpt,"ggrd not implemented et for regional, flavor method= %d\n",
Regional_tracer_advection.c:177:		  E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:178:	  fflush(E->trace.fpt);
Regional_tracer_advection.c:183:            fprintf(E->trace.fpt,"Sorry-This IC methods for Flavors are Unavailable %d\n",E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:184:            fflush(E->trace.fpt);
Regional_tracer_advection.c:189:    for (i=0; i<E->trace.nflavors-2; i++) {
Regional_tracer_advection.c:190:        if (E->trace.z_interface[i] < E->trace.z_interface[i+1]) {
Regional_tracer_advection.c:191:            fprintf(E->trace.fpt,"Sorry - The %d-th z_interface is smaller than the next one.\n", i);
Regional_tracer_advection.c:192:            fflush(E->trace.fpt);
Regional_tracer_advection.c:201:    fprintf(E->trace.fpt,"Box Cushion: %f\n",E->trace.box_cushion);
Regional_tracer_advection.c:202:    fprintf(E->trace.fpt,"Number of Basic Quantities: %d\n",
Regional_tracer_advection.c:203:            E->trace.number_of_basic_quantities);
Regional_tracer_advection.c:204:    fprintf(E->trace.fpt,"Number of Extra Quantities: %d\n",
Regional_tracer_advection.c:205:            E->trace.number_of_extra_quantities);
Regional_tracer_advection.c:206:    fprintf(E->trace.fpt,"Total Number of Tracer Quantities: %d\n",
Regional_tracer_advection.c:207:            E->trace.number_of_tracer_quantities);
Regional_tracer_advection.c:211:    if (E->trace.itracer_warnings==0) {
Regional_tracer_advection.c:212:        fprintf(E->trace.fpt,"\n WARNING EXITS ARE TURNED OFF! TURN THEM ON!\n");
Regional_tracer_advection.c:214:        fflush(E->trace.fpt);
Regional_tracer_advection.c:226:    nox=E->lmesh.nox;
Regional_tracer_advection.c:227:    noy=E->lmesh.noy;
Regional_tracer_advection.c:228:    noz=E->lmesh.noz;
Regional_tracer_advection.c:230:    E->trace.x_space=(double*) malloc(nox*sizeof(double));
Regional_tracer_advection.c:231:    E->trace.y_space=(double*) malloc(noy*sizeof(double));
Regional_tracer_advection.c:232:    E->trace.z_space=(double*) malloc(noz*sizeof(double));
Regional_tracer_advection.c:239:	    E->trace.x_space[i]=E->sx[1][i*noz+1];
Regional_tracer_advection.c:242:	    E->trace.y_space[j]=E->sx[2][j*nox*noz+1];
Regional_tracer_advection.c:245:	    E->trace.z_space[k]=E->sx[3][k+1];
Regional_tracer_advection.c:265:    elx = E->lmesh.elx;
Regional_tracer_advection.c:266:    ely = E->lmesh.ely;
Regional_tracer_advection.c:267:    elz = E->lmesh.elz;
Regional_tracer_advection.c:279:	ii = isearch_neighbors(E->trace.x_space, elx+1, theta, i);
Regional_tracer_advection.c:280:	jj = isearch_neighbors(E->trace.y_space, ely+1, phi, j);
Regional_tracer_advection.c:281:	kk = isearch_neighbors(E->trace.z_space, elz+1, rad, k);
Regional_tracer_advection.c:289:    ii = isearch_all(E->trace.x_space, elx+1, theta);
Regional_tracer_advection.c:290:    jj = isearch_all(E->trace.y_space, ely+1, phi);
Regional_tracer_advection.c:291:    kk = isearch_all(E->trace.z_space, elz+1, rad);
Regional_tracer_advection.c:364:    theta_min = E->trace.theta_cap[icap][2];
Regional_tracer_advection.c:365:    theta_max = E->trace.theta_cap[icap][4];
Regional_tracer_advection.c:367:    phi_min = E->trace.phi_cap[icap][2];
Regional_tracer_advection.c:368:    phi_max = E->trace.phi_cap[icap][4];
Regional_tracer_advection.c:389:    elx = E->lmesh.elx;
Regional_tracer_advection.c:390:    ely = E->lmesh.ely;
Regional_tracer_advection.c:391:    elz = E->lmesh.elz;
Regional_tracer_advection.c:411:    tr_dx = theta - E->trace.x_space[i];
Regional_tracer_advection.c:412:    dx = E->trace.x_space[i+1] - E->trace.x_space[i];
Regional_tracer_advection.c:414:    tr_dy = phi - E->trace.y_space[j];
Regional_tracer_advection.c:415:    dy = E->trace.y_space[j+1] - E->trace.y_space[j];
Regional_tracer_advection.c:417:    tr_dz = rad - E->trace.z_space[k];
Regional_tracer_advection.c:418:    dz = E->trace.z_space[k+1] - E->trace.z_space[k];
Regional_tracer_advection.c:441:    fprintf(E->trace.fpt, "dr=(%e,%e,%e)  tr_dr=(%e,%e,%e)\n",
Regional_tracer_advection.c:443:    fprintf(E->trace.fpt, "shp: %e %e %e %e %e %e %e %e\n",
Regional_tracer_advection.c:445:    fprintf(E->trace.fpt, "sum(shp): %e\n",
Regional_tracer_advection.c:447:    fflush(E->trace.fpt);
Regional_tracer_advection.c:503:        fprintf(E->trace.fpt, "VV: %e %e %e %e %e %e %e %e: %e\n",
Regional_tracer_advection.c:511:        tmp += E->sx[m][1][E->ien[m][nelem].node[n]] * shp[n];
Regional_tracer_advection.c:513:    fprintf(E->trace.fpt, "THETA: %e -> %e\n", theta, tmp);
Regional_tracer_advection.c:515:    fflush(E->trace.fpt);
Regional_tracer_advection.c:526:    if (*theta > E->control.theta_max - E->trace.box_cushion) {
Regional_tracer_advection.c:527:        *theta = E->control.theta_max - E->trace.box_cushion;
Regional_tracer_advection.c:531:    if (*theta < E->control.theta_min + E->trace.box_cushion) {
Regional_tracer_advection.c:532:        *theta = E->control.theta_min + E->trace.box_cushion;
Regional_tracer_advection.c:536:    if (*phi > E->control.fi_max - E->trace.box_cushion) {
Regional_tracer_advection.c:537:        *phi = E->control.fi_max - E->trace.box_cushion;
Regional_tracer_advection.c:541:    if (*phi < E->control.fi_min + E->trace.box_cushion) {
Regional_tracer_advection.c:542:        *phi = E->control.fi_min + E->trace.box_cushion;
Regional_tracer_advection.c:546:    if (*rad > E->sphere.ro - E->trace.box_cushion) {
Regional_tracer_advection.c:547:        *rad = E->sphere.ro - E->trace.box_cushion;
Regional_tracer_advection.c:551:    if (*rad < E->sphere.ri + E->trace.box_cushion) {
Regional_tracer_advection.c:552:        *rad = E->sphere.ri + E->trace.box_cushion;
Regional_tracer_advection.c:562:    int lev = E->mesh.levmax;
Regional_tracer_advection.c:584:    E->trace.istat_isend = E->trace.ilater;
Regional_tracer_advection.c:587:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:588:        bounds[d][0] = E->sx[d+1][1];
Regional_tracer_advection.c:589:        bounds[d][1] = E->sx[d+1][E->lmesh.nno];
Regional_tracer_advection.c:596:        if (E->parallel.NUM_PASS[lev].bound[kk] == 1) {
Regional_tracer_advection.c:597:            ngbr_rank[kk] = E->parallel.PROCESSOR[lev].pass[ipass];
Regional_tracer_advection.c:606:    for (kk=1; kk<=E->trace.istat_isend; kk++) {
Regional_tracer_advection.c:607:        fprintf(E->trace.fpt, "tracer#=%d xx=(%g,%g,%g)\n", kk,
Regional_tracer_advection.c:608:                E->trace.rlater[j][0][kk],
Regional_tracer_advection.c:609:                E->trace.rlater[j][1][kk],
Regional_tracer_advection.c:610:                E->trace.rlater[j][2][kk]);
Regional_tracer_advection.c:613:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:614:        fprintf(E->trace.fpt, "bounds(dim=%d) = (%e, %e)\n",
Regional_tracer_advection.c:619:        fprintf(E->trace.fpt, "pass=%d  neighbor_rank=%d\n",
Regional_tracer_advection.c:622:    fflush(E->trace.fpt);
Regional_tracer_advection.c:628:    max_send_size = max(2*E->trace.ilater, E->trace.ntracers/100);
Regional_tracer_advection.c:629:    itemp_size = max_send_size * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:633:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (u388)\n");
Regional_tracer_advection.c:634:        fflush(E->trace.fpt);
Regional_tracer_advection.c:639:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (u389)\n");
Regional_tracer_advection.c:640:        fflush(E->trace.fpt);
Regional_tracer_advection.c:645:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:646:        int original_size = E->trace.ilater;
Regional_tracer_advection.c:654:        while (kk<=E->trace.ilater) {
Regional_tracer_advection.c:658:            coord = E->trace.rlater[d][kk];
Regional_tracer_advection.c:676:                itemp_size = isize * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:681:                    fprintf(E->trace.fpt,"Error(lost souls)-no memory (s4)\n");
Regional_tracer_advection.c:682:                    fflush(E->trace.fpt);
Regional_tracer_advection.c:688:                    fprintf(E->trace.fpt,"Error(lost souls)-no memory (s5)\n");
Regional_tracer_advection.c:689:                    fflush(E->trace.fpt);
Regional_tracer_advection.c:693:                fprintf(E->trace.fpt,"Expanding physical memory of send to "
Regional_tracer_advection.c:705:        if ((isend[0] + isend[1] + E->trace.ilater) != original_size) {
Regional_tracer_advection.c:706:            fprintf(E->trace.fpt, "original_size: %d, rlater_size: %d, "
Regional_tracer_advection.c:708:                    original_size, E->trace.ilater, kk);
Regional_tracer_advection.c:715:                fprintf(E->trace.fpt, "dim:%d side:%d kk=%d coord[kk]=%e\n",
Regional_tracer_advection.c:717:                        send[i][kk*E->trace.number_of_tracer_quantities+d]);
Regional_tracer_advection.c:720:        fflush(E->trace.fpt);
Regional_tracer_advection.c:734:                          11, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:737:                          11, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:755:                fprintf(E->trace.fpt, "%d: %d send %d to proc %d\n",
Regional_tracer_advection.c:757:                fprintf(E->trace.fpt, "%d: %d recv %d from proc %d\n",
Regional_tracer_advection.c:766:            isize = irecv[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:771:                fprintf(E->trace.fpt, "Error(lost souls)-no memory (c721)\n");
Regional_tracer_advection.c:772:                fflush(E->trace.fpt);
Regional_tracer_advection.c:785:                isize = isend[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:787:                          12, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:789:                isize = irecv[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:791:                          12, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:804:                fprintf(E->trace.fpt, "recv: %d %e %e %e\n",
Regional_tracer_advection.c:806:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities],
Regional_tracer_advection.c:807:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities+1],
Regional_tracer_advection.c:808:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities+2]);
Regional_tracer_advection.c:811:        fflush(E->trace.fpt);
Regional_tracer_advection.c:828:    if (E->trace.ilater > 0) {
Regional_tracer_advection.c:829:        fprintf(E->trace.fpt, "Error(regional_lost_souls) lost tracers\n");
Regional_tracer_advection.c:830:        for (kk=1; kk<=E->trace.ilater; kk++) {
Regional_tracer_advection.c:831:            fprintf(E->trace.fpt, "lost #%d xx=(%e, %e, %e)\n", kk,
Regional_tracer_advection.c:832:                    E->trace.rlater[0][kk],
Regional_tracer_advection.c:833:                    E->trace.rlater[1][kk],
Regional_tracer_advection.c:834:                    E->trace.rlater[2][kk]);
Regional_tracer_advection.c:836:        fflush(E->trace.fpt);
Regional_tracer_advection.c:846:    E->trace.lost_souls_time += CPU_time0() - begin_time;
Regional_tracer_advection.c:858:    isend_position = (*send_size) * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:860:    for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++) {
Regional_tracer_advection.c:862:        send[ipos] = E->trace.rlater[pp][kk];
Regional_tracer_advection.c:867:    ilast_tracer = E->trace.ilater;
Regional_tracer_advection.c:868:    for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++) {
Regional_tracer_advection.c:869:        E->trace.rlater[pp][kk] = E->trace.rlater[pp][ilast_tracer];
Regional_tracer_advection.c:871:    E->trace.ilater--;
Regional_tracer_advection.c:891:        ipos = kk * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:905:        fprintf(E->trace.fpt, "kk=%d, inside=%d, xx=(%e, %e, %e)\n",
Regional_tracer_advection.c:907:        fprintf(E->trace.fpt, "before: %d %d\n",
Regional_tracer_advection.c:908:                E->trace.ilater[j], E->trace.ntracers[j]);
Regional_tracer_advection.c:913:            E->trace.ntracers++;
Regional_tracer_advection.c:914:            ilast = E->trace.ntracers;
Regional_tracer_advection.c:916:            if (E->trace.ntracers > (E->trace.max_ntracers-5))
Regional_tracer_advection.c:919:            for (pp=0; pp<E->trace.number_of_basic_quantities; pp++)
Regional_tracer_advection.c:920:                E->trace.basicq[pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:922:            ipos += E->trace.number_of_basic_quantities;
Regional_tracer_advection.c:923:            for (pp=0; pp<E->trace.number_of_extra_quantities; pp++)
Regional_tracer_advection.c:924:                E->trace.extraq[pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:931:                fprintf(E->trace.fpt, "Error(regional lost souls) - "
Regional_tracer_advection.c:933:                fprintf(E->trace.fpt, "theta, phi, rad: %f %f %f\n",
Regional_tracer_advection.c:935:                fflush(E->trace.fpt);
Regional_tracer_advection.c:939:            E->trace.ielement[ilast] = iel;
Regional_tracer_advection.c:943:            if (E->trace.ilatersize==0) {
Regional_tracer_advection.c:945:                E->trace.ilatersize=E->trace.max_ntracers/5;
Regional_tracer_advection.c:947:                for (kk=0;kk<E->trace.number_of_tracer_quantities;kk++) {
Regional_tracer_advection.c:948:                    if ((E->trace.rlater[kk]=(double *)malloc(E->trace.ilatersize*sizeof(double)))==NULL) {
Regional_tracer_advection.c:949:                        fprintf(E->trace.fpt,"AKM(put_found_tracers)-no memory (%d)\n",kk);
Regional_tracer_advection.c:950:                        fflush(E->trace.fpt);
Regional_tracer_advection.c:956:            E->trace.ilater++;
Regional_tracer_advection.c:957:            ilast = E->trace.ilater;
Regional_tracer_advection.c:959:            if (E->trace.ilater > (E->trace.ilatersize-5))
Regional_tracer_advection.c:962:            for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++)
Regional_tracer_advection.c:963:                E->trace.rlater[pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:967:        fprintf(E->trace.fpt, "after: %d %d\n",
Regional_tracer_advection.c:968:                E->trace.ilater[j], E->trace.ntracers[j]);
Regional_tracer_advection.c:969:        fflush(E->trace.fpt);
Regional_version_dependent.c:63:  rr = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Regional_version_dependent.c:64:  RR = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Regional_version_dependent.c:65:  nox=E->mesh.nox;
Regional_version_dependent.c:66:  noy=E->mesh.noy;
Regional_version_dependent.c:67:  noz=E->mesh.noz;
Regional_version_dependent.c:70:  switch(E->control.coor)    {	
Regional_version_dependent.c:73:    dr = (E->sphere.ro-E->sphere.ri)/(E->mesh.noz-1);
Regional_version_dependent.c:74:    for (k=1;k<=E->mesh.noz;k++)  {
Regional_version_dependent.c:75:      rr[k] = E->sphere.ri + (k-1)*dr;
Regional_version_dependent.c:80:    sprintf(output_file,"%s",E->control.coor_file);
Regional_version_dependent.c:83:      fprintf(E->fp,"(Nodal_mesh.c #1) Cannot open %s\n",output_file);
Regional_version_dependent.c:96:    for (k=1;k<=E->mesh.noz;k++)  {
Regional_version_dependent.c:103:    E->sphere.ri = rr[1];
Regional_version_dependent.c:104:    E->sphere.ro = rr[E->mesh.noz];
Regional_version_dependent.c:122:  for (i=1;i<=E->mesh.noz;i++)  {
Regional_version_dependent.c:123:      E->sphere.gr[i] = rr[i];
Regional_version_dependent.c:124:      /* if(E->parallel.me==0) fprintf(stderr, "%d %f\n", i, E->sphere.gr[i]); */
Regional_version_dependent.c:127:  for (i=1;i<=E->lmesh.noz;i++)  {
Regional_version_dependent.c:128:      k = E->lmesh.nzs+i-1;
Regional_version_dependent.c:132:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Regional_version_dependent.c:134:    if (E->control.NMULTIGRID)
Regional_version_dependent.c:135:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Regional_version_dependent.c:139:      for (i=1;i<=E->lmesh.NOZ[lev];i++)
Regional_version_dependent.c:140:         E->sphere.R[lev][i] = RR[(i-1)*step+1];
Regional_version_dependent.c:148:  if (E->control.verbose) {
Regional_version_dependent.c:149:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Regional_version_dependent.c:150:    fprintf(E->fp_out,"output_coordinates before rotation %d \n",lev);
Regional_version_dependent.c:151:      fprintf(E->fp_out,"output_coordinates for cap %d %d\n",j,E->lmesh.NNO[lev]);
Regional_version_dependent.c:152:      for (i=1;i<=E->lmesh.NNO[lev];i++)
Regional_version_dependent.c:153:        if(i%E->lmesh.NOZ[lev]==1)
Regional_version_dependent.c:154:             fprintf(E->fp_out,"%d %g %g %g\n",i,
Regional_version_dependent.c:155:                 E->SX[lev][1][i],E->SX[lev][2][i],E->SX[lev][3][i]);
Regional_version_dependent.c:157:    fflush(E->fp_out);
Regional_version_dependent.c:162:  if(E->data.use_ellipse)
Regional_version_dependent.c:165:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Regional_version_dependent.c:166:    for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Regional_version_dependent.c:167:        E->SinCos[lev][0][i] = sin(E->SX[lev][1][i]);
Regional_version_dependent.c:168:        E->SinCos[lev][1][i] = sin(E->SX[lev][2][i]);
Regional_version_dependent.c:169:        E->SinCos[lev][2][i] = cos(E->SX[lev][1][i]);
Regional_version_dependent.c:170:        E->SinCos[lev][3][i] = cos(E->SX[lev][2][i]);
Regional_version_dependent.c:173:  if (E->control.verbose) {
Regional_version_dependent.c:174:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Regional_version_dependent.c:175:    fprintf(E->fp_out,"output_coordinates after rotation %d \n",lev);
Regional_version_dependent.c:176:    for (i=1;i<=E->lmesh.NNO[lev];i++)
Regional_version_dependent.c:177:      if(i%E->lmesh.NOZ[lev]==1)
Regional_version_dependent.c:178:           fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,
Regional_version_dependent.c:179:               E->SX[lev][1][i],
Regional_version_dependent.c:180:               E->SX[lev][2][i],
Regional_version_dependent.c:181:               E->SX[lev][3][i]);
Regional_version_dependent.c:183:    fflush(E->fp_out);
Regional_version_dependent.c:194:  const int dims=E->mesh.nsd;
Regional_version_dependent.c:201:  int max_size = E->lmesh.elx*E->lmesh.ely*E->lmesh.elz
Regional_version_dependent.c:202:    - (E->lmesh.elx-2)*(E->lmesh.ely-2)*(E->lmesh.elz-2) + 1;
Regional_version_dependent.c:204:  E->boundary.element = (int *)malloc(max_size*sizeof(int));
Regional_version_dependent.c:207:    E->boundary.normal[d] = (int *)malloc(max_size*sizeof(int));
Regional_version_dependent.c:211:    for(k=1; k<=E->lmesh.ely; k++)
Regional_version_dependent.c:212:      for(j=1; j<=E->lmesh.elx; j++)
Regional_version_dependent.c:213:        for(i=1; i<=E->lmesh.elz; i++) {
Regional_version_dependent.c:219:          if((E->parallel.me_loc[1] == 0) && (j == 1)) {
Regional_version_dependent.c:224:          if((E->parallel.me_loc[1] == E->parallel.nprocx - 1)
Regional_version_dependent.c:225:             && (j == E->lmesh.elx)) {
Regional_version_dependent.c:230:          if((E->parallel.me_loc[2] == 0) && (k == 1)) {
Regional_version_dependent.c:235:          if((E->parallel.me_loc[2] == E->parallel.nprocy - 1)
Regional_version_dependent.c:236:             && (k == E->lmesh.ely)) {
Regional_version_dependent.c:241:          if((E->parallel.me_loc[3] == 0) && (i == 1)) {
Regional_version_dependent.c:246:          if((E->parallel.me_loc[3] == E->parallel.nprocz - 1)
Regional_version_dependent.c:247:             && (i == E->lmesh.elz)) {
Regional_version_dependent.c:253:            el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Regional_version_dependent.c:254:            E->boundary.element[count] = el;
Regional_version_dependent.c:256:              E->boundary.normal[d][count] = normalFlag[d];
Regional_version_dependent.c:263:    E->boundary.nel = count - 1;
Shape_functions.c:54:    { E->N.vpt[i] = 0.0; 
Shape_functions.c:55:      E->Nx.vpt[i] = 0.0;
Shape_functions.c:56:      E->Nx.vpt[GNVI+i] = 0.0;
Shape_functions.c:57:      E->Nx.vpt[2*GNVI+i] = 0.0; 
Shape_functions.c:61:    { E->N.ppt[i] = 0.0; 
Shape_functions.c:62:      E->Nx.ppt[i] = 0.0;
Shape_functions.c:63:      E->Nx.ppt[GNPI+i] = 0.0;
Shape_functions.c:64:      E->Nx.ppt[2*GNPI+i] = 0.0; 
Shape_functions.c:68:    { E->M.vpt[i] = 0.0; 
Shape_functions.c:69:      E->Mx.vpt[i] = 0.0;
Shape_functions.c:70:      E->Mx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:74:    { E->M.ppt[i] = 0.0; 
Shape_functions.c:75:      E->Mx.ppt[i] = 0.0;
Shape_functions.c:76:      E->Mx.ppt[GN1PI+i] = 0.0;
Shape_functions.c:80:    { E->L.vpt[i] = 0.0; 
Shape_functions.c:81:      E->Lx.vpt[i] = 0.0;
Shape_functions.c:82:      E->Lx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:86:    { E->NM.vpt[i] = 0.0; 
Shape_functions.c:87:      E->NMx.vpt[i] = 0.0;
Shape_functions.c:88:      E->NMx.vpt[GNVI+i] = 0.0;
Shape_functions.c:89:      E->NMx.vpt[2*GNVI+i] = 0.0; 
Shape_functions.c:92:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Shape_functions.c:95:      for(j=1;j<=vpoints[E->mesh.nsd];j++)  { 
Shape_functions.c:98:         E->N.vpt[GNVINDEX(i,j)] = 1.0;
Shape_functions.c:99:         for(d=1;d<=E->mesh.nsd;d++)   
Shape_functions.c:100:             E->N.vpt[GNVINDEX(i,j)] *=  
Shape_functions.c:103:         for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:104:             E->Nx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],g_point[j].x[dd-1]);
Shape_functions.c:105:             for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:107:                   E->Nx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],g_point[j].x[d-1]);
Shape_functions.c:112:      for(j=1;j<=ppoints[E->mesh.nsd];j++)  {
Shape_functions.c:114:         E->N.ppt[GNPINDEX(i,j)] = 1.0;
Shape_functions.c:115:         for(d=1;d<=E->mesh.nsd;d++) 
Shape_functions.c:116:            E->N.ppt[GNPINDEX(i,j)] *=  
Shape_functions.c:119:         for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:120:            E->Nx.ppt[GNPXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],p_point[j].x[dd-1]);
Shape_functions.c:121:            for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:123:                  E->Nx.ppt[GNPXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],p_point[j].x[d-1]); 
Shape_functions.c:129:  for(j=1;j<=onedvpoints[E->mesh.nsd];j++)
Shape_functions.c:130:    for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Shape_functions.c:131:       E->M.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:132:       E->L.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:133:       for(d=1;d<=E->mesh.nsd-1;d++) {
Shape_functions.c:134:          E->M.vpt[GMVINDEX(j,k)] *= lpoly(bb[d-1][j],s_point[k].x[d-1]);
Shape_functions.c:135:          E->L.vpt[GMVINDEX(j,k)] *= lpoly(bb[d-1][j],l_1d[k].x[d-1]);
Shape_functions.c:137:       for(dd=1;dd<=E->mesh.nsd-1;dd++) {
Shape_functions.c:138:          E->Mx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(bb[dd-1][j],s_point[k].x[d-1]);
Shape_functions.c:139:          E->Lx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(bb[dd-1][j],l_1d[k].x[d-1]);
Shape_functions.c:140:          for(d=1;d<=E->mesh.nsd-1;d++)
Shape_functions.c:142:                E->Mx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(bb[d-1][j],s_point[k].x[d-1]);
Shape_functions.c:143:                E->Lx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(bb[d-1][j],l_1d[k].x[d-1]);
Shape_functions.c:152:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Shape_functions.c:153:      for(j=1;j<=vpoints[E->mesh.nsd];j++)   {
Shape_functions.c:155:         E->NM.vpt[GNVINDEX(i,j)] = 1.0;
Shape_functions.c:156:         for(d=1;d<=E->mesh.nsd;d++)   
Shape_functions.c:157:             E->NM.vpt[GNVINDEX(i,j)] *=  
Shape_functions.c:160:         for(dd=1;dd<=E->mesh.nsd;dd++)                 {
Shape_functions.c:161:            E->NMx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],s_point[j].x[dd-1]);
Shape_functions.c:162:            for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:164:                  E->NMx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],s_point[j].x[d-1]); 
Size_does_matter.c:77:    const int dims = E->mesh.nsd;
Size_does_matter.c:92:                x[d] += E->X[lev][d][E->IEN[lev][el].node[i]]
Size_does_matter.c:93:                    * E->N.vpt[GNVINDEX(i,k)];
Size_does_matter.c:98:                    dxda[d][e] += E->X[lev][e][E->IEN[lev][el].node[i]]
Size_does_matter.c:99:                        * E->Nx.vpt[GNVXINDEX(d-1,i,k)];
Size_does_matter.c:101:        jacobian = determinant(dxda, E->mesh.nsd);
Size_does_matter.c:102:        E->GDA[lev][el].vpt[k] = jacobian;
Size_does_matter.c:114:                        E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Size_does_matter.c:121:                E->GNX[lev][el].vpt[GNVXINDEX(d-1,j,k)]
Size_does_matter.c:137:                x[d] += E->X[lev][d][E->IEN[lev][el].node[i]]
Size_does_matter.c:138:                    * E->N.ppt[GNPINDEX(i,k)];
Size_does_matter.c:143:                    dxda[d][e] += E->X[lev][e][E->IEN[lev][el].node[i]]
Size_does_matter.c:144:                        * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Size_does_matter.c:146:        jacobian = determinant(dxda,E->mesh.nsd);
Size_does_matter.c:147:        E->GDA[lev][el].ppt[k] = jacobian;
Size_does_matter.c:151:                cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd);
Size_does_matter.c:159:                        E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Size_does_matter.c:164:                E->GNX[lev][el].ppt[GNPXINDEX(d-1,j,k)]
Size_does_matter.c:178:    for(lev=E->mesh.levmax; lev>=E->mesh.levmin; lev--)
Size_does_matter.c:179:      for(el=1; el<=E->lmesh.NEL[lev]; el++)
Size_does_matter.c:197:    const int dims = E->mesh.nsd;
Size_does_matter.c:207:                x[d] += E->X[lev][d][E->IEN[lev][el].node[i]] * 
Size_does_matter.c:208:                        E->N.vpt[GNVINDEX(i,k)];
Size_does_matter.c:224:    const int dims = E->mesh.nsd;
Size_does_matter.c:234:                x[d] += E->X[lev][d][E->IEN[lev][el].node[i]] * 
Size_does_matter.c:235:                        E->N.ppt[GNPINDEX(i,k)];
Size_does_matter.c:248:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:251:  to = theta_g(E->eco[el].centre[1],E);
Size_does_matter.c:253:  to = E->eco[el].centre[1];	
Size_does_matter.c:256:  fo = E->eco[el].centre[2];
Size_does_matter.c:270:    node = E->ien[el].node[s];
Size_does_matter.c:271:    xx[1][i] = E->x[1][node]*dxdy[1][1]
Size_does_matter.c:272:             + E->x[2][node]*dxdy[1][2]
Size_does_matter.c:273:             + E->x[3][node]*dxdy[1][3];
Size_does_matter.c:274:    xx[2][i] = E->x[1][node]*dxdy[2][1]
Size_does_matter.c:275:             + E->x[2][node]*dxdy[2][2]
Size_does_matter.c:276:             + E->x[3][node]*dxdy[2][3];
Size_does_matter.c:277:    xx[3][i] = E->x[1][node]*dxdy[3][1]
Size_does_matter.c:278:             + E->x[2][node]*dxdy[3][2]
Size_does_matter.c:279:             + E->x[3][node]*dxdy[3][3];
Size_does_matter.c:295:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:300:    E->surf_det[k] = (double *)malloc((1+E->lmesh.snel)*sizeof(double));
Size_does_matter.c:302:  r2 = 1.0 / (E->sx[3][E->lmesh.elz+1] * E->sx[3][E->lmesh.elz+1]);
Size_does_matter.c:304:  for (es=1;es<=E->lmesh.snel;es++)   {
Size_does_matter.c:305:    el = es * E->lmesh.elz;
Size_does_matter.c:309:      for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:310:        for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:314:        for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:315:          for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:316:             dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:318:      jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:321:      E->surf_det[k][es] = jacobian * r2;
Size_does_matter.c:340:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:346:      E->boundary.det[side][d] = 
Size_does_matter.c:347:        (double *)malloc((1+E->boundary.nel)*sizeof(double));
Size_does_matter.c:349:    for (es=1;es<=E->boundary.nel;es++) {
Size_does_matter.c:350:      el = E->boundary.element[es];
Size_does_matter.c:357:          for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:358:            for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:362:            for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:363:              for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:365:                  E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:367:          jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:368:          E->boundary.det[side][k][es] = jacobian;
Size_does_matter.c:387:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:396:      for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:397:        for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:401:        for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:402:          for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:403:            dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:405:      jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:424:    const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:429:    to = theta_g(E->eco[el].centre[1],E);
Size_does_matter.c:431:    to = E->eco[el].centre[1]; 
Size_does_matter.c:433:    fo = E->eco[el].centre[2];
Size_does_matter.c:449:            node = E->ien[el].node[e];
Size_does_matter.c:450:            xx[1][i] = E->x[1][node]*dxdy[1][1]
Size_does_matter.c:451:                + E->x[2][node]*dxdy[1][2]
Size_does_matter.c:452:                + E->x[3][node]*dxdy[1][3];
Size_does_matter.c:453:            xx[2][i] = E->x[1][node]*dxdy[2][1]
Size_does_matter.c:454:                + E->x[2][node]*dxdy[2][2]
Size_does_matter.c:455:                + E->x[3][node]*dxdy[2][3];
Size_does_matter.c:456:            xx[3][i] = E->x[1][node]*dxdy[3][1]
Size_does_matter.c:457:                + E->x[2][node]*dxdy[3][2]
Size_does_matter.c:458:                + E->x[3][node]*dxdy[3][3];
Size_does_matter.c:463:            for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:464:                for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:468:                for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:469:                    for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:470:                        dxda[d][e] += xx[e][i]*E->Lx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:472:            jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:493:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:500:    for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:501:      for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:505:      for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:506:        for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:507:          dxda[d][e] += xx[sidedim[side][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:510:    jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:526:  const int dims=E->mesh.nsd;
Size_does_matter.c:538:            x[d] += E->X[lev][d][E->IEN[lev][el].node[a]]
Size_does_matter.c:539:                   *E->N.vpt[GNVINDEX(a,k)];
Size_does_matter.c:566:          tt = E->SX[lev][1][E->IEN[lev][el].node[a]];
Size_does_matter.c:567:          ff = E->SX[lev][2][E->IEN[lev][el].node[a]];
Size_does_matter.c:599:            x[d] += E->X[lev][d][E->IEN[lev][el].node[a]]
Size_does_matter.c:600:                   *E->N.ppt[GNPINDEX(a,k)];
Size_does_matter.c:628:	  lnode = E->IEN[lev][el].node[a];
Size_does_matter.c:629:	  sintt = E->SinCos[lev][0][lnode];
Size_does_matter.c:630:	  sinff = E->SinCos[lev][1][lnode];
Size_does_matter.c:631:	  costt = E->SinCos[lev][2][lnode];
Size_does_matter.c:632:	  cosff = E->SinCos[lev][3][lnode];
Size_does_matter.c:665:  const int dims=E->mesh.nsd;
Size_does_matter.c:677:	  x[d] += E->X[lev][d][E->IEN[lev][el].node[a]]
Size_does_matter.c:678:	    *E->M.vpt[GMVINDEX(aa,k)];
Size_does_matter.c:710:	lnode = E->IEN[lev][el].node[a];
Size_does_matter.c:711:	sintt = E->SinCos[lev][0][lnode];
Size_does_matter.c:712:	sinff = E->SinCos[lev][1][lnode];
Size_does_matter.c:713:	costt = E->SinCos[lev][2][lnode];
Size_does_matter.c:714:	cosff = E->SinCos[lev][3][lnode];
Size_does_matter.c:735:      for(d=1;d<=E->mesh.nsd;d++)
Size_does_matter.c:739:       	x[d] += E->X[lev][d][E->IEN[lev][el].node[aa]]
Size_does_matter.c:740:       	  *E->M.ppt[GMPINDEX(a,k)];
Size_does_matter.c:769:	lnode = E->IEN[lev][el].node[aa];
Size_does_matter.c:770:	sintt = E->SinCos[lev][0][lnode];
Size_does_matter.c:771:	sinff = E->SinCos[lev][1][lnode];
Size_does_matter.c:772:	costt = E->SinCos[lev][2][lnode];
Size_does_matter.c:773:	cosff = E->SinCos[lev][3][lnode];
Size_does_matter.c:779:	for (i=1;i<=E->mesh.nsd;i++) {
Size_does_matter.c:780:	  for (j=1;j<=E->mesh.nsd;j++) {
Size_does_matter.c:803:  const int dims=E->mesh.nsd;
Size_does_matter.c:808: for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Size_does_matter.c:809:    nel_surface = E->lmesh.NEL[lev]/E->lmesh.ELZ[lev];
Size_does_matter.c:812:      el = es*E->lmesh.ELZ[lev];
Size_does_matter.c:820:            x[d] += E->X[lev][d][E->IEN[lev][el].node[a]]
Size_does_matter.c:821:                   *E->N.vpt[GNVINDEX(a,k)];
Size_does_matter.c:849:          lnode = E->IEN[lev][el].node[a];
Size_does_matter.c:850:          sintt = E->SinCos[lev][0][lnode];
Size_does_matter.c:851:          sinff = E->SinCos[lev][1][lnode];
Size_does_matter.c:852:          costt = E->SinCos[lev][2][lnode];
Size_does_matter.c:853:          cosff = E->SinCos[lev][3][lnode];
Size_does_matter.c:861:              E->CC[lev][es].vpt[BVINDEX(i,j,a,k)] =
Size_does_matter.c:863:              E->CCX[lev][es].vpt[BVXINDEX(i,j,1,a,k)] =
Size_does_matter.c:865:              E->CCX[lev][es].vpt[BVXINDEX(i,j,2,a,k)] =
Size_does_matter.c:878:            x[d] += E->X[lev][d][E->IEN[lev][el].node[a]] *
Size_does_matter.c:879:                    E->N.ppt[GNPINDEX(a,k)];
Size_does_matter.c:907:          lnode = E->IEN[lev][el].node[a];
Size_does_matter.c:908:          sintt = E->SinCos[lev][0][lnode];
Size_does_matter.c:909:          sinff = E->SinCos[lev][1][lnode];
Size_does_matter.c:910:          costt = E->SinCos[lev][2][lnode];
Size_does_matter.c:911:          cosff = E->SinCos[lev][3][lnode];
Size_does_matter.c:920:              E->CC[lev][es].ppt[BPINDEX(i,j,a,k)] =
Size_does_matter.c:922:              E->CCX[lev][es].ppt[BPXINDEX(i,j,1,a,k)] =
Size_does_matter.c:924:              E->CCX[lev][es].ppt[BPXINDEX(i,j,2,a,k)] =
Size_does_matter.c:950:    const int vpts=vpoints[E->mesh.nsd];
Size_does_matter.c:954:    for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Size_does_matter.c:956:      for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:957:          E->MASS[lev][node] = 0.0;
Size_does_matter.c:959:      for(e=1;e<=E->lmesh.NEL[lev];e++)  {
Size_does_matter.c:963:          for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:964:              n[node] = E->IEN[lev][e].node[node];
Size_does_matter.c:966:          for(i=1;i<=E->mesh.nsd;i++)  {
Size_does_matter.c:967:              for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:968:                  centre[i] += E->X[lev][i][n[node]];
Size_does_matter.c:970:              centre[i] = centre[i]/enodes[E->mesh.nsd];
Size_does_matter.c:979:          E->ECO[lev][e].centre[1] = dx1;
Size_does_matter.c:980:          E->ECO[lev][e].centre[2] = dx2;
Size_does_matter.c:981:          E->ECO[lev][e].centre[3] = dx3;
Size_does_matter.c:984:          dx1 = max( fabs(E->SX[lev][1][n[3]]-E->SX[lev][1][n[1]]),
Size_does_matter.c:985:                     fabs(E->SX[lev][1][n[2]]-E->SX[lev][1][n[4]]) );
Size_does_matter.c:988:          E->ECO[lev][e].size[1] = dx1*E->ECO[lev][e].centre[3];
Size_does_matter.c:991:          dx1 = fabs(E->SX[lev][2][n[3]]-E->SX[lev][2][n[1]]);
Size_does_matter.c:993:              dx1 = min(E->SX[lev][2][n[3]],E->SX[lev][2][n[1]]) + 2.0*M_PI -
Size_does_matter.c:994:                  max(E->SX[lev][2][n[3]],E->SX[lev][2][n[1]]) ;
Size_does_matter.c:996:          dx2 = fabs(E->SX[lev][2][n[2]]-E->SX[lev][2][n[4]]);
Size_does_matter.c:998:              dx2 = min(E->SX[lev][2][n[2]],E->SX[lev][2][n[4]]) + 2.0*M_PI -
Size_does_matter.c:999:                  max(E->SX[lev][2][n[2]],E->SX[lev][2][n[4]]) ;
Size_does_matter.c:1004:          E->ECO[lev][e].size[2] = dx2*E->ECO[lev][e].centre[3]
Size_does_matter.c:1005:              *sin(E->ECO[lev][e].centre[1]);
Size_does_matter.c:1008:          dx3 = 0.25*(fabs(E->SX[lev][3][n[5]]+E->SX[lev][3][n[6]]
Size_does_matter.c:1009:                           +E->SX[lev][3][n[7]]+E->SX[lev][3][n[8]]
Size_does_matter.c:1010:                           -E->SX[lev][3][n[1]]-E->SX[lev][3][n[2]]
Size_does_matter.c:1011:                           -E->SX[lev][3][n[3]]-E->SX[lev][3][n[4]]));
Size_does_matter.c:1014:          E->ECO[lev][e].size[3] = dx3;
Size_does_matter.c:1018:              area += g_point[nint].weight[E->mesh.nsd-1] *
Size_does_matter.c:1019:                      E->GDA[lev][e].vpt[nint];
Size_does_matter.c:1020:          E->ECO[lev][e].area = area;
Size_does_matter.c:1022:          for(node=1;node<=enodes[E->mesh.nsd];node++)  {
Size_does_matter.c:1025:                  temp[node] += E->GDA[lev][e].vpt[nint] *
Size_does_matter.c:1026:                                g_point[nint].weight[E->mesh.nsd-1] *
Size_does_matter.c:1027:                                E->N.vpt[GNVINDEX(node,nint)];/* int Na dV */
Size_does_matter.c:1030:          for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:1031:              E->MASS[lev][E->IEN[lev][e].node[node]] += temp[node];
Size_does_matter.c:1034:          for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:1035:              E->TWW[lev][e].node[node] = temp[node];
Size_does_matter.c:1041:  if(lev == E->mesh.levmax)
Size_does_matter.c:1042:          for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:1043:            E->NMass[node] = E->MASS[lev][node];
Size_does_matter.c:1045:        if (E->control.NMULTIGRID||E->mesh.levmax==lev)
Size_does_matter.c:1046:            (E->exchange_node_d)(E,E->MASS[lev],lev);
Size_does_matter.c:1048:        for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:1049:            E->MASS[lev][node] = 1.0/E->MASS[lev][node];
Size_does_matter.c:1054:    for(node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:1055:        E->TMass[node] = 0.0;
Size_does_matter.c:1057:    for(e=1;e<=E->lmesh.nel;e++)  {
Size_does_matter.c:1058:      for(node=1;node<=enodes[E->mesh.nsd];node++) {
Size_does_matter.c:1060:          nz = ((E->ien[e].node[node]-1) % E->lmesh.noz) + 1;
Size_does_matter.c:1062:              temp[node] += E->refstate.rho[nz]
Size_does_matter.c:1063:                  * E->refstate.heat_capacity[nz]
Size_does_matter.c:1064:                  * E->gDA[e].vpt[nint]
Size_does_matter.c:1065:                  * g_point[nint].weight[E->mesh.nsd-1]
Size_does_matter.c:1066:                  * E->N.vpt[GNVINDEX(node,nint)];
Size_does_matter.c:1070:      for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:1071:          E->TMass[E->ien[e].node[node]] += temp[node];
Size_does_matter.c:1075:    (E->exchange_node_d)(E,E->TMass,E->mesh.levmax);
Size_does_matter.c:1076:    for(node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:1077:      E->TMass[node] = 1.0 / E->TMass[node];
Size_does_matter.c:1081:    E->lmesh.volume = 0;
Size_does_matter.c:1082:    E->mesh.volume = 0;
Size_does_matter.c:1084:    for(e=1;e<=E->lmesh.nel;e++)
Size_does_matter.c:1085:      E->lmesh.volume += E->eco[e].area;
Size_does_matter.c:1087:    MPI_Allreduce(&E->lmesh.volume, &E->mesh.volume, 1, MPI_DOUBLE,
Size_does_matter.c:1088:                  MPI_SUM, E->parallel.world);
Size_does_matter.c:1091:    if (E->control.verbose)  {
Size_does_matter.c:1092:        fprintf(E->fp_out, "rank=%d my_volume=%e total_volume=%e\n",
Size_does_matter.c:1093:                E->parallel.me, E->lmesh.volume, E->mesh.volume);
Size_does_matter.c:1095:        for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Size_does_matter.c:1096:            fprintf(E->fp_out,"output_mass lev=%d\n",lev);
Size_does_matter.c:1097:            fprintf(E->fp_out,"%d \n",E->sphere.capid);
Size_does_matter.c:1098:            for(e=1;e<=E->lmesh.NEL[lev];e++)
Size_does_matter.c:1099:                fprintf(E->fp_out,"%d %g \n",e,E->ECO[lev][e].area);
Size_does_matter.c:1100:            for (node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:1101:                fprintf(E->fp_out,"Mass[%d]= %g \n",node,E->MASS[lev][node]);
Size_does_matter.c:1104:        fprintf(E->fp_out,"capid =%d \n",E->sphere.capid);
Size_does_matter.c:1105:        for (node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:1106:            fprintf(E->fp_out,"TMass[%d]= %g \n",node,E->TMass[node]);
Size_does_matter.c:1107:        fflush(E->fp_out);
Solver_conj_grad.c:37:  E->control.CONJ_GRAD = 1;
Solver_conj_grad.c:38:  E->build_forcing_term =   assemble_forces_iterative;
Solver_conj_grad.c:39:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_conj_grad.c:40:  E->solver_allocate_vars = cg_allocate_vars;
Solver_conj_grad.c:66:  strip_bcs_from_residual(E,E->F,E->mesh.levmax);
Solver_multigrid.c:42:  E->control.NMULTIGRID = 1;
Solver_multigrid.c:43:  E->build_forcing_term =   assemble_forces_iterative;
Solver_multigrid.c:44:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_multigrid.c:45:  E->solver_allocate_vars = mg_allocate_vars;
Solver_multigrid.c:68:    const int dims = E->mesh.nsd;
Solver_multigrid.c:71:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:72:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:79:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Solver_multigrid.c:81:          node_coarse = E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:82:          node_fine=E->IEN[start_lev][E->EL[sl_minus][el].sub[i]].node[i];
Solver_multigrid.c:95:    const int dims = E->mesh.nsd;
Solver_multigrid.c:100:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:101:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:107:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Solver_multigrid.c:109:          node_coarse = E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:110:          node_fine=E->IEN[start_lev][E->EL[sl_minus][el].sub[i]].node[i];
Solver_multigrid.c:112:            eqn_fine   = E->ID[start_lev][node_fine].doff[j];
Solver_multigrid.c:113:            eqn_coarse = E->ID[sl_minus][node_coarse].doff[j];
Solver_multigrid.c:137:    const int dims = E->mesh.nsd;
Solver_multigrid.c:140:    const int neq = E->lmesh.NEQ[sl_plus];
Solver_multigrid.c:141:    const int nels = E->lmesh.NEL[start_lev];
Solver_multigrid.c:143:    assert(start_lev != E->mesh.levmax  /* un_injection */);
Solver_multigrid.c:150:        node = E->IEN[start_lev][el].node[i];
Solver_multigrid.c:151:        node_plus=E->IEN[sl_plus][E->EL[start_lev][el].sub[i]].node[i];
Solver_multigrid.c:153:        eqn1 = E->ID[start_lev][node].doff[1];
Solver_multigrid.c:154:        eqn2 = E->ID[start_lev][node].doff[2];
Solver_multigrid.c:155:        eqn3 = E->ID[start_lev][node].doff[3];
Solver_multigrid.c:156:        eqn_plus1 = E->ID[sl_plus][node_plus].doff[1];
Solver_multigrid.c:157:        eqn_plus2 = E->ID[sl_plus][node_plus].doff[2];
Solver_multigrid.c:158:        eqn_plus3 = E->ID[sl_plus][node_plus].doff[3];
Solver_multigrid.c:191:    const int dims =E->mesh.nsd;
Solver_multigrid.c:194:    const int nox = E->lmesh.NOX[level];
Solver_multigrid.c:195:    const int noz = E->lmesh.NOZ[level];
Solver_multigrid.c:196:    const int noy = E->lmesh.NOY[level];
Solver_multigrid.c:197:    const int high_eqn = E->lmesh.NEQ[level];
Solver_multigrid.c:199:    if (start_lev==E->mesh.levmax) return;
Solver_multigrid.c:202:    un_inject_vector(E,start_lev,AU,E->temp); /*  information from lower level */
Solver_multigrid.c:203:    fill_in_gaps(E,E->temp,level);
Solver_multigrid.c:204:    from_xyz_to_rtf(E,level,E->temp,AU);      /* get back to rtf coordinates */
Solver_multigrid.c:227:    const int nsd=E->mesh.nsd;
Solver_multigrid.c:232:  lv = E->mesh.levmax;
Solver_multigrid.c:234:    viscU=(float *)malloc((1+E->lmesh.NNO[lv])*sizeof(float));
Solver_multigrid.c:235:    viscD=(float *)malloc((1+vpts*E->lmesh.NEL[lv-1])*sizeof(float));
Solver_multigrid.c:238:  if(E->viscosity.allow_anisotropic_viscosity){
Solver_multigrid.c:239:    for(lv=E->mesh.levmax;lv>E->mesh.levmin;lv--)     {
Solver_multigrid.c:241:      if (E->viscosity.smooth_cycles==1)  {
Solver_multigrid.c:242:        visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);	/* isotropic */
Solver_multigrid.c:244:        visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:246:        visc_from_gint_to_nodes(E,E->EVI2[lv],viscU,lv);
Solver_multigrid.c:248:        visc_from_nodes_to_gint(E,viscD,E->EVI2[sl_minus],sl_minus);
Solver_multigrid.c:250:        visc_from_gint_to_nodes(E,E->EVIn1[lv],viscU,lv);
Solver_multigrid.c:252:        visc_from_nodes_to_gint(E,viscD,E->EVIn1[sl_minus],sl_minus);
Solver_multigrid.c:254:        visc_from_gint_to_nodes(E,E->EVIn2[lv],viscU,lv);
Solver_multigrid.c:256:        visc_from_nodes_to_gint(E,viscD,E->EVIn2[sl_minus],sl_minus);
Solver_multigrid.c:258:        visc_from_gint_to_nodes(E,E->EVIn3[lv],viscU,lv);
Solver_multigrid.c:260:        visc_from_nodes_to_gint(E,viscD,E->EVIn3[sl_minus],sl_minus);
Solver_multigrid.c:262:      else if (E->viscosity.smooth_cycles==2)   {
Solver_multigrid.c:263:        visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv); /* isotropic */
Solver_multigrid.c:264:        inject_scalar_e(E,lv,viscU,E->EVI[sl_minus]);
Solver_multigrid.c:266:        visc_from_gint_to_ele(E,E->EVI2[lv],viscU,lv);
Solver_multigrid.c:267:        inject_scalar_e(E,lv,viscU,E->EVI2[sl_minus]);
Solver_multigrid.c:269:        visc_from_gint_to_ele(E,E->EVIn1[lv],viscU,lv);
Solver_multigrid.c:270:        inject_scalar_e(E,lv,viscU,E->EVIn1[sl_minus]);
Solver_multigrid.c:272:        visc_from_gint_to_ele(E,E->EVIn2[lv],viscU,lv);
Solver_multigrid.c:273:        inject_scalar_e(E,lv,viscU,E->EVIn2[sl_minus]);
Solver_multigrid.c:275:        visc_from_gint_to_ele(E,E->EVIn3[lv],viscU,lv);
Solver_multigrid.c:276:        inject_scalar_e(E,lv,viscU,E->EVIn3[sl_minus]);
Solver_multigrid.c:278:      else if (E->viscosity.smooth_cycles==3)   {
Solver_multigrid.c:279:        visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);/* isotropic */
Solver_multigrid.c:281:        visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:283:        visc_from_gint_to_ele(E,E->EVI2[lv],viscU,lv);
Solver_multigrid.c:285:        visc_from_ele_to_gint(E,viscD,E->EVI2[sl_minus],sl_minus);
Solver_multigrid.c:287:        visc_from_gint_to_ele(E,E->EVIn1[lv],viscU,lv);
Solver_multigrid.c:289:        visc_from_ele_to_gint(E,viscD,E->EVIn1[sl_minus],sl_minus);
Solver_multigrid.c:291:        visc_from_gint_to_ele(E,E->EVIn2[lv],viscU,lv);
Solver_multigrid.c:293:        visc_from_ele_to_gint(E,viscD,E->EVIn2[sl_minus],sl_minus);
Solver_multigrid.c:295:        visc_from_gint_to_ele(E,E->EVIn3[lv],viscU,lv);
Solver_multigrid.c:297:        visc_from_ele_to_gint(E,viscD,E->EVIn3[sl_minus],sl_minus);
Solver_multigrid.c:299:      else if (E->viscosity.smooth_cycles==0)  {
Solver_multigrid.c:300:        inject_scalar(E,lv,E->VI[lv],E->VI[sl_minus]);/* isotropic */
Solver_multigrid.c:301:        visc_from_nodes_to_gint(E,E->VI[sl_minus],E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:304:        inject_scalar(E,lv,E->VI2[lv],E->VI2[sl_minus]);
Solver_multigrid.c:305:        visc_from_nodes_to_gint(E,E->VI2[sl_minus],E->EVI2[sl_minus],sl_minus);
Solver_multigrid.c:307:        inject_scalar(E,lv,E->VIn1[lv],E->VIn1[sl_minus]);
Solver_multigrid.c:308:        visc_from_nodes_to_gint(E,E->VIn1[sl_minus],E->EVIn1[sl_minus],sl_minus);
Solver_multigrid.c:309:        inject_scalar(E,lv,E->VIn2[lv],E->VIn2[sl_minus]);
Solver_multigrid.c:310:        visc_from_nodes_to_gint(E,E->VIn2[sl_minus],E->EVIn2[sl_minus],sl_minus);
Solver_multigrid.c:311:        inject_scalar(E,lv,E->VIn3[lv],E->VIn3[sl_minus]);
Solver_multigrid.c:312:        visc_from_nodes_to_gint(E,E->VIn3[sl_minus],E->EVIn3[sl_minus],sl_minus);
Solver_multigrid.c:314:      normalize_director_at_gint(E,E->EVIn1[sl_minus],E->EVIn2[sl_minus],E->EVIn3[sl_minus],sl_minus);      
Solver_multigrid.c:319:    for(lv=E->mesh.levmax;lv>E->mesh.levmin;lv--)     {
Solver_multigrid.c:323:      if (E->viscosity.smooth_cycles==1)  {
Solver_multigrid.c:324:	visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:326:	visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:328:      else if (E->viscosity.smooth_cycles==2)   {
Solver_multigrid.c:329:	visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:330:	inject_scalar_e(E,lv,viscU,E->EVI[sl_minus]);
Solver_multigrid.c:332:      else if (E->viscosity.smooth_cycles==3)   {
Solver_multigrid.c:333:	visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:335:	visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:337:      else if (E->viscosity.smooth_cycles==0)  {
Solver_multigrid.c:338:	/*      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:340:		visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus); */
Solver_multigrid.c:342:	inject_scalar(E,lv,E->VI[lv],E->VI[sl_minus]);
Solver_multigrid.c:343:	visc_from_nodes_to_gint(E,E->VI[sl_minus],E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:367:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:368:    const int dims=E->mesh.nsd;
Solver_multigrid.c:369:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:370:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c:379:          e = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:397:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:398:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:399:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:401:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c:411:            e = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:432:    const int nno_minus=E->lmesh.NNO[start_lev-1];
Solver_multigrid.c:433:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:434:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:435:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:445:          node1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:447:              node=E->IEN[start_lev][node1].node[j];
Solver_multigrid.c:453:          node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:455:          AD[node] += w * E->TWW[sl_minus][el].node[i];
Solver_multigrid.c:458:   (E->exchange_node_f)(E,AD,sl_minus);
Solver_multigrid.c:461:     AD[i] *= E->MASS[sl_minus][i];
Solver_multigrid.c:483:    const int neq_minus=E->lmesh.NEQ[start_lev-1];
Solver_multigrid.c:484:    const int nno_minus=E->lmesh.NNO[start_lev-1];
Solver_multigrid.c:485:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:486:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:487:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:495:   if (start_lev==E->mesh.levmin) 
Solver_multigrid.c:499:    from_rtf_to_xyz(E,start_lev,AU,E->temp);
Solver_multigrid.c:502:      E->temp1[i] = 0.0;
Solver_multigrid.c:507:            node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:509:            e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:511:              node1=E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:512:              average1 += E->temp[E->ID[start_lev][node1].doff[1]];
Solver_multigrid.c:513:              average2 += E->temp[E->ID[start_lev][node1].doff[2]];
Solver_multigrid.c:514:              average3 += E->temp[E->ID[start_lev][node1].doff[3]];
Solver_multigrid.c:516:            w = weight*E->TWW[sl_minus][el].node[i];
Solver_multigrid.c:518:            E->temp1[E->ID[sl_minus][node].doff[1]] += w * average1;
Solver_multigrid.c:519:            E->temp1[E->ID[sl_minus][node].doff[2]] += w * average2;
Solver_multigrid.c:520:            E->temp1[E->ID[sl_minus][node].doff[3]] += w * average3;
Solver_multigrid.c:524:   (E->solver.exchange_id_d)(E, E->temp1, sl_minus);
Solver_multigrid.c:527:     E->temp1[E->ID[sl_minus][i].doff[1]] *= E->MASS[sl_minus][i];
Solver_multigrid.c:528:     E->temp1[E->ID[sl_minus][i].doff[2]] *= E->MASS[sl_minus][i];
Solver_multigrid.c:529:     E->temp1[E->ID[sl_minus][i].doff[3]] *= E->MASS[sl_minus][i];
Solver_multigrid.c:533:   from_xyz_to_rtf(E,sl_minus,E->temp1,AD);
Solver_multigrid.c:546:   for (i=1;i<=E->lmesh.NNO[level];i++)  {
Solver_multigrid.c:547:     eqn1 = E->ID[level][i].doff[1];
Solver_multigrid.c:548:     eqn2 = E->ID[level][i].doff[2];
Solver_multigrid.c:549:     eqn3 = E->ID[level][i].doff[3];
Solver_multigrid.c:550:     sint = E->SinCos[level][0][i];
Solver_multigrid.c:551:     sinf = E->SinCos[level][1][i];
Solver_multigrid.c:552:     cost = E->SinCos[level][2][i];
Solver_multigrid.c:553:     cosf = E->SinCos[level][3][i];
Solver_multigrid.c:570:   for (i=1;i<=E->lmesh.NNO[level];i++)  {
Solver_multigrid.c:571:     eqn1 = E->ID[level][i].doff[1];
Solver_multigrid.c:572:     eqn2 = E->ID[level][i].doff[2];
Solver_multigrid.c:573:     eqn3 = E->ID[level][i].doff[3];
Solver_multigrid.c:574:     sint = E->SinCos[level][0][i];
Solver_multigrid.c:575:     sinf = E->SinCos[level][1][i];
Solver_multigrid.c:576:     cost = E->SinCos[level][2][i];
Solver_multigrid.c:577:     cosf = E->SinCos[level][3][i];
Solver_multigrid.c:597:    const int dims =E->mesh.nsd;
Solver_multigrid.c:600:    const int nox = E->lmesh.NOX[level];
Solver_multigrid.c:601:    const int noz = E->lmesh.NOZ[level];
Solver_multigrid.c:602:    const int noy = E->lmesh.NOY[level];
Solver_multigrid.c:616:	      eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:617:	      eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:618:	      eqn2=E->ID[level][node2].doff[1];
Solver_multigrid.c:621:	      eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:622:	      eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:623:	      eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:626:	      eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:627:	      eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:628:	      eqn2=E->ID[level][node2].doff[3];
Solver_multigrid.c:640:	        eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:641:	        eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:642:	        eqn2=E->ID[level][node2].doff[1];
Solver_multigrid.c:645:	        eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:646:	        eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:647:	        eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:650:	        eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:651:	        eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:652:	        eqn2=E->ID[level][node2].doff[3];
Solver_multigrid.c:658:       x1 = E->sphere.R[level][j] - E->sphere.R[level][j-1];
Solver_multigrid.c:659:       x2 = E->sphere.R[level][j+1] - E->sphere.R[level][j];
Solver_multigrid.c:668:            eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:669:            eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:670:            eqn2=E->ID[level][node2].doff[1];
Solver_multigrid.c:673:            eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:674:            eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:675:            eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:678:            eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:679:            eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:680:            eqn2=E->ID[level][node2].doff[3];
Sphere_harmonics.c:22:    for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:24:            E->sphere.hindex[ll][mm] = i;
Sphere_harmonics.c:28:    E->sphere.hindice = i;
Sphere_harmonics.c:33:        E->sphere.harm_geoid[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:34:        E->sphere.harm_geoid_from_bncy[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:35:        E->sphere.harm_geoid_from_bncy_botm[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:36:        E->sphere.harm_geoid_from_tpgt[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:37:        E->sphere.harm_geoid_from_tpgb[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:39:        E->sphere.harm_tpgt[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:40:        E->sphere.harm_tpgb[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:109:    for (i=0;i<E->sphere.hindice;i++)    {
Sphere_harmonics.c:114:    for (es=1;es<=E->lmesh.snel;es++)   {
Sphere_harmonics.c:116:        for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:119:                p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:121:                for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Sphere_harmonics.c:122:                    for(d=1;d<=onedvpoints[E->mesh.nsd];d++)   {
Sphere_harmonics.c:123:                        j = E->sien[es].node[d];
Sphere_harmonics.c:124:                        sphc[p] += TG[E->sien[es].node[d]]
Sphere_harmonics.c:125:                            * E->sphere.tablesplm[j][p]
Sphere_harmonics.c:126:                            * E->sphere.tablescosf[j][mm]
Sphere_harmonics.c:127:                            * E->M.vpt[GMVINDEX(d,nint)]
Sphere_harmonics.c:128:                            * E->surf_det[nint][es];
Sphere_harmonics.c:129:                        sphs[p] += TG[E->sien[es].node[d]]
Sphere_harmonics.c:130:                            * E->sphere.tablesplm[j][p]
Sphere_harmonics.c:131:                            * E->sphere.tablessinf[j][mm]
Sphere_harmonics.c:132:                            * E->M.vpt[GMVINDEX(d,nint)]
Sphere_harmonics.c:133:                            * E->surf_det[nint][es];
Sphere_harmonics.c:154:    TT = (float *) malloc ((E->lmesh.nsf+1)*sizeof(float));
Sphere_harmonics.c:157:    sph_harm[0] = (float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:159:    sph_harm[1] = (float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:161:    for(k=1;k<=E->lmesh.noz;k++)  {
Sphere_harmonics.c:162:      for(i=1;i<=E->lmesh.noy;i++)
Sphere_harmonics.c:163:          for(j=1;j<=E->lmesh.nox;j++)  {
Sphere_harmonics.c:164:              node= k + (j-1)*E->lmesh.noz + (i-1)*E->lmesh.nox*E->lmesh.noz;
Sphere_harmonics.c:165:              p = j + (i-1)*E->lmesh.nox;
Sphere_harmonics.c:166:              TT[p] = E->T[node];
Sphere_harmonics.c:173:        if(E->parallel.me < E->parallel.nprocz) {
Sphere_harmonics.c:174:            for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:176:                    p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:178:                            k+E->lmesh.nzs-1, ll, mm,
Sphere_harmonics.c:195:    E->sphere.tablesplm = 
Sphere_harmonics.c:196:      (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:197:    E->sphere.tablescosf = 
Sphere_harmonics.c:198:      (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:199:    E->sphere.tablessinf = 
Sphere_harmonics.c:200:      (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:202:    for (i=1;i<=E->lmesh.nsf;i++)   {
Sphere_harmonics.c:203:        E->sphere.tablesplm[i]= 
Sphere_harmonics.c:204:          (double *)malloc((E->sphere.hindice)*sizeof(double));
Sphere_harmonics.c:205:        E->sphere.tablescosf[i]= 
Sphere_harmonics.c:206:          (double *)malloc((E->output.llmax+1)*sizeof(double));
Sphere_harmonics.c:207:        E->sphere.tablessinf[i]= 
Sphere_harmonics.c:208:          (double *)malloc((E->output.llmax+1)*sizeof(double));
Sphere_harmonics.c:211:    for (j=1;j<=E->lmesh.nsf;j++)  {
Sphere_harmonics.c:212:        node = j*E->lmesh.noz;
Sphere_harmonics.c:213:        f=E->sx[2][node];
Sphere_harmonics.c:214:        t=E->sx[1][node];
Sphere_harmonics.c:215:        for (mm=0;mm<=E->output.llmax;mm++)   {
Sphere_harmonics.c:217:          E->sphere.tablescosf[j][mm] = cos( mmf );
Sphere_harmonics.c:218:          E->sphere.tablessinf[j][mm] = sin( mmf );
Sphere_harmonics.c:221:        for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:223:            p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:224:            E->sphere.tablesplm[j][p] = modified_plgndr_a(ll,mm,t) ;
Sphere_util.c:77:        ia[2] = E->lmesh.noz*E->lmesh.nox-E->lmesh.noz+1;
Sphere_util.c:78:        ia[3] = E->lmesh.nno-E->lmesh.noz+1;
Sphere_util.c:79:        ia[4] = ia[3]-E->lmesh.noz*(E->lmesh.nox-1);
Sphere_util.c:82:            xx[1][i] = E->x[1][ia[i]]/E->sx[3][ia[1]];
Sphere_util.c:83:            xx[2][i] = E->x[2][ia[i]]/E->sx[3][ia[1]];
Sphere_util.c:84:            xx[3][i] = E->x[3][ia[i]]/E->sx[3][ia[1]];
Sphere_util.c:90:            E->sphere.angle[i] = angle[i];
Sphere_util.c:92:        E->sphere.area = area_sphere_cap(angle);
Sphere_util.c:94:        for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)
Sphere_util.c:95:            for (es=1;es<=E->lmesh.SNEL[lev];es++)              {
Sphere_util.c:96:                el = (es-1)*E->lmesh.ELZ[lev]+1;
Sphere_util.c:98:                    ia[i] = E->IEN[lev][el].node[i];
Sphere_util.c:101:                    xx[1][i] = E->X[lev][1][ia[i]]/E->SX[lev][3][ia[1]];
Sphere_util.c:102:                    xx[2][i] = E->X[lev][2][ia[i]]/E->SX[lev][3][ia[1]];
Sphere_util.c:103:                    xx[3][i] = E->X[lev][3][ia[i]]/E->SX[lev][3][ia[1]];
Sphere_util.c:109:                    E->sphere.angle1[lev][i][es] = angle[i];
Sphere_util.c:111:                E->sphere.area1[lev][es] = area_sphere_cap(angle);
Sphere_util.c:113:/*              fprintf(E->fp_out,"lev%d %d %.6e %.6e %.6e %.6e %.6e\n",lev,es,angle[1],angle[2],angle[3],angle[4],E->sphere.area1[lev][m][es]); */
Sphere_util.c:182:        ia[i] = E->IEN[lev][el].node[i];
Sphere_util.c:184:    es = (el-1)/E->lmesh.ELZ[lev]+1;
Sphere_util.c:187:        xx[1] = E->X[lev][1][ia[i]]/E->SX[lev][3][ia[1]];
Sphere_util.c:188:        xx[2] = E->X[lev][2][ia[i]]/E->SX[lev][3][ia[1]];
Sphere_util.c:189:        xx[3] = E->X[lev][3][ia[i]]/E->SX[lev][3][ia[1]];
Sphere_util.c:191:        angle1[i]= E->sphere.angle1[lev][i][es];
Stokes_flow_Incomp.c:70:    cycles=E->control.p_iterations;
Stokes_flow_Incomp.c:74:    solve_Ahat_p_fhat(E,E->U,E->P,E->F,E->control.accuracy,&cycles);
Stokes_flow_Incomp.c:76:    if(E->control.pseudo_free_surf)
Stokes_flow_Incomp.c:81:    p_to_nodes(E,E->P,E->NP,E->mesh.levmax);
Stokes_flow_Incomp.c:89:     * This norm is ~= E->monitor.momentum_residual */
Stokes_flow_Incomp.c:98:    const int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:99:    const int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:105:    assemble_grad_p(E, P, E->u1, lev);
Stokes_flow_Incomp.c:108:      r2[i] = F[i] - E->u1[i] - r1[i];
Stokes_flow_Incomp.c:129:    fprintf(E->fp, "(%03d) %5.1f s v=%e p=%e "
Stokes_flow_Incomp.c:132:            E->monitor.solution_cycles);
Stokes_flow_Incomp.c:136:            E->monitor.solution_cycles);
Stokes_flow_Incomp.c:146:    if(E->control.check_continuity_convergence)
Stokes_flow_Incomp.c:147:        return (E->monitor.incompressibility > acc) ||
Stokes_flow_Incomp.c:150:        return (E->monitor.incompressibility > acc) &&
Stokes_flow_Incomp.c:159:    if(E->control.inv_gruneisen == 0)
Stokes_flow_Incomp.c:162:        if(strcmp(E->control.uzawa, "cg") == 0)
Stokes_flow_Incomp.c:164:        else if(strcmp(E->control.uzawa, "bicg") == 0)
Stokes_flow_Incomp.c:206:    inner_imp = imp * E->control.inner_accuracy_scale; /* allow for different innner loop accuracy */
Stokes_flow_Incomp.c:208:    npno = E->lmesh.npno;
Stokes_flow_Incomp.c:209:    neq = E->lmesh.neq;
Stokes_flow_Incomp.c:210:    lev = E->mesh.levmax;
Stokes_flow_Incomp.c:222:    v_res = E->monitor.fdotf;
Stokes_flow_Incomp.c:231:    if(E->control.inv_gruneisen != 0) {
Stokes_flow_Incomp.c:242:    if(E->control.inv_gruneisen == 0)
Stokes_flow_Incomp.c:250:    if(E->control.inv_gruneisen != 0)
Stokes_flow_Incomp.c:254:    E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:255:    E->monitor.incompressibility = sqrt(global_div_norm2(E, r1)
Stokes_flow_Incomp.c:256:                                        / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:258:    v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:259:    p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:264:    if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:268:                                   E->monitor.incompressibility);
Stokes_flow_Incomp.c:279:          z1[j] = E->BPI[lev][j] * r1[j];
Stokes_flow_Incomp.c:299:        valid = solve_del2_u(E, E->u1, F, inner_imp*v_res, lev);
Stokes_flow_Incomp.c:300:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:302:            fputs("Warning: solver not converging! 1\n", E->fp);
Stokes_flow_Incomp.c:304:        strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:308:        assemble_div_u(E, E->u1, F, lev);
Stokes_flow_Incomp.c:325:          V[j] -= alpha * E->u1[j];
Stokes_flow_Incomp.c:329:        E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:330:        E->monitor.pdotp = global_p_norm2(E, P);
Stokes_flow_Incomp.c:331:        v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:332:        p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:334:          alpha * sqrt(global_v_norm2(E, E->u1) / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:336:          alpha * sqrt(global_p_norm2(E, s2) / (1e-32 + E->monitor.pdotp));
Stokes_flow_Incomp.c:341:        if(E->control.inv_gruneisen != 0)
Stokes_flow_Incomp.c:344:        E->monitor.incompressibility = sqrt(global_div_norm2(E, z1)
Stokes_flow_Incomp.c:345:                                            / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:350:        if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:354:                                       E->monitor.incompressibility);
Stokes_flow_Incomp.c:362:          if(E->control.check_pressure_convergence) {
Stokes_flow_Incomp.c:389:	if((E->sphere.caps == 12) && (E->control.inner_remove_rigid_rotation)){
Stokes_flow_Incomp.c:392:	  if(E->control.pseudo_free_surf) /* move from U to V */
Stokes_flow_Incomp.c:402:    if(E->control.inv_gruneisen != 0)
Stokes_flow_Incomp.c:454:    inner_imp = imp * E->control.inner_accuracy_scale; /* allow for different innner loop accuracy */
Stokes_flow_Incomp.c:456:    npno = E->lmesh.npno;
Stokes_flow_Incomp.c:457:    neq = E->lmesh.neq;
Stokes_flow_Incomp.c:458:    lev = E->mesh.levmax;
Stokes_flow_Incomp.c:475:    v_res = E->monitor.fdotf;
Stokes_flow_Incomp.c:489:    E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:490:    E->monitor.incompressibility = sqrt(global_div_norm2(E, r1)
Stokes_flow_Incomp.c:491:                                        / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:493:    v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:494:    p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:500:    if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:504:                                   E->monitor.incompressibility);
Stokes_flow_Incomp.c:522:            fprintf(E->fp, "BiCGstab method failed!!\n");
Stokes_flow_Incomp.c:541:            pt[j] = E->BPI[lev][j] * p2[j];
Stokes_flow_Incomp.c:547:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:549:            fputs("Warning: solver not converging! 1\n", E->fp);
Stokes_flow_Incomp.c:565:            st[j] = E->BPI[lev][j] * s0[j];
Stokes_flow_Incomp.c:569:        valid = solve_del2_u(E, E->u1, F, inner_imp*v_res, lev);
Stokes_flow_Incomp.c:570:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:572:            fputs("Warning: solver not converging! 2\n", E->fp);
Stokes_flow_Incomp.c:574:        strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:578:        assemble_div_rho_u(E, E->u1, t0, lev);
Stokes_flow_Incomp.c:596:            F[j] = alpha * u0[j] + omega * E->u1[j];
Stokes_flow_Incomp.c:603:        E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:604:        E->monitor.pdotp = global_p_norm2(E, P);
Stokes_flow_Incomp.c:605:        v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:606:        p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:607:        dvelocity = sqrt(global_v_norm2(E, F) / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:608:        dpressure = sqrt(global_p_norm2(E, s0) / (1e-32 + E->monitor.pdotp));
Stokes_flow_Incomp.c:614:        E->monitor.incompressibility = sqrt(global_div_norm2(E, t0)
Stokes_flow_Incomp.c:615:                                            / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:622:        if(E->control.print_convergence && E->parallel.me==0) {
Stokes_flow_Incomp.c:626:                                       E->monitor.incompressibility);
Stokes_flow_Incomp.c:634:        if(E->control.check_pressure_convergence) {
Stokes_flow_Incomp.c:693:    const int npno = E->lmesh.npno;
Stokes_flow_Incomp.c:694:    const int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:695:    const int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:706:    cycles = E->control.p_iterations;
Stokes_flow_Incomp.c:709:                         imp * E->control.inner_accuracy_scale * E->monitor.fdotf);
Stokes_flow_Incomp.c:718:          (num_of_loop <= E->control.compress_iter_maxstep)) {
Stokes_flow_Incomp.c:728:        assemble_div_rho_u(E, V, E->u1, lev);
Stokes_flow_Incomp.c:729:        div_res = sqrt(global_div_norm2(E, E->u1) / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:735:                               (1.0e-32 + E->monitor.vdotv) );
Stokes_flow_Incomp.c:741:                               (1.0e-32 + E->monitor.pdotp) );
Stokes_flow_Incomp.c:743:        if(E->parallel.me == 0) {
Stokes_flow_Incomp.c:745:            fprintf(E->fp, "itercg -- div(rho*v)/v=%.2e dv/v=%.2e and dp/p=%.2e loop %d\n\n", div_res, relative_err_v, relative_err_p, num_of_loop);
Stokes_flow_Incomp.c:767:    int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:768:    int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:772:    assemble_grad_p(E, P, E->u1, lev);
Stokes_flow_Incomp.c:774:      F[i] = F[i] - E->u1[i];
Stokes_flow_Incomp.c:776:    assemble_del2_u(E, V, E->u1, lev, 1);
Stokes_flow_Incomp.c:778:      F[i] = F[i] - E->u1[i];
Stokes_flow_Incomp.c:784:    valid = solve_del2_u(E, E->u1, F, acc, lev);
Stokes_flow_Incomp.c:785:    if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:787:        fputs("Warning: solver not converging! 0\n", E->fp);
Stokes_flow_Incomp.c:789:    strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:794:        V[i] += E->u1[i];
Topo_gravity.c:89:   for(snode=1;snode<=E->lmesh.nsf;snode++)   {
Topo_gravity.c:90:      node = E->surf_node[snode];
Topo_gravity.c:92:      tpgb[snode] =  2*SZZ[node-E->lmesh.noz+1]- SZZ[node-E->lmesh.noz+2];
Topo_gravity.c:108:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Topo_gravity.c:109:    for(snode=1;snode<=E->lmesh.nsf;snode++) {
Topo_gravity.c:110:      node = E->surf_node[snode];
Topo_gravity.c:111:      freesurf[snode] += E->sphere.cap.V[3][node] * E->advection.timestep;
Topo_gravity.c:122:  SXX = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:123:  SYY = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:124:  SXY = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:125:  SXZ = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:126:  SZY = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:127:  SZZ = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:128:  divv = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:129:  vorv = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:131:  for(i=1;i<=E->lmesh.nno;i++) {
Topo_gravity.c:186:  const int lev = E->mesh.levmax;
Topo_gravity.c:187:  const int dims = E->mesh.nsd;
Topo_gravity.c:188:  const int nel = E->lmesh.nel;
Topo_gravity.c:207:      dOmega = &(E->gDA[e]);	/* Jacobian at integration points */
Topo_gravity.c:208:      GNx = &(E->gNX[e]);	/* derivatives of shape functions at
Topo_gravity.c:222:	/* E->EVi[j] = E->EVI[E->mesh.levmax][j]; */
Topo_gravity.c:223:        pre[j] =  E->EVi[(e-1)*vpts+j]*dOmega->vpt[j];
Topo_gravity.c:240:          tww[i] += dOmega->vpt[j] * g_point[j].weight[E->mesh.nsd-1]
Topo_gravity.c:241:            * E->N.vpt[GNVINDEX(i,j)];
Topo_gravity.c:243:      if (E->control.precise_strain_rate){
Topo_gravity.c:248:	if ((e-1)%E->lmesh.elz==0) {
Topo_gravity.c:249:	  construct_c3x3matrix_el(E,e,&E->element_Cc,&E->element_Ccx,lev,0);
Topo_gravity.c:252:	get_ba(&(E->N), GNx, &E->element_Cc, &E->element_Ccx,rtf, dims, ba);
Topo_gravity.c:266:				     + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])/sin(rtf[1][j])
Topo_gravity.c:270:		+ VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])
Topo_gravity.c:283:			  + VV[3][i]*E->N.vpt[GNVINDEX(i,j)] )*rtf[3][j];
Topo_gravity.c:285:			   + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j]))/sin(rtf[1][j])
Topo_gravity.c:286:			  + VV[3][i]*E->N.vpt[GNVINDEX(i,j)] )*rtf[3][j];
Topo_gravity.c:290:			   - VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j]))/sin(rtf[1][j])
Topo_gravity.c:293:									 *GNx->vpt[GNVXINDEX(0,i,j)]-VV[1][i]*E->N.vpt[GNVINDEX(i,j)]);
Topo_gravity.c:295:									 *GNx->vpt[GNVXINDEX(1,i,j)]/sin(rtf[1][j])-VV[2][i]*E->N.vpt[GNVINDEX(i,j)]);
Topo_gravity.c:298:				     + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])/sin(rtf[1][j])
Topo_gravity.c:302:		+ VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])
Topo_gravity.c:308:      if(E->control.inv_gruneisen != 0) { /* isotropic component */
Topo_gravity.c:313:    if(E->viscosity.allow_anisotropic_viscosity){ /* general anisotropic */
Topo_gravity.c:322:			 E->EVIn1[E->mesh.levmax][l1], 
Topo_gravity.c:323:			 E->EVIn2[E->mesh.levmax][l1], 
Topo_gravity.c:324:			 E->EVIn3[E->mesh.levmax][l1],
Topo_gravity.c:325:			 E->EVI2[E->mesh.levmax][l1],
Topo_gravity.c:326:			 E->avmode[E->mesh.levmax][l1],
Topo_gravity.c:369:      Sxx /= E->eco[e].area;
Topo_gravity.c:370:      Syy /= E->eco[e].area;
Topo_gravity.c:371:      Szz /= E->eco[e].area;
Topo_gravity.c:372:      Sxy /= E->eco[e].area;
Topo_gravity.c:373:      Sxz /= E->eco[e].area;
Topo_gravity.c:374:      Szy /= E->eco[e].area;
Topo_gravity.c:375:      div /= E->eco[e].area;
Topo_gravity.c:376:      vor /= E->eco[e].area;
Topo_gravity.c:379:      Szz -= E->P[e];
Topo_gravity.c:380:      Sxx -= E->P[e];
Topo_gravity.c:381:      Syy -= E->P[e];
Topo_gravity.c:384:        node = E->ien[e].node[i]; /* assign to global nodes */
Topo_gravity.c:397:  (E->exchange_node_f)(E,SXX,lev);
Topo_gravity.c:398:  (E->exchange_node_f)(E,SYY,lev);
Topo_gravity.c:399:  (E->exchange_node_f)(E,SZZ,lev);
Topo_gravity.c:400:  (E->exchange_node_f)(E,SXY,lev);
Topo_gravity.c:401:  (E->exchange_node_f)(E,SXZ,lev);
Topo_gravity.c:402:  (E->exchange_node_f)(E,SZY,lev);
Topo_gravity.c:403:  (E->exchange_node_f)(E,divv,lev);
Topo_gravity.c:404:  (E->exchange_node_f)(E,vorv,lev);
Topo_gravity.c:408:    for(node=1;node<=E->lmesh.nno;node++)   {
Topo_gravity.c:409:      mass_fac = E->Mass[node]*stress_scaling;
Topo_gravity.c:417:      mass_fac = E->Mass[node]*velo_scaling;
Topo_gravity.c:423:    for (node=1;node<=E->lmesh.nno;node++) {
Topo_gravity.c:424:      E->gstress[(node-1)*6+1] = SXX[node];
Topo_gravity.c:425:      E->gstress[(node-1)*6+2] = SYY[node];
Topo_gravity.c:426:      E->gstress[(node-1)*6+3] = SZZ[node];
Topo_gravity.c:427:      E->gstress[(node-1)*6+4] = SXY[node];
Topo_gravity.c:428:      E->gstress[(node-1)*6+5] = SXZ[node];
Topo_gravity.c:429:      E->gstress[(node-1)*6+6] = SZY[node];
Topo_gravity.c:446:                                   {0, 4, 2, 6}, /* E-W sides   yx yy yz */
Topo_gravity.c:451:  noxnoz = E->lmesh.nox*E->lmesh.noz;
Topo_gravity.c:453:  if(E->control.side_sbcs) {	/* side boundary conditions */
Topo_gravity.c:455:      for(i=1; i<=E->lmesh.noy; i++)
Topo_gravity.c:456:        for(j=1; j<=E->lmesh.nox; j++)
Topo_gravity.c:457:          for(k=1; k<=E->lmesh.noz; k++) {
Topo_gravity.c:458:            n = k+(j-1)*E->lmesh.noz+(i-1)*noxnoz;
Topo_gravity.c:459:            for(d=1; d<=E->mesh.nsd; d++)
Topo_gravity.c:460:              if(E->node[n] & sbc_flag[d]) {
Topo_gravity.c:462:                  E->gstress[(n-1)*6+stress_index[d][2]] = 
Topo_gravity.c:463:                    E->sbc.SB[SIDE_WEST][d][ E->sbc.node[n] ];
Topo_gravity.c:464:                if(i==E->lmesh.noy)
Topo_gravity.c:465:                  E->gstress[(n-1)*6+stress_index[d][2]] = 
Topo_gravity.c:466:                    E->sbc.SB[SIDE_EAST][d][ E->sbc.node[n] ];
Topo_gravity.c:468:                  E->gstress[(n-1)*6+stress_index[d][1]] = 
Topo_gravity.c:469:                    E->sbc.SB[SIDE_NORTH][d][ E->sbc.node[n] ];
Topo_gravity.c:470:                if(j==E->lmesh.nox)
Topo_gravity.c:471:                  E->gstress[(n-1)*6+stress_index[d][1]] = 
Topo_gravity.c:472:                    E->sbc.SB[SIDE_SOUTH][d][ E->sbc.node[n] ];
Topo_gravity.c:474:                  E->gstress[(n-1)*6+stress_index[d][3]] = 
Topo_gravity.c:475:                    E->sbc.SB[SIDE_BOTTOM][d][ E->sbc.node[n] ];
Topo_gravity.c:476:                if(k==E->lmesh.noz)
Topo_gravity.c:477:                  E->gstress[(n-1)*6+stress_index[d][3]] = 
Topo_gravity.c:478:                    E->sbc.SB[SIDE_TOP][d][ E->sbc.node[n] ];
Topo_gravity.c:486:    if(E->mesh.toplayerbc != 0){
Topo_gravity.c:488:	for(i=1; i<=E->lmesh.noy; i++)
Topo_gravity.c:489:	  for(j=1; j<=E->lmesh.nox; j++)
Topo_gravity.c:490:	    for(k=1; k<=E->lmesh.noz; k++) {
Topo_gravity.c:491:	      n = k+(j-1)*E->lmesh.noz+(i-1)*noxnoz;
Topo_gravity.c:492:	      for(d=1; d<=E->mesh.nsd; d++)
Topo_gravity.c:493:		if(E->node[n] & sbc_flag[d]) {
Topo_gravity.c:495:		  E->gstress[(n-1)*6+stress_index[d][3]] = E->sphere.cap.VB[d][n];
Topo_gravity.c:500:	for(i=1; i<=E->lmesh.noy; i++)
Topo_gravity.c:501:	  for(j=1; j<=E->lmesh.nox; j++)
Topo_gravity.c:502:	    for(k=1; k<=E->lmesh.noz; k++) {
Topo_gravity.c:503:	      n = k+(j-1)*E->lmesh.noz+(i-1)*noxnoz;
Topo_gravity.c:504:	      for(d=1; d<=E->mesh.nsd; d++)
Topo_gravity.c:505:		if(E->node[n] & sbc_flag[d]) {
Topo_gravity.c:506:		  if(i==1 || i==E->lmesh.noy)
Topo_gravity.c:507:		    E->gstress[(n-1)*6+stress_index[d][2]] = E->sphere.cap.VB[d][n];
Topo_gravity.c:508:		  if(j==1 || j==E->lmesh.nox)
Topo_gravity.c:509:		    E->gstress[(n-1)*6+stress_index[d][1]] = E->sphere.cap.VB[d][n];
Topo_gravity.c:510:		  if(k==1 || k==E->lmesh.noz)
Topo_gravity.c:511:		    E->gstress[(n-1)*6+stress_index[d][3]] = E->sphere.cap.VB[d][n];
Topo_gravity.c:529:     * E->buoyancy needs to be converted to density (-therm_exp*ref_T/Ra/g)
Topo_gravity.c:539:    nxnz = E->lmesh.nox*E->lmesh.noz;
Topo_gravity.c:540:    radius_m = E->data.radius_km*1e3;
Topo_gravity.c:543:    scaling2 = -E->data.therm_exp*E->data.ref_temperature*E->data.density
Topo_gravity.c:544:      / fabs(E->control.Atemp);
Topo_gravity.c:546:    scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:547:        / E->data.grav_acc;
Topo_gravity.c:550:    TT = (float *) malloc ((E->lmesh.nsf+1)*sizeof(float));
Topo_gravity.c:553:    geoid[0] = (float*)malloc(E->sphere.hindice*sizeof(float));
Topo_gravity.c:555:    geoid[1] = (float*)malloc(E->sphere.hindice*sizeof(float));
Topo_gravity.c:558:    for (p = 0; p < E->sphere.hindice; p++) {
Topo_gravity.c:566:    for(k=1;k<E->lmesh.noz;k++)  {
Topo_gravity.c:568:        grav = 0.5 * (E->refstate.gravity[k] + E->refstate.gravity[k+1]);
Topo_gravity.c:570:        for(i=1;i<=E->lmesh.noy;i++)
Topo_gravity.c:571:            for(j=1;j<=E->lmesh.nox;j++)  {
Topo_gravity.c:572:                node= k + (j-1)*E->lmesh.noz + (i-1)*nxnz;
Topo_gravity.c:573:                p = j + (i-1)*E->lmesh.nox;
Topo_gravity.c:576:                TT[p] = (E->buoyancy[node]+E->buoyancy[node+1])*0.5*buoy2rho;
Topo_gravity.c:583:        dlayer = (E->sx[3][k+1]-E->sx[3][k])*radius_m;
Topo_gravity.c:586:        radius = (E->sx[3][k+1]+E->sx[3][k])*0.5;
Topo_gravity.c:589:        for (ll=1;ll<=E->output.llmax;ll++) {
Topo_gravity.c:592:            conb = radius * pow(E->sphere.ri/radius, ((double)(ll)));
Topo_gravity.c:595:                p = E->sphere.hindex[ll][mm];
Topo_gravity.c:603:        //if(E->parallel.me==0)  fprintf(stderr,"layer %d %.5e %g %g %g\n",k,radius,dlayer,con1,con2);
Topo_gravity.c:624:     * E->slice.tpg is essentailly non-dimensional stress(rr) and need
Topo_gravity.c:632:    stress_scaling = E->data.ref_viscosity*E->data.therm_diff/
Topo_gravity.c:633:        (E->data.radius_km*E->data.radius_km*1e6);
Topo_gravity.c:636:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:638:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:641:    grav1 = E->refstate.gravity[E->lmesh.noz] * E->data.grav_acc;
Topo_gravity.c:643:    grav2 = E->refstate.gravity[1] * E->data.grav_acc;
Topo_gravity.c:650:    scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:651:        / E->data.grav_acc;
Topo_gravity.c:653:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:655:        sphere_expansion(E, E->slice.tpg, tpgt[0], tpgt[1]);
Topo_gravity.c:659:            for (i=0; i<E->sphere.hindice; i++) {
Topo_gravity.c:665:    if (E->parallel.me_loc[3] == 0) {
Topo_gravity.c:667:        sphere_expansion(E, E->slice.tpgb, tpgb[0], tpgb[1]);
Topo_gravity.c:671:            for (i=0; i<E->sphere.hindice; i++) {
Topo_gravity.c:678:    broadcast_vertical(E, tpgt[0], tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:700:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:702:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:706:    for (i = 0; i < E->sphere.hindice; i++) {
Topo_gravity.c:713:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:715:        scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:716:            / E->data.grav_acc;
Topo_gravity.c:720:            for (ll=2; ll<=E->output.llmax; ll++)   {
Topo_gravity.c:723:                    i = E->sphere.hindex[ll][mm];
Topo_gravity.c:730:    if (E->parallel.me_loc[3] == 0) {
Topo_gravity.c:732:        scaling = 1.0e3 * 4.0 * M_PI * E->data.radius_km * E->data.grav_const
Topo_gravity.c:733:            / (E->data.grav_acc * E->refstate.gravity[1]);
Topo_gravity.c:737:            for (ll=2; ll<=E->output.llmax; ll++)   {
Topo_gravity.c:739:                con2 = con1 * pow(E->sphere.ri, ((double)(ll+2)));
Topo_gravity.c:741:                    i = E->sphere.hindex[ll][mm];
Topo_gravity.c:749:    broadcast_vertical(E, geoid_tpgt[0], geoid_tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:772:    ri = E->sphere.ri;
Topo_gravity.c:775:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:777:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:780:    grav1 = E->refstate.gravity[E->lmesh.noz] * E->data.grav_acc;
Topo_gravity.c:782:    grav2 = E->refstate.gravity[1] * E->data.grav_acc;
Topo_gravity.c:789:    con4 = 4.0*M_PI*E->data.grav_const*E->data.radius_km*1000;
Topo_gravity.c:792:    for (i = 0; i < E->sphere.hindice; i++) {
Topo_gravity.c:799:    for (ll=2;ll<=E->output.llmax;ll++)   {
Topo_gravity.c:807:        a11 = den_contrast1*E->data.grav_acc - E->data.density*b1;
Topo_gravity.c:808:        a12 =                                - E->data.density*a1;
Topo_gravity.c:810:        a22 = den_contrast2*(E->data.grav_acc-a2);
Topo_gravity.c:815:            i = E->sphere.hindex[ll][mm];
Topo_gravity.c:818:            c1_0 = geoid_bncy[0][i]*E->data.density*grav1;
Topo_gravity.c:827:            c1_1 = geoid_bncy[1][i]*E->data.density*grav1;
Topo_gravity.c:855:    broadcast_vertical(E, geoid_tpgt[0], geoid_tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:862:    geoid_from_buoyancy(E, E->sphere.harm_geoid_from_bncy,
Topo_gravity.c:863:                        E->sphere.harm_geoid_from_bncy_botm);
Topo_gravity.c:865:    expand_topo_sph_harm(E, E->sphere.harm_tpgt, E->sphere.harm_tpgb);
Topo_gravity.c:867:    if(E->control.self_gravitation)
Topo_gravity.c:869:                                     E->sphere.harm_tpgt,
Topo_gravity.c:870:                                     E->sphere.harm_tpgb,
Topo_gravity.c:871:                                     E->sphere.harm_geoid_from_bncy,
Topo_gravity.c:872:                                     E->sphere.harm_geoid_from_bncy_botm,
Topo_gravity.c:873:                                     E->sphere.harm_geoid_from_tpgt,
Topo_gravity.c:874:                                     E->sphere.harm_geoid_from_tpgb);
Topo_gravity.c:876:        geoid_from_topography(E, E->sphere.harm_tpgt, E->sphere.harm_tpgb,
Topo_gravity.c:877:                              E->sphere.harm_geoid_from_tpgt,
Topo_gravity.c:878:                              E->sphere.harm_geoid_from_tpgb);
Topo_gravity.c:880:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Topo_gravity.c:882:            for (p = 0; p < E->sphere.hindice; p++) {
Topo_gravity.c:883:                E->sphere.harm_geoid[i][p]
Topo_gravity.c:884:                    = E->sphere.harm_geoid_from_bncy[i][p]
Topo_gravity.c:885:                    + E->sphere.harm_geoid_from_tpgt[i][p]
Topo_gravity.c:886:                    + E->sphere.harm_geoid_from_tpgb[i][p];
Topo_gravity.c:931:    const int dims=E->mesh.nsd;
Topo_gravity.c:935:    const int noz=E->lmesh.noz;
Topo_gravity.c:936:    const int noy=E->lmesh.noy;
Topo_gravity.c:937:    const int nno=E->lmesh.nno;
Topo_gravity.c:940:    const int elz = E->lmesh.elz;
Topo_gravity.c:941:    const int ely = E->lmesh.ely;
Topo_gravity.c:942:    const int lev=E->mesh.levmax;
Topo_gravity.c:945:    const int lnsf=E->lmesh.nsf;
Topo_gravity.c:960:  for(els=1;els<=E->lmesh.snel;els++) {
Topo_gravity.c:961:    el = E->surf_element[els];
Topo_gravity.c:989:    if (E->control.augmented_Lagr) {
Topo_gravity.c:997:         res[m]  = eltf[m]  - E->elt_del[lev][el].g[m][0]  * E->P[el];
Topo_gravity.c:998:         resb[m] = eltfb[m] - E->elt_del[lev][elb].g[m][0]* E->P[elb];
Topo_gravity.c:999://           res[m]  = eltf[m] - eltg[m][0]  * E->P[el];
Topo_gravity.c:1000://           resb[m] = eltfb[m] - eltgb[m][0]* E->P[elb];
Topo_gravity.c:1015:              nodes = E->sien[els].node[1];
Topo_gravity.c:1018:              nodes = E->sien[els].node[2];
Topo_gravity.c:1021:              nodes = E->sien[els].node[3];
Topo_gravity.c:1024:              nodes = E->sien[els].node[4];
Topo_gravity.c:1032:              nodes = E->sien[els].node[1];
Topo_gravity.c:1035:              nodes = E->sien[els].node[2];
Topo_gravity.c:1038:              nodes = E->sien[els].node[3];
Topo_gravity.c:1041:              nodes = E->sien[els].node[4];
Topo_gravity.c:1052:  for(els=1;els<=E->lmesh.snel;els++) {
Topo_gravity.c:1053:     el = E->surf_element[els];
Topo_gravity.c:1065:              * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:1068:              * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:1073:          SL[E->sien[els].node[m]] += eltTL[m-1];
Topo_gravity.c:1076:          SU[E->sien[els].node[m]] += eltTU[m-1];
Topo_gravity.c:1081:if(E->parallel.me_loc[3] == 0) {
Topo_gravity.c:1082:  if(E->sphere.caps == 12)
Topo_gravity.c:1083:      full_exchange_snode_f(E,RL,SL,E->mesh.levmax);
Topo_gravity.c:1085:      regional_exchange_snode_f(E,RL,SL,E->mesh.levmax);
Topo_gravity.c:1087:  for(i=1;i<=E->lmesh.nsf;i++)
Topo_gravity.c:1091:  if(E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:1092:  if(E->sphere.caps == 12)
Topo_gravity.c:1093:      full_exchange_snode_f(E,RU,SU,E->mesh.levmax);
Topo_gravity.c:1095:      regional_exchange_snode_f(E,RU,SU,E->mesh.levmax);
Topo_gravity.c:1097:    for(i=1;i<=E->lmesh.nsf;i++)
Tracer_setup.c:101:    int m=E->parallel.me;
Tracer_setup.c:104:    input_boolean("tracer",&(E->control.tracer),"off",m);
Tracer_setup.c:106:		  &(E->control.tracer_enriched),"off",m);
Tracer_setup.c:107:    if(E->control.tracer_enriched){
Tracer_setup.c:108:      if(!E->control.tracer)	/* check here so that we can get away
Tracer_setup.c:113:      input_float("Q0_enriched",&(E->control.Q0ER),"0.0",m);
Tracer_setup.c:115:	       E->control.Q0,E->control.Q0ER);
Tracer_setup.c:121:      //if(E->composition.ncomp != 1)
Tracer_setup.c:125:    if(E->control.tracer) {
Tracer_setup.c:130:        input_int("tracer_ic_method",&(E->trace.ic_method),"0,0,nomax",m);
Tracer_setup.c:132:        if (E->trace.ic_method==0){
Tracer_setup.c:133:            input_int("tracers_per_element",&(E->trace.itperel),"10,0,nomax",m);
Tracer_setup.c:135:        else if (E->trace.ic_method==1)
Tracer_setup.c:136:            input_string("tracer_file",E->trace.tracer_file,"tracer.dat",m);
Tracer_setup.c:137:        else if (E->trace.ic_method==2) {
Tracer_setup.c:152:        input_int("tracer_flavors",&(E->trace.nflavors),"0,0,nomax",m);
Tracer_setup.c:163:		  &(E->trace.ic_method_for_flavors),"0,0,nomax",m);
Tracer_setup.c:166:        if (E->trace.nflavors > 1) {
Tracer_setup.c:167:            switch(E->trace.ic_method_for_flavors){
Tracer_setup.c:171:                E->trace.z_interface = (double*) malloc((E->trace.nflavors-1)
Tracer_setup.c:173:                for(i=0; i<E->trace.nflavors-1; i++)
Tracer_setup.c:174:                    E->trace.z_interface[i] = 0.7;
Tracer_setup.c:176:                input_double_vector("z_interface", E->trace.nflavors-1,
Tracer_setup.c:177:                                    E->trace.z_interface, m);
Tracer_setup.c:187:	      input_string("ictracer_grd_file",E->trace.ggrd_file,"",m); /* file from which to read */
Tracer_setup.c:188:	      input_int("ictracer_grd_layers",&(E->trace.ggrd_layers),"2",m); /* 
Tracer_setup.c:198:                fprintf(stderr,"ic_method_for_flavors %i undefined (1 and 99 only for ggrd mode)\n",E->trace.ic_method_for_flavors);
Tracer_setup.c:205:        input_boolean("itracer_warnings",&(E->trace.itracer_warnings),"on",m);
Tracer_setup.c:208:        if(E->parallel.nprocxy == 12)
Tracer_setup.c:231:   E->trace.advection_time = 0;
Tracer_setup.c:232:   E->trace.find_tracers_time = 0;
Tracer_setup.c:233:   E->trace.lost_souls_time = 0;
Tracer_setup.c:235:   if(E->parallel.nprocxy == 1) {
Tracer_setup.c:236:       E->problem_tracer_setup = regional_tracer_setup;
Tracer_setup.c:238:       E->trace.keep_within_bounds = regional_keep_within_bounds;
Tracer_setup.c:239:       E->trace.get_velocity = regional_get_velocity;
Tracer_setup.c:240:       E->trace.iget_element = regional_iget_element;
Tracer_setup.c:243:       E->problem_tracer_setup = full_tracer_setup;
Tracer_setup.c:245:       E->trace.keep_within_bounds = full_keep_within_bounds;
Tracer_setup.c:246:       E->trace.get_velocity = full_get_velocity;
Tracer_setup.c:247:       E->trace.iget_element = full_iget_element;
Tracer_setup.c:272:    if (E->trace.nflavors > 0)
Tracer_setup.c:276:    if (E->composition.on) {
Tracer_setup.c:280:    E->trace.advection_time += CPU_time0() - begin_time;
Tracer_setup.c:297:    E->trace.istat_isend=0;
Tracer_setup.c:298:    E->trace.istat_elements_checked=0;
Tracer_setup.c:299:    E->trace.istat1=0;
Tracer_setup.c:302:    if ((E->monitor.solution_cycles % 20) == 0) {
Tracer_setup.c:303:        fprintf(E->trace.fpt, "STEP %d\n", E->monitor.solution_cycles);
Tracer_setup.c:305:        fprintf(E->trace.fpt, "Advecting tracers takes %f seconds.\n",
Tracer_setup.c:306:                E->trace.advection_time - E->trace.find_tracers_time);
Tracer_setup.c:307:        fprintf(E->trace.fpt, "Finding element takes %f seconds.\n",
Tracer_setup.c:308:                E->trace.find_tracers_time - E->trace.lost_souls_time);
Tracer_setup.c:309:        fprintf(E->trace.fpt, "Exchanging lost tracers takes %f seconds.\n",
Tracer_setup.c:310:                E->trace.lost_souls_time);
Tracer_setup.c:313:    if(E->control.verbose){
Tracer_setup.c:314:      fprintf(E->trace.fpt,"Number of times for all element search  %d\n",E->trace.istat1);
Tracer_setup.c:316:      fprintf(E->trace.fpt,"Number of tracers sent to other processors: %d\n",E->trace.istat_isend);
Tracer_setup.c:318:      fprintf(E->trace.fpt,"Number of times element columns are checked: %d \n",E->trace.istat_elements_checked);
Tracer_setup.c:322:      if (E->composition.on) {
Tracer_setup.c:323:        fprintf(E->trace.fpt,"Empty elements filled with old compositional "
Tracer_setup.c:324:                "values: %d (%f percent)\n", E->trace.istat_iempty,
Tracer_setup.c:325:                (100.0*E->trace.istat_iempty)/E->lmesh.nel);
Tracer_setup.c:326:        E->trace.istat_iempty=0;
Tracer_setup.c:331:        if (E->parallel.me==0) {
Tracer_setup.c:333:            fprintf(E->fp,"composition: %e",E->monitor.elapsed_time);
Tracer_setup.c:334:            for (i=0; i<E->composition.ncomp; i++)
Tracer_setup.c:335:                fprintf(E->fp," %e", E->composition.bulk_composition[i]);
Tracer_setup.c:336:            fprintf(E->fp,"\n");
Tracer_setup.c:338:            fprintf(E->fp,"composition_error_fraction: %e",E->monitor.elapsed_time);
Tracer_setup.c:339:            for (i=0; i<E->composition.ncomp; i++)
Tracer_setup.c:340:                fprintf(E->fp," %e", E->composition.error_fraction[i]);
Tracer_setup.c:341:            fprintf(E->fp,"\n");
Tracer_setup.c:345:      fflush(E->trace.fpt);
Tracer_setup.c:382:    dt=E->advection.timestep;
Tracer_setup.c:384:    numtracers=E->trace.ntracers;
Tracer_setup.c:388:        theta0=E->trace.basicq[0][kk];
Tracer_setup.c:389:        phi0=E->trace.basicq[1][kk];
Tracer_setup.c:390:        rad0=E->trace.basicq[2][kk];
Tracer_setup.c:391:        x0=E->trace.basicq[3][kk];
Tracer_setup.c:392:        y0=E->trace.basicq[4][kk];
Tracer_setup.c:393:        z0=E->trace.basicq[5][kk];
Tracer_setup.c:395:        nelem=E->trace.ielement[kk];
Tracer_setup.c:396:        (E->trace.get_velocity)(E,nelem,theta0,phi0,rad0,velocity_vector);
Tracer_setup.c:406:        (E->trace.keep_within_bounds)(E,&x_pred,&y_pred,&z_pred,&theta_pred,&phi_pred,&rad_pred);
Tracer_setup.c:410:        E->trace.basicq[0][kk]=theta_pred;
Tracer_setup.c:411:        E->trace.basicq[1][kk]=phi_pred;
Tracer_setup.c:412:        E->trace.basicq[2][kk]=rad_pred;
Tracer_setup.c:413:        E->trace.basicq[3][kk]=x_pred;
Tracer_setup.c:414:        E->trace.basicq[4][kk]=y_pred;
Tracer_setup.c:415:        E->trace.basicq[5][kk]=z_pred;
Tracer_setup.c:419:        E->trace.basicq[6][kk]=x0;
Tracer_setup.c:420:        E->trace.basicq[7][kk]=y0;
Tracer_setup.c:421:        E->trace.basicq[8][kk]=z0;
Tracer_setup.c:425:        E->trace.basicq[9][kk]=velocity_vector[1];  /* Vx */
Tracer_setup.c:426:        E->trace.basicq[10][kk]=velocity_vector[2];  /* Vy */
Tracer_setup.c:427:        E->trace.basicq[11][kk]=velocity_vector[3];  /* Vz */
Tracer_setup.c:469:    dt=E->advection.timestep;
Tracer_setup.c:472:    for (kk=1;kk<=E->trace.ntracers;kk++) {
Tracer_setup.c:474:        theta_pred=E->trace.basicq[0][kk];
Tracer_setup.c:475:        phi_pred=E->trace.basicq[1][kk];
Tracer_setup.c:476:        rad_pred=E->trace.basicq[2][kk];
Tracer_setup.c:477:        x_pred=E->trace.basicq[3][kk];
Tracer_setup.c:478:        y_pred=E->trace.basicq[4][kk];
Tracer_setup.c:479:        z_pred=E->trace.basicq[5][kk];
Tracer_setup.c:481:        x0=E->trace.basicq[6][kk];
Tracer_setup.c:482:        y0=E->trace.basicq[7][kk];
Tracer_setup.c:483:        z0=E->trace.basicq[8][kk];
Tracer_setup.c:485:        Vx0=E->trace.basicq[9][kk];
Tracer_setup.c:486:        Vy0=E->trace.basicq[10][kk];
Tracer_setup.c:487:        Vz0=E->trace.basicq[11][kk];
Tracer_setup.c:489:        nelem=E->trace.ielement[kk];
Tracer_setup.c:491:        (E->trace.get_velocity)(E,nelem,theta_pred,phi_pred,rad_pred,velocity_vector);
Tracer_setup.c:502:        (E->trace.keep_within_bounds)(E,&x_cor,&y_cor,&z_cor,&theta_cor,&phi_cor,&rad_cor);
Tracer_setup.c:506:        E->trace.basicq[0][kk]=theta_cor;
Tracer_setup.c:507:        E->trace.basicq[1][kk]=phi_cor;
Tracer_setup.c:508:        E->trace.basicq[2][kk]=rad_cor;
Tracer_setup.c:509:        E->trace.basicq[3][kk]=x_cor;
Tracer_setup.c:510:        E->trace.basicq[4][kk]=y_cor;
Tracer_setup.c:511:        E->trace.basicq[5][kk]=z_cor;
Tracer_setup.c:554:    E->trace.ilater=E->trace.ilatersize=0;
Tracer_setup.c:556:    E->trace.istat1=0;
Tracer_setup.c:558:        E->trace.istat_ichoice[kk]=0;
Tracer_setup.c:565:    num_tracers=E->trace.ntracers;
Tracer_setup.c:571:        theta=E->trace.basicq[0][it];
Tracer_setup.c:572:        phi=E->trace.basicq[1][it];
Tracer_setup.c:573:        rad=E->trace.basicq[2][it];
Tracer_setup.c:574:        x=E->trace.basicq[3][it];
Tracer_setup.c:575:        y=E->trace.basicq[4][it];
Tracer_setup.c:576:        z=E->trace.basicq[5][it];
Tracer_setup.c:578:        iprevious_element=E->trace.ielement[it];
Tracer_setup.c:580:        iel=(E->trace.iget_element)(E,iprevious_element,x,y,z,theta,phi,rad);
Tracer_setup.c:582:        fprintf(E->trace.fpt,"BB. kk %d %d %d %d %f %f %f %f %f %f\n",kk,j,iprevious_element,iel,x,y,z,theta,phi,rad);
Tracer_setup.c:583:        fflush(E->trace.fpt);
Tracer_setup.c:586:        E->trace.ielement[it]=iel;
Tracer_setup.c:598:            if (E->trace.itracer_warnings) exit(10);
Tracer_setup.c:609:if (E->parallel.nprocxy == 12)
Tracer_setup.c:616:    if (E->trace.ilatersize>0) {
Tracer_setup.c:617:        for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:618:            free(E->trace.rlater[kk]);
Tracer_setup.c:626:    E->trace.find_tracers_time += CPU_time0() - begin_time;
Tracer_setup.c:641:    for (flavor=0; flavor<E->trace.nflavors; flavor++)
Tracer_setup.c:642:        for (e=1; e<=E->lmesh.nel; e++)
Tracer_setup.c:643:            E->trace.ntracer_flavor[flavor][e] = 0;
Tracer_setup.c:645:    numtracers=E->trace.ntracers;
Tracer_setup.c:649:        e = E->trace.ielement[kk];
Tracer_setup.c:650:        flavor = E->trace.extraq[0][kk];
Tracer_setup.c:651:        E->trace.ntracer_flavor[flavor][e]++;
Tracer_setup.c:658:    if (E->trace.ic_method==0)
Tracer_setup.c:660:    else if (E->trace.ic_method==1)
Tracer_setup.c:662:    else if (E->trace.ic_method==2)
Tracer_setup.c:665:        fprintf(E->trace.fpt,"Not ready for other inputs yet\n");
Tracer_setup.c:666:        fflush(E->trace.fpt);
Tracer_setup.c:671:    E->trace.ilast_tracer_count = isum_tracers(E);
Tracer_setup.c:672:    fprintf(E->trace.fpt, "Sum of Tracers: %d\n", E->trace.ilast_tracer_count);
Tracer_setup.c:673:    if(E->parallel.me==0)
Tracer_setup.c:674:        fprintf(stderr, "Sum of Tracers: %d\n", E->trace.ilast_tracer_count);
Tracer_setup.c:682:    if (E->trace.nflavors > 0)
Tracer_setup.c:700:    if (E->parallel.me==0) fprintf(stderr,"Making Tracer Array\n");
Tracer_setup.c:703:    processor_fraction=E->lmesh.volume/E->mesh.volume;
Tracer_setup.c:704:    tracers_cap=E->mesh.nel*E->trace.itperel*processor_fraction;
Tracer_setup.c:706:    fprintf(E->trace.fpt,"\nGenerating %d Tracers\n",tracers_cap);
Tracer_setup.c:711:    if (E->trace.nflavors) 
Tracer_setup.c:732:    /* One must loop over E->X to find the min/max, since the 8 corner */
Tracer_setup.c:734:    xmin = ymin = zmin = E->sphere.ro;
Tracer_setup.c:735:    xmax = ymax = zmax = -E->sphere.ro;
Tracer_setup.c:736:    for (kk=1; kk<=E->lmesh.nno; kk++) {
Tracer_setup.c:737:        x = E->x[1][kk];
Tracer_setup.c:738:        y = E->x[2][kk];
Tracer_setup.c:739:        z = E->x[3][kk];
Tracer_setup.c:751:    while (E->trace.ntracers<tracers_cap) {
Tracer_setup.c:757:            fprintf(E->trace.fpt,"Error(make_tracer_array)-too many tries?\n");
Tracer_setup.c:758:            fprintf(E->trace.fpt,"%d %d %d\n",max_tries,number_of_tries,RAND_MAX);
Tracer_setup.c:759:            fflush(E->trace.fpt);
Tracer_setup.c:781:        if (rad>=E->sx[3][E->lmesh.noz]) continue;
Tracer_setup.c:782:        if (rad<E->sx[3][1]) continue;
Tracer_setup.c:786:        if (E->parallel.nprocxy==1)
Tracer_setup.c:795:        (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:797:        E->trace.ntracers++;
Tracer_setup.c:798:        kk=E->trace.ntracers;
Tracer_setup.c:800:        E->trace.basicq[0][kk]=theta;
Tracer_setup.c:801:        E->trace.basicq[1][kk]=phi;
Tracer_setup.c:802:        E->trace.basicq[2][kk]=rad;
Tracer_setup.c:803:        E->trace.basicq[3][kk]=x;
Tracer_setup.c:804:        E->trace.basicq[4][kk]=y;
Tracer_setup.c:805:        E->trace.basicq[5][kk]=z;
Tracer_setup.c:841:    fptracer=fopen(E->trace.tracer_file,"r");
Tracer_setup.c:845:        fprintf(stderr,"Error while reading file '%s'\n", E->trace.tracer_file);
Tracer_setup.c:848:    fprintf(E->trace.fpt,"%d Tracers, %d columns in file \n",
Tracer_setup.c:852:    if (E->trace.number_of_extra_quantities+3 != ncolumns) {
Tracer_setup.c:853:        fprintf(E->trace.fpt,"ERROR(read tracer file)-wrong # of columns\n");
Tracer_setup.c:854:        fflush(E->trace.fpt);
Tracer_setup.c:864:    E->trace.number_of_tracers = number_of_tracers;
Tracer_setup.c:866:    iestimate=number_of_tracers/E->parallel.nproc + icushion;
Tracer_setup.c:872:            ncol = 3 + E->trace.number_of_extra_quantities;
Tracer_setup.c:876:                fprintf(E->trace.fpt,"ERROR(read tracer file) - wrong input file format: %s\n", E->trace.tracer_file);
Tracer_setup.c:877:                fflush(E->trace.fpt);
Tracer_setup.c:890:            (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:895:            if (E->parallel.nprocz>1) icheck=icheck_processor_shell(E,rad);
Tracer_setup.c:898:            if (E->parallel.nprocxy==1)
Tracer_setup.c:908:            E->trace.ntracers++;
Tracer_setup.c:910:            if (E->trace.ntracers>=(E->trace.max_ntracers-5)) 
Tracer_setup.c:913:            E->trace.basicq[0][E->trace.ntracers]=theta;
Tracer_setup.c:914:            E->trace.basicq[1][E->trace.ntracers]=phi;
Tracer_setup.c:915:            E->trace.basicq[2][E->trace.ntracers]=rad;
Tracer_setup.c:916:            E->trace.basicq[3][E->trace.ntracers]=x;
Tracer_setup.c:917:            E->trace.basicq[4][E->trace.ntracers]=y;
Tracer_setup.c:918:            E->trace.basicq[5][E->trace.ntracers]=z;
Tracer_setup.c:920:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:921:                E->trace.extraq[i][E->trace.ntracers]=buffer[i+3];
Tracer_setup.c:925:        fprintf(E->trace.fpt,"Number of tracers in this cap is: %d\n",
Tracer_setup.c:926:                E->trace.ntracers);
Tracer_setup.c:933:        fprintf(E->trace.fpt,"ERROR(read_tracer_file) - tracers != number in file\n");
Tracer_setup.c:934:        fprintf(E->trace.fpt,"Tracers in system: %d\n", icheck);
Tracer_setup.c:935:        fprintf(E->trace.fpt,"Tracers in file: %d\n", number_of_tracers);
Tracer_setup.c:936:        fflush(E->trace.fpt);
Tracer_setup.c:965:    if (E->trace.number_of_extra_quantities>99) {
Tracer_setup.c:966:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-increase size of extra[]\n");
Tracer_setup.c:967:        fflush(E->trace.fpt);
Tracer_setup.c:975:    if(strcmp(E->output.format, "ascii-gz") == 0){
Tracer_setup.c:977:	      E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:980:      sprintf(output_file,"%s.tracer.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:982:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-gziped file not found %s\n",output_file);
Tracer_setup.c:983:        fflush(E->trace.fpt);
Tracer_setup.c:988:    sprintf(output_file,"%s.tracer.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:990:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-file not found %s\n",output_file);
Tracer_setup.c:991:        fflush(E->trace.fpt);
Tracer_setup.c:1008:        if (E->trace.number_of_extra_quantities+3 != ncolumns) {
Tracer_setup.c:1009:            fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-wrong # of columns\n");
Tracer_setup.c:1010:            fflush(E->trace.fpt);
Tracer_setup.c:1017:        E->trace.ntracers=numtracers;
Tracer_setup.c:1021:            ncol = 3 + E->trace.number_of_extra_quantities;
Tracer_setup.c:1025:                fprintf(E->trace.fpt,"ERROR(read_old_tracer_file) - wrong input file format: %s\n", output_file);
Tracer_setup.c:1026:                fflush(E->trace.fpt);
Tracer_setup.c:1038:            (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:1040:            E->trace.basicq[0][kk]=theta;
Tracer_setup.c:1041:            E->trace.basicq[1][kk]=phi;
Tracer_setup.c:1042:            E->trace.basicq[2][kk]=rad;
Tracer_setup.c:1043:            E->trace.basicq[3][kk]=x;
Tracer_setup.c:1044:            E->trace.basicq[4][kk]=y;
Tracer_setup.c:1045:            E->trace.basicq[5][kk]=z;
Tracer_setup.c:1047:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:1048:                E->trace.extraq[i][kk]=buffer[i+3];
Tracer_setup.c:1052:        fprintf(E->trace.fpt,"Read %d tracers from file %s\n",numtracers,output_file);
Tracer_setup.c:1053:        fflush(E->trace.fpt);
Tracer_setup.c:1057:    if(strcmp(E->output.format, "ascii-gz") == 0)
Tracer_setup.c:1072:    iold_number = E->trace.ilast_tracer_count;
Tracer_setup.c:1075:        fprintf(E->trace.fpt,"ERROR(check_sum)-break in conservation %d %d\n",
Tracer_setup.c:1077:        fflush(E->trace.fpt);
Tracer_setup.c:1078:        if (E->trace.itracer_warnings)
Tracer_setup.c:1082:    E->trace.ilast_tracer_count = number;
Tracer_setup.c:1096:    imycount = imycount + E->trace.ntracers;
Tracer_setup.c:1098:    MPI_Allreduce(&imycount,&iallcount,1,MPI_INT,MPI_SUM,E->parallel.world);
Tracer_setup.c:1147:    switch(E->trace.ic_method_for_flavors){
Tracer_setup.c:1153:	number_of_tracers = E->trace.ntracers;
Tracer_setup.c:1155:	  rad = E->trace.basicq[2][kk];
Tracer_setup.c:1157:          flavor = E->trace.nflavors - 1;
Tracer_setup.c:1158:          for (i=0; i<E->trace.nflavors-1; i++) {
Tracer_setup.c:1159:              if (rad > E->trace.z_interface[i]) {
Tracer_setup.c:1164:          E->trace.extraq[0][kk] = flavor;
Tracer_setup.c:1172:	      E->trace.ic_method_for_flavors);
Tracer_setup.c:1182:      fprintf(stderr,"ic_method_for_flavors %i undefined\n",E->trace.ic_method_for_flavors);
Tracer_setup.c:1191:/* which is later used by (E->trace.icheck_cap)()                            */
Tracer_setup.c:1210:    nox=E->lmesh.nox;
Tracer_setup.c:1211:    noy=E->lmesh.noy;
Tracer_setup.c:1212:    noz=E->lmesh.noz;
Tracer_setup.c:1219:    lev = E->mesh.levmax;
Tracer_setup.c:1226:                xx[n] = E->sx[d+1][node[i]];
Tracer_setup.c:1232:        num_ngb = E->parallel.TNUM_PASS[lev];
Tracer_setup.c:1234:            neighbor_proc = E->parallel.PROCESSOR[lev].pass[kk];
Tracer_setup.c:1237:                      tag, E->parallel.world, &request[idb]);
Tracer_setup.c:1241:                      tag, E->parallel.world, &request[idb]);
Tracer_setup.c:1255:         *      1) E->sphere.caps_per_proc==1
Tracer_setup.c:1256:         *      2) E->mesh.nsd==3
Tracer_setup.c:1263:                rad = E->sphere.ro;
Tracer_setup.c:1267:                E->trace.xcap[kk][i] = x;
Tracer_setup.c:1268:                E->trace.ycap[kk][i] = y;
Tracer_setup.c:1269:                E->trace.zcap[kk][i] = z;
Tracer_setup.c:1270:                E->trace.theta_cap[kk][i] = theta;
Tracer_setup.c:1271:                E->trace.phi_cap[kk][i] = phi;
Tracer_setup.c:1272:                E->trace.rad_cap[kk][i] = rad;
Tracer_setup.c:1273:                E->trace.cos_theta[kk][i] = cos(theta);
Tracer_setup.c:1274:                E->trace.sin_theta[kk][i] = sin(theta);
Tracer_setup.c:1275:                E->trace.cos_phi[kk][i] = cos(phi);
Tracer_setup.c:1276:                E->trace.sin_phi[kk][i] = sin(phi);
Tracer_setup.c:1283:                neighbor_proc = E->parallel.me;
Tracer_setup.c:1285:                neighbor_proc = E->parallel.PROCESSOR[lev][1].pass[kk];
Tracer_setup.c:1288:                fprintf(E->trace.fpt, "pass=%d rank=%d corner=%d "
Tracer_setup.c:1291:                        E->trace.theta_cap[kk][i],
Tracer_setup.c:1292:                        E->trace.phi_cap[kk][i],
Tracer_setup.c:1293:                        E->trace.rad_cap[kk][i]);
Tracer_setup.c:1296:        fflush(E->trace.fpt);
Tracer_setup.c:1312:    E->trace.max_ntracers=number_of_tracers+number_of_tracers/4;
Tracer_setup.c:1313:    E->trace.ntracers=0;
Tracer_setup.c:1317:    if ((E->trace.ielement=(int *) malloc(E->trace.max_ntracers*sizeof(int)))==NULL) {
Tracer_setup.c:1318:        fprintf(E->trace.fpt,"ERROR(make tracer array)-no memory 1a\n");
Tracer_setup.c:1319:        fflush(E->trace.fpt);
Tracer_setup.c:1322:    for (kk=1;kk<E->trace.max_ntracers;kk++)
Tracer_setup.c:1323:        E->trace.ielement[kk]=-99;
Tracer_setup.c:1326:    for (kk=0;kk<E->trace.number_of_basic_quantities;kk++) {
Tracer_setup.c:1327:        if ((E->trace.basicq[kk]=(double *)malloc(E->trace.max_ntracers*sizeof(double)))==NULL) {
Tracer_setup.c:1328:            fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1b.%d\n",kk);
Tracer_setup.c:1329:            fflush(E->trace.fpt);
Tracer_setup.c:1334:    for (kk=0;kk<E->trace.number_of_extra_quantities;kk++) {
Tracer_setup.c:1335:        if ((E->trace.extraq[kk]=(double *)malloc(E->trace.max_ntracers*sizeof(double)))==NULL) {
Tracer_setup.c:1336:            fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1c.%d\n",kk);
Tracer_setup.c:1337:            fflush(E->trace.fpt);
Tracer_setup.c:1342:    if (E->trace.nflavors > 0) {
Tracer_setup.c:1343:        E->trace.ntracer_flavor=(int **)malloc(E->trace.nflavors*sizeof(int*));
Tracer_setup.c:1344:        for (kk=0;kk<E->trace.nflavors;kk++) {
Tracer_setup.c:1345:            if ((E->trace.ntracer_flavor[kk]=(int *)malloc((E->lmesh.nel+1)*sizeof(int)))==NULL) {
Tracer_setup.c:1346:                fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1c.%d\n",kk);
Tracer_setup.c:1347:                fflush(E->trace.fpt);
Tracer_setup.c:1354:    fprintf(E->trace.fpt,"Physical size of tracer arrays (max_ntracers): %d\n",
Tracer_setup.c:1355:            E->trace.max_ntracers);
Tracer_setup.c:1356:    fflush(E->trace.fpt);
Tracer_setup.c:1371:    inewsize=E->trace.max_ntracers+E->trace.max_ntracers/5+icushion;
Tracer_setup.c:1373:    if ((E->trace.ielement=(int *)realloc(E->trace.ielement,inewsize*sizeof(int)))==NULL) {
Tracer_setup.c:1374:        fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory (ielement)\n");
Tracer_setup.c:1375:        fflush(E->trace.fpt);
Tracer_setup.c:1379:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++) {
Tracer_setup.c:1380:        if ((E->trace.basicq[kk]=(double *)realloc(E->trace.basicq[kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1381:            fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory (%d)\n",kk);
Tracer_setup.c:1382:            fflush(E->trace.fpt);
Tracer_setup.c:1387:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++) {
Tracer_setup.c:1388:        if ((E->trace.extraq[kk]=(double *)realloc(E->trace.extraq[kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1389:            fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory 78 (%d)\n",kk);
Tracer_setup.c:1390:            fflush(E->trace.fpt);
Tracer_setup.c:1396:    fprintf(E->trace.fpt,"Expanding physical memory of ielement, basicq, and extraq to %d from %d\n",
Tracer_setup.c:1397:            inewsize,E->trace.max_ntracers);
Tracer_setup.c:1399:    E->trace.max_ntracers=inewsize;
Tracer_setup.c:1415:        iempty_space=(E->trace.max_ntracers-E->trace.ntracers);
Tracer_setup.c:1417:        if (iempty_space>(E->trace.ntracers+icushion)) {
Tracer_setup.c:1420:            inewsize=E->trace.ntracers+E->trace.ntracers/4+icushion;
Tracer_setup.c:1423:                fprintf(E->trace.fpt,"Error(reduce tracer arrays)-something up (hdf3)\n");
Tracer_setup.c:1424:                fflush(E->trace.fpt);
Tracer_setup.c:1429:            if ((E->trace.ielement=(int *)realloc(E->trace.ielement,inewsize*sizeof(int)))==NULL) {
Tracer_setup.c:1430:                fprintf(E->trace.fpt,"ERROR(reduce tracer arrays )-no memory (ielement)\n");
Tracer_setup.c:1431:                fflush(E->trace.fpt);
Tracer_setup.c:1436:            for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++) {
Tracer_setup.c:1437:                if ((E->trace.basicq[kk]=(double *)realloc(E->trace.basicq[kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1438:                    fprintf(E->trace.fpt,"AKM(reduce tracer arrays )-no memory (%d)\n",kk);
Tracer_setup.c:1439:                    fflush(E->trace.fpt);
Tracer_setup.c:1444:            for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++) {
Tracer_setup.c:1445:                if ((E->trace.extraq[kk]=(double *)realloc(E->trace.extraq[kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1446:                    fprintf(E->trace.fpt,"AKM(reduce tracer arrays )-no memory 783 (%d)\n",kk);
Tracer_setup.c:1447:                    fflush(E->trace.fpt);
Tracer_setup.c:1453:            fprintf(E->trace.fpt,"Reducing physical memory of ielement, basicq, and extraq to %d from %d\n",
Tracer_setup.c:1454:                    E->trace.max_ntracers,inewsize);
Tracer_setup.c:1456:            E->trace.max_ntracers=inewsize;
Tracer_setup.c:1475:    if (E->trace.ilatersize==0) {
Tracer_setup.c:1477:        E->trace.ilatersize=E->trace.max_ntracers/5;
Tracer_setup.c:1479:        for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:1480:            if ((E->trace.rlater[kk]=
Tracer_setup.c:1481:                  (double *)malloc(E->trace.ilatersize*sizeof(double)))==NULL) {
Tracer_setup.c:1482:                fprintf(E->trace.fpt,"AKM(put_away_later)-no memory (%d)\n",kk);
Tracer_setup.c:1483:                fflush(E->trace.fpt);
Tracer_setup.c:1492:    E->trace.ilater++;
Tracer_setup.c:1494:    if (E->trace.ilater >= (E->trace.ilatersize-5)) expand_later_array(E);
Tracer_setup.c:1498:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++)
Tracer_setup.c:1499:        E->trace.rlater[kk][E->trace.ilater]=E->trace.basicq[kk][it];
Tracer_setup.c:1501:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++)
Tracer_setup.c:1502:        E->trace.rlater[E->trace.number_of_basic_quantities+kk][E->trace.ilater]=E->trace.extraq[kk][it];
Tracer_setup.c:1518:    inewsize=E->trace.ilatersize+E->trace.ilatersize/5+icushion;
Tracer_setup.c:1520:    for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:1521:        if ((E->trace.rlater[kk]=(double *)realloc(E->trace.rlater[kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:1522:            fprintf(E->trace.fpt,"AKM(expand later array )-no memory (%d)\n",kk);
Tracer_setup.c:1523:            fflush(E->trace.fpt);
Tracer_setup.c:1529:    fprintf(E->trace.fpt,
Tracer_setup.c:1531:            inewsize,E->trace.ilatersize);
Tracer_setup.c:1533:    E->trace.ilatersize=inewsize;
Tracer_setup.c:1545:    ilast_tracer=E->trace.ntracers;
Tracer_setup.c:1549:    E->trace.ielement[it]=E->trace.ielement[ilast_tracer];
Tracer_setup.c:1551:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++)
Tracer_setup.c:1552:        E->trace.basicq[kk][it]=E->trace.basicq[kk][ilast_tracer];
Tracer_setup.c:1554:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++)
Tracer_setup.c:1555:        E->trace.extraq[kk][it]=E->trace.extraq[kk][ilast_tracer];
Tracer_setup.c:1557:    E->trace.ntracers--;
Tracer_setup.c:1574:    const int noz = E->lmesh.noz;
Tracer_setup.c:1575:    const int nprocz = E->parallel.nprocz;
Tracer_setup.c:1580:    top_r = E->sx[3][noz];
Tracer_setup.c:1581:    bottom_r = E->sx[3][1];
Tracer_setup.c:1594:    if ( (rad<=top_r) && (E->parallel.me_loc[3]==nprocz-1) ) return 1;
Tracer_setup.c:1614:    int me = E->parallel.me;
Tracer_setup.c:1629:    fprintf(E->trace.fpt, "Should not be here\n");
Tracer_setup.c:1630:    fprintf(E->trace.fpt, "Error(check_shell) nprocessor: %d, radius: %f\n",
Tracer_setup.c:1632:    fflush(E->trace.fpt);
Viscosity_structures.c:59:    int m=E->parallel.me;
Viscosity_structures.c:63:    input_boolean("VISC_UPDATE",&(E->viscosity.update_allowed),"on",m);
Viscosity_structures.c:65:    input_boolean("visc_layer_control",&(E->viscosity.layer_control),"off",m);
Viscosity_structures.c:66:    input_string("visc_layer_file", E->viscosity.layer_file,"visc.dat",m);
Viscosity_structures.c:69:    input_int("allow_anisotropic_viscosity",&(E->viscosity.allow_anisotropic_viscosity),"0",m);
Viscosity_structures.c:71:    if(E->viscosity.allow_anisotropic_viscosity){ /* error */
Viscosity_structures.c:76:    if(E->viscosity.allow_anisotropic_viscosity){ /* read additional
Viscosity_structures.c:80:      input_int("anisotropic_init",&(E->viscosity.anisotropic_init),"0",m); /* 0: isotropic
Viscosity_structures.c:90:      input_string("anisotropic_init_dir",(E->viscosity.anisotropic_init_dir),"",m); /* directory
Viscosity_structures.c:95:      input_int("anivisc_layer",&(E->viscosity.anivisc_layer),"1",m); /* >0: assign to layers on top of anivisc_layer
Viscosity_structures.c:98:      if((E->viscosity.anisotropic_init == 6) && (E->viscosity.anivisc_layer >= 0))
Viscosity_structures.c:102:		    &(E->viscosity.anivisc_start_from_iso),"on",m); /* start
Viscosity_structures.c:106:      if(!E->viscosity.anivisc_start_from_iso)
Viscosity_structures.c:107:	if(E->viscosity.anisotropic_init == 3){
Viscosity_structures.c:108:	  if(E->parallel.me == 0)fprintf(stderr,"WARNING: overriding anisotropic first step for ani init mode\n");
Viscosity_structures.c:109:	  E->viscosity.anivisc_start_from_iso = TRUE;
Viscosity_structures.c:112:      input_double("ani_vis2_factor",&(E->viscosity.ani_vis2_factor),"1.0",m);
Viscosity_structures.c:120:    for(i=0;i < E->viscosity.num_mat;i++)
Viscosity_structures.c:121:        E->viscosity.N0[i]=1.0;
Viscosity_structures.c:122:    input_float_vector("visc0",E->viscosity.num_mat,(E->viscosity.N0),m);
Viscosity_structures.c:124:    input_boolean("TDEPV",&(E->viscosity.TDEPV),"on",m);
Viscosity_structures.c:125:    input_int("rheol",&(E->viscosity.RHEOL),"3",m);
Viscosity_structures.c:126:    if (E->viscosity.TDEPV) {
Viscosity_structures.c:127:        for(i=0;i < E->viscosity.num_mat;i++) {
Viscosity_structures.c:128:            E->viscosity.T[i] = 0.0;
Viscosity_structures.c:129:            E->viscosity.Z[i] = 0.0;
Viscosity_structures.c:130:            E->viscosity.E[i] = 0.0;
Viscosity_structures.c:133:        input_float_vector("viscT",E->viscosity.num_mat,(E->viscosity.T),m);
Viscosity_structures.c:134:        input_float_vector("viscE",E->viscosity.num_mat,(E->viscosity.E),m);
Viscosity_structures.c:135:        input_float_vector("viscZ",E->viscosity.num_mat,(E->viscosity.Z),m);
Viscosity_structures.c:138:        input_float("T_sol0",&(E->viscosity.T_sol0),"0.6",m);
Viscosity_structures.c:139:        input_float("ET_red",&(E->viscosity.ET_red),"0.1",m);
Viscosity_structures.c:143:    E->viscosity.sdepv_misfit = 1.0;
Viscosity_structures.c:144:    input_boolean("SDEPV",&(E->viscosity.SDEPV),"off",m);
Viscosity_structures.c:145:    if (E->viscosity.SDEPV) {
Viscosity_structures.c:146:      E->viscosity.sdepv_visited = 0;
Viscosity_structures.c:147:      input_float_vector("sdepv_expt",E->viscosity.num_mat,(E->viscosity.sdepv_expt),m);
Viscosity_structures.c:151:    input_boolean("PDEPV",&(E->viscosity.PDEPV),"off",m); /* plasticity addition by TWB */
Viscosity_structures.c:152:    if (E->viscosity.PDEPV) {
Viscosity_structures.c:153:      E->viscosity.pdepv_visited = 0;
Viscosity_structures.c:154:      for(i=0;i < E->viscosity.num_mat;i++) {
Viscosity_structures.c:155:          E->viscosity.pdepv_a[i] = 1.e20; /* \sigma_y = min(a + b * (1-r),y) */
Viscosity_structures.c:156:          E->viscosity.pdepv_b[i] = 0.0;
Viscosity_structures.c:157:          E->viscosity.pdepv_y[i] = 1.e20;
Viscosity_structures.c:160:      input_boolean("psrw",&(E->viscosity.psrw),"off",m); /* SRW? else regular plasiticity */
Viscosity_structures.c:161:      input_boolean("pdepv_eff",&(E->viscosity.pdepv_eff),"on",m); /* effective
Viscosity_structures.c:165:      input_float_vector("pdepv_a",E->viscosity.num_mat,(E->viscosity.pdepv_a),m);
Viscosity_structures.c:166:      input_float_vector("pdepv_b",E->viscosity.num_mat,(E->viscosity.pdepv_b),m);
Viscosity_structures.c:167:      input_float_vector("pdepv_y",E->viscosity.num_mat,(E->viscosity.pdepv_y),m);
Viscosity_structures.c:169:      input_float("pdepv_offset",&(E->viscosity.pdepv_offset),"0.0",m);
Viscosity_structures.c:171:    input_float("sdepv_misfit",&(E->viscosity.sdepv_misfit),"0.001",m);	/* there should be no harm in having 
Viscosity_structures.c:177:    //input_boolean("CDEPV",&(E->viscosity.CDEPV),"off",m);
Viscosity_structures.c:179:      E->viscosity.cdepv_ff[i] = 1.0; /* flavor factors for CDEPV */
Viscosity_structures.c:180:    if(E->viscosity.CDEPV){
Viscosity_structures.c:182:      if(E->control.tracer < 1){
Viscosity_structures.c:186:      if(E->trace.nflavors > 10)
Viscosity_structures.c:189:      input_float_vector("cdepv_ff",E->trace.nflavors,
Viscosity_structures.c:190:			 (E->viscosity.cdepv_ff),m);
Viscosity_structures.c:192:      for(i=0;i<E->trace.nflavors;i++)
Viscosity_structures.c:193:	E->viscosity.cdepv_ff[i] = log(E->viscosity.cdepv_ff[i]);
Viscosity_structures.c:197:    input_boolean("low_visc_channel",&(E->viscosity.channel),"off",m);
Viscosity_structures.c:198:    input_boolean("low_visc_wedge",&(E->viscosity.wedge),"off",m);
Viscosity_structures.c:200:    input_float("lv_min_radius",&(E->viscosity.lv_min_radius),"0.9764",m);
Viscosity_structures.c:201:    input_float("lv_max_radius",&(E->viscosity.lv_max_radius),"0.9921",m);
Viscosity_structures.c:202:    input_float("lv_channel_thickness",&(E->viscosity.lv_channel_thickness),"0.0047",m);
Viscosity_structures.c:203:    input_float("lv_reduction",&(E->viscosity.lv_reduction),"0.5",m);
Viscosity_structures.c:205:    input_boolean("use_ne_visc_smooth",&(E->viscosity.SMOOTH),"off",m);
Viscosity_structures.c:207:    input_boolean("VMAX",&(E->viscosity.MAX),"off",m);
Viscosity_structures.c:208:    if (E->viscosity.MAX)
Viscosity_structures.c:209:        input_float("visc_max",&(E->viscosity.max_value),"1e22,1,nomax",m);
Viscosity_structures.c:211:    input_boolean("VMIN",&(E->viscosity.MIN),"off",m);
Viscosity_structures.c:212:    if (E->viscosity.MIN)
Viscosity_structures.c:213:        input_float("visc_min",&(E->viscosity.min_value),"1e20",m);
Viscosity_structures.c:221:    int m = E->parallel.me;
Viscosity_structures.c:223:    input_string("Viscosity",E->viscosity.STRUCTURE,"system",m);
Viscosity_structures.c:224:    input_int ("visc_smooth_method",&(E->viscosity.smooth_cycles),"0",m);
Viscosity_structures.c:226:    if ( strcmp(E->viscosity.STRUCTURE,"system") == 0)
Viscosity_structures.c:227:        E->viscosity.FROM_SYSTEM = 1;
Viscosity_structures.c:229:        E->viscosity.FROM_SYSTEM = 0;
Viscosity_structures.c:231:    if (E->viscosity.FROM_SYSTEM)
Viscosity_structures.c:242:  if(E->viscosity.layer_control) {
Viscosity_structures.c:244:    i = E->mesh.noz - 1;
Viscosity_structures.c:246:    i = E->viscosity.num_mat;
Viscosity_structures.c:249:  E->viscosity.N0 = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:250:  E->viscosity.E = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:251:  E->viscosity.T = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:252:  E->viscosity.Z = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:253:  E->viscosity.pdepv_a = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:254:  E->viscosity.pdepv_b = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:255:  E->viscosity.pdepv_y = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:256:  E->viscosity.sdepv_expt = (float*) malloc(i*sizeof(float));
Viscosity_structures.c:258:  if(E->viscosity.N0 == NULL ||
Viscosity_structures.c:259:     E->viscosity.E == NULL ||
Viscosity_structures.c:260:     E->viscosity.T == NULL ||
Viscosity_structures.c:261:     E->viscosity.Z == NULL ||
Viscosity_structures.c:262:     E->viscosity.pdepv_a == NULL ||
Viscosity_structures.c:263:     E->viscosity.pdepv_b == NULL ||
Viscosity_structures.c:264:     E->viscosity.pdepv_y == NULL ||
Viscosity_structures.c:265:     E->viscosity.sdepv_expt == NULL) {
Viscosity_structures.c:267:	    E->parallel.me);
Viscosity_structures.c:279:   evisc = E->EVI[E->mesh.levmax]
Viscosity_structures.c:280:   visc  = E->VI[E->mesh.levmax]
Viscosity_structures.c:304:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:306:    if(E->viscosity.allow_anisotropic_viscosity){
Viscosity_structures.c:307:      if(!E->viscosity.anisotropic_viscosity_init)
Viscosity_structures.c:315:    if(E->viscosity.TDEPV)
Viscosity_structures.c:320:    if(E->viscosity.CDEPV)	/* compositional prefactor */
Viscosity_structures.c:323:    if(E->viscosity.SDEPV)
Viscosity_structures.c:326:    if(E->viscosity.PDEPV)	/* "plasticity" */
Viscosity_structures.c:336:    if(E->viscosity.channel || E->viscosity.wedge)
Viscosity_structures.c:342:    if(E->viscosity.MAX) {
Viscosity_structures.c:343:        for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:345:                if(evisc[(i-1)*vpts + j] > E->viscosity.max_value)
Viscosity_structures.c:346:                    evisc[(i-1)*vpts + j] = E->viscosity.max_value;
Viscosity_structures.c:349:    if(E->viscosity.MIN) {
Viscosity_structures.c:350:        for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:352:                if(evisc[(i-1)*vpts + j] < E->viscosity.min_value)
Viscosity_structures.c:353:                    evisc[(i-1)*vpts + j] = E->viscosity.min_value;
Viscosity_structures.c:356:    if (E->control.verbose)  {
Viscosity_structures.c:357:      fprintf(E->fp_out,"output_evisc \n");
Viscosity_structures.c:358:        fprintf(E->fp_out,"output_evisc for cap %d\n",E->sphere.capid);
Viscosity_structures.c:359:      for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:360:          fprintf(E->fp_out,"%d %d %f %f\n",i,E->mat[i],evisc[(i-1)*vpts+1],evisc[(i-1)*vpts+7]);
Viscosity_structures.c:362:      fflush(E->fp_out);
Viscosity_structures.c:364:    visc_from_gint_to_nodes(E,evisc,visc,E->mesh.levmax);
Viscosity_structures.c:366:    if(E->viscosity.SMOOTH){ /* go the other way, for
Viscosity_structures.c:368:      visc_from_nodes_to_gint(E,visc,evisc,E->mesh.levmax);
Viscosity_structures.c:372:    if(E->viscosity.allow_anisotropic_viscosity){
Viscosity_structures.c:373:      visc_from_gint_to_nodes(E,E->EVI2[E->mesh.levmax], E->VI2[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:374:      visc_from_gint_to_nodes(E,E->EVIn1[E->mesh.levmax], E->VIn1[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:375:      visc_from_gint_to_nodes(E,E->EVIn2[E->mesh.levmax], E->VIn2[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:376:      visc_from_gint_to_nodes(E,E->EVIn3[E->mesh.levmax], E->VIn3[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:377:      normalize_director_at_nodes(E,E->VIn1[E->mesh.levmax],E->VIn2[E->mesh.levmax],E->VIn3[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:379:      if(E->viscosity.SMOOTH){ 
Viscosity_structures.c:380:	if(E->parallel.me == 0)fprintf(stderr,"WARNING: smoothing anisotropic viscosity, perhaps not a good idea\n");
Viscosity_structures.c:381:	visc_from_nodes_to_gint(E,E->VI2[E->mesh.levmax],E->EVI2[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:382:	visc_from_nodes_to_gint(E,E->VIn1[E->mesh.levmax],E->EVIn1[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:383:	visc_from_nodes_to_gint(E,E->VIn2[E->mesh.levmax],E->EVIn2[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:384:	visc_from_nodes_to_gint(E,E->VIn3[E->mesh.levmax],E->EVIn3[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:385:	normalize_director_at_gint(E,E->EVIn1[E->mesh.levmax],E->EVIn2[E->mesh.levmax],E->EVIn3[E->mesh.levmax],E->mesh.levmax);
Viscosity_structures.c:401:    if (E->viscosity.FROM_SYSTEM)
Viscosity_structures.c:402:        get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Viscosity_structures.c:411:    if(E->control.mat_control){	/* use pre-factor even without temperature dependent viscosity */
Viscosity_structures.c:412:        for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:413:	  for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)
Viscosity_structures.c:414:	    EEta[ (i-1)*vpoints[E->mesh.nsd]+jj ] = E->viscosity.N0[E->mat[i]-1]*E->VIP[i];
Viscosity_structures.c:416:        for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:417:	  for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)
Viscosity_structures.c:418:	    EEta[ (i-1)*vpoints[E->mesh.nsd]+jj ] = E->viscosity.N0[E->mat[i]-1];
Viscosity_structures.c:429:    fp = fopen(E->viscosity.layer_file, "r");
Viscosity_structures.c:431:        fprintf(E->fp, "(Viscosity_structures #1) Cannot open %s\n", E->viscosity.layer_file);
Viscosity_structures.c:437:    for(i=0; i<E->mesh.elz; i++) {
Viscosity_structures.c:438:        E->viscosity.N0[i] =
Viscosity_structures.c:439:            E->viscosity.E[i] =
Viscosity_structures.c:440:            E->viscosity.T[i] =
Viscosity_structures.c:441:            E->viscosity.Z[i] =
Viscosity_structures.c:442:            E->viscosity.pdepv_a[i] =
Viscosity_structures.c:443:            E->viscosity.pdepv_b[i] =
Viscosity_structures.c:444:            E->viscosity.pdepv_y[i] =
Viscosity_structures.c:445:            E->viscosity.sdepv_expt[i] = 0;
Viscosity_structures.c:448:    read_visc_param_from_file(E, "visc0", E->viscosity.N0, fp);
Viscosity_structures.c:449:    if(E->viscosity.TDEPV) {
Viscosity_structures.c:450:        read_visc_param_from_file(E, "viscE", E->viscosity.E, fp);
Viscosity_structures.c:451:        read_visc_param_from_file(E, "viscT", E->viscosity.T, fp);
Viscosity_structures.c:452:        read_visc_param_from_file(E, "viscZ", E->viscosity.Z, fp);
Viscosity_structures.c:455:    if(E->viscosity.SDEPV) {
Viscosity_structures.c:456:        read_visc_param_from_file(E, "sdepv_expt", E->viscosity.sdepv_expt, fp);
Viscosity_structures.c:459:    if(E->viscosity.PDEPV) {
Viscosity_structures.c:460:        read_visc_param_from_file(E, "pdepv_a", E->viscosity.pdepv_a, fp);
Viscosity_structures.c:461:        read_visc_param_from_file(E, "pdepv_b", E->viscosity.pdepv_b, fp);
Viscosity_structures.c:462:        read_visc_param_from_file(E, "pdepv_y", E->viscosity.pdepv_y, fp);
Viscosity_structures.c:475:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:476:    const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:477:    const int nel = E->lmesh.nel;
Viscosity_structures.c:484:    switch (E->viscosity.RHEOL)   {
Viscosity_structures.c:488:                l = E->mat[i] - 1;
Viscosity_structures.c:490:                if(E->control.mat_control==0)
Viscosity_structures.c:491:                    tempa = E->viscosity.N0[l];
Viscosity_structures.c:493:                    tempa = E->viscosity.N0[l]*E->VIP[i];
Viscosity_structures.c:496:                    TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:502:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:506:                        exp( E->viscosity.E[l] * (E->viscosity.T[l] - temp));
Viscosity_structures.c:515:                l = E->mat[i] - 1;
Viscosity_structures.c:517:                if(E->control.mat_control==0)
Viscosity_structures.c:518:                    tempa = E->viscosity.N0[l];
Viscosity_structures.c:520:                    tempa = E->viscosity.N0[l]*E->VIP[i];
Viscosity_structures.c:523:                    TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:529:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:533:                        exp( -temp / E->viscosity.T[l]);
Viscosity_structures.c:546:                l = E->mat[i] - 1;
Viscosity_structures.c:547:		if(E->control.mat_control) /* switch moved up here TWB */
Viscosity_structures.c:548:		  tempa = E->viscosity.N0[l] * E->VIP[i];
Viscosity_structures.c:550:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:553:		  TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:563:		      temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:566:		      exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:567:			   - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:575:                l = E->mat[i] - 1;
Viscosity_structures.c:576:		if(E->control.mat_control) /* moved this up here TWB */
Viscosity_structures.c:577:		  tempa = E->viscosity.N0[l] * E->VIP[i];
Viscosity_structures.c:579:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:582:                    TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:583:                    zz[kk] = (1.-E->sx[3][E->ien[i].node[kk]]);
Viscosity_structures.c:591:                        temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:592:                        zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:597:		      exp( (E->viscosity.E[l] +  E->viscosity.Z[l]*zzz )
Viscosity_structures.c:598:			   / (E->viscosity.T[l]+temp) );
Viscosity_structures.c:610:                l = E->mat[i] - 1;
Viscosity_structures.c:611:                tempa = E->viscosity.N0[l];
Viscosity_structures.c:614:                    TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:621:                        temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:624:                    if(E->control.mat_control==0){
Viscosity_structures.c:626:                            exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:627:                                 - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:630:	               exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:631:		          - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:632:                       if(E->viscosity.MAX) {
Viscosity_structures.c:633:                           if(visc2 > E->viscosity.max_value)
Viscosity_structures.c:634:                               visc2 = E->viscosity.max_value;
Viscosity_structures.c:636:                       if(E->viscosity.MIN) {
Viscosity_structures.c:637:                           if(visc2 < E->viscosity.min_value)
Viscosity_structures.c:638:                               visc2 = E->viscosity.min_value;
Viscosity_structures.c:640:                       EEta[ (i-1)*vpts + jj ] = E->VIP[i]*visc2;
Viscosity_structures.c:655:	    l = E->mat[i] - 1;
Viscosity_structures.c:657:	    if(E->control.mat_control)
Viscosity_structures.c:658:	      tempa = E->viscosity.N0[l] * E->VIP[i];
Viscosity_structures.c:660:	      tempa = E->viscosity.N0[l];
Viscosity_structures.c:663:	      TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:664:	      zz[kk] = (1.0 - E->sx[3][E->ien[i].node[kk]]);
Viscosity_structures.c:671:		temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:672:		zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:675:		exp( E->viscosity.E[l]*(E->viscosity.T[l] - temp) +
Viscosity_structures.c:676:		     zzz *  E->viscosity.Z[l]);
Viscosity_structures.c:678:               if(E->parallel.me == 0)
Viscosity_structures.c:680:                        zzz *E->data.radius_km ,l+1,
Viscosity_structures.c:681:                        tempa,temp,E->viscosity.T[l],E->viscosity.E[l], E->viscosity.Z[l],l+1,log10(EEta[m][ (i-1)*vpts + jj ]));
Viscosity_structures.c:705:           E->viscosity.E = Ea/(R*DT);
Viscosity_structures.c:707:           E->viscosity.Z = Va*rho*g/(R*DT);
Viscosity_structures.c:708:           E->viscosity.T = T0;
Viscosity_structures.c:716:	      l = E->mat[i] - 1;
Viscosity_structures.c:718:		if(E->control.mat_control)
Viscosity_structures.c:719:		  tempa = E->viscosity.N0[l] * E->VIP[i];
Viscosity_structures.c:721:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:724:                    TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:725:                    zz[kk] = (1.-E->sx[3][E->ien[i].node[kk]]);
Viscosity_structures.c:732:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:733:                        zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:738:                        exp( (E->viscosity.E[l] +  E->viscosity.Z[l]*zzz )
Viscosity_structures.c:739:                             / (E->viscosity.T[l] + temp)
Viscosity_structures.c:740:                             - (E->viscosity.E[l] +
Viscosity_structures.c:741:                                E->viscosity.Z[l]*(E->sphere.ro-E->sphere.ri) )
Viscosity_structures.c:742:                             / (E->viscosity.T[l] + one) );
Viscosity_structures.c:763:        dr = E->sphere.ro - E->sphere.ri;
Viscosity_structures.c:765:                l = E->mat[i] - 1;
Viscosity_structures.c:766:		if(E->control.mat_control) 
Viscosity_structures.c:767:		  tempa = E->viscosity.N0[l] * E->VIP[i];
Viscosity_structures.c:769:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:772:		  TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:773:		  zz[kk] = E->sx[3][E->ien[i].node[kk]]; /* radius */
Viscosity_structures.c:780:		      temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)]; /* mean temp */
Viscosity_structures.c:781:		      zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];/* mean r */
Viscosity_structures.c:785:		    zzz = (zzz - E->sphere.ri)/dr;
Viscosity_structures.c:786:		    visc1 = tempa* exp( E->viscosity.E[l]/(temp+E->viscosity.T[l]) 
Viscosity_structures.c:787:				  - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:788:		    if(temp < E->viscosity.T_sol0 + 2.*(1.-zzz))
Viscosity_structures.c:791:		      EEta[ (i-1)*vpts + jj ] = visc1 * E->viscosity.ET_red;
Viscosity_structures.c:802:                l = E->mat[i] - 1;
Viscosity_structures.c:803:		if(E->control.mat_control) /* switch moved up here TWB */
Viscosity_structures.c:804:		  tempa = E->viscosity.N0[l] * E->VIP[i];
Viscosity_structures.c:806:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:808:		  TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:813:		      temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:815:		      exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:816:			   - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:831:        dr = E->sphere.ro - E->sphere.ri;
Viscosity_structures.c:833:                l = E->mat[i] - 1;
Viscosity_structures.c:834:		if(E->control.mat_control) 
Viscosity_structures.c:835:		  tempa = E->viscosity.N0[l] * E->VIP[i];
Viscosity_structures.c:837:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:840:		  TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:841:		  zz[kk] = E->sx[3][E->ien[i].node[kk]]; /* radius */
Viscosity_structures.c:847:		      temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)]; /* mean temp */
Viscosity_structures.c:848:		      zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];/* mean r */
Viscosity_structures.c:850:		    zzz = (zzz - E->sphere.ri)/dr;
Viscosity_structures.c:851:		    visc1 = tempa* exp( E->viscosity.E[l]/(temp+E->viscosity.T[l]) 
Viscosity_structures.c:852:				  - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:853:		    if(temp < E->viscosity.T_sol0 + 2.*(1.-zzz))
Viscosity_structures.c:856:		      EEta[ (i-1)*vpts + jj ] = visc1 * E->viscosity.ET_red;
Viscosity_structures.c:865:                E->viscosity.RHEOL);
Viscosity_structures.c:871:        fprintf(stderr, "Invalid value of 'rheol=%d'\n", E->viscosity.RHEOL);
Viscosity_structures.c:886:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:887:    const int nel = E->lmesh.nel;
Viscosity_structures.c:893:      if(E->viscosity.sdepv_visited){
Viscosity_structures.c:900:	E->viscosity.sdepv_visited = 1;
Viscosity_structures.c:909:            exponent1= one/E->viscosity.sdepv_expt[E->mat[e]-1];
Viscosity_structures.c:970:  const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:971:  const int nel = E->lmesh.nel;
Viscosity_structures.c:972:  const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:979:    if(E->viscosity.pdepv_visited){
Viscosity_structures.c:980:      if(E->viscosity.psrw)
Viscosity_structures.c:987:	E->viscosity.pdepv_visited = 1;
Viscosity_structures.c:988:      if((E->parallel.me == 0)&&(E->control.verbose)){
Viscosity_structures.c:990:		e,E->viscosity.pdepv_a[e],E->viscosity.pdepv_b[e],E->viscosity.pdepv_y[e],
Viscosity_structures.c:991:		(E->viscosity.psrw)?(" -- SRW"):(""));
Viscosity_structures.c:994:    if(!E->viscosity.psrw){
Viscosity_structures.c:1000:	l = E->mat[e] -1 ;	/* material of this element */
Viscosity_structures.c:1003:	  zz[kk] = (1.0 - E->sx[3][E->ien[e].node[kk]]); /* for depth, zz = 1 - r */
Viscosity_structures.c:1009:	    zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:1012:	  tau = E->viscosity.pdepv_a[l] + zzz * E->viscosity.pdepv_b[l];
Viscosity_structures.c:1015:	  tau = min(tau,  E->viscosity.pdepv_y[l]);
Viscosity_structures.c:1018:	  eta_p = tau/(2.0 * eedot[e] + 1e-7) + E->viscosity.pdepv_offset;
Viscosity_structures.c:1019:	  if(E->viscosity.pdepv_eff){
Viscosity_structures.c:1027:	  //	  zzz,l,E->viscosity.pdepv_a[l], E->viscosity.pdepv_b[l],E->viscosity.pdepv_y[l],
Viscosity_structures.c:1036:	l = E->mat[e] -1 ;	
Viscosity_structures.c:1038:	  zz[kk] = (1.0 - E->sx[3][E->ien[e].node[kk]]); 
Viscosity_structures.c:1042:	    zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:1044:	  tau = E->viscosity.pdepv_a[l] + zzz * E->viscosity.pdepv_b[l];
Viscosity_structures.c:1045:	  tau = min(tau,  E->viscosity.pdepv_y[l]);
Viscosity_structures.c:1054:	    //	    E->viscosity.pdepv_a[l],E->viscosity.pdepv_b[l],E->viscosity.pdepv_y[l],zzz,tau,eedot[e],eta_old,eta_new,
Viscosity_structures.c:1077:  const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:1078:  const int nel = E->lmesh.nel;
Viscosity_structures.c:1079:  const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:1083:        for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:1085:                CC[p][kk] = E->composition.comp_node[p][E->ien[i].node[kk]];
Viscosity_structures.c:1093:            for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:1097:                    cc_loc[p] += CC[p][kk] * E->N.vpt[GNVINDEX(kk, jj)];
Viscosity_structures.c:1103:            vmean = cbackground * E->viscosity.cdepv_ff[0];
Viscosity_structures.c:1104:            for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:1105:                vmean += cc_loc[p] * E->viscosity.cdepv_ff[p+1];
Viscosity_structures.c:1135:    const int nel = E->lmesh.nel;
Viscosity_structures.c:1136:    const int dims = E->mesh.nsd;
Viscosity_structures.c:1138:    const int lev = E->mesh.levmax;
Viscosity_structures.c:1147:        GNx = &(E->gNX[e]);
Viscosity_structures.c:1172:        if ((E->control.precise_strain_rate) || 
Viscosity_structures.c:1180:            if ((e-1)%E->lmesh.elz==0) {
Viscosity_structures.c:1181:                construct_c3x3matrix_el(E,e,&E->element_Cc,&E->element_Ccx,
Viscosity_structures.c:1185:            get_ba_p(&(E->N), GNx, &E->element_Cc, &E->element_Ccx,
Viscosity_structures.c:1186:                     rtf, E->mesh.nsd, ba);
Viscosity_structures.c:1200:                                   + VV[3][i] * E->N.ppt[GNPINDEX(i, j)])
Viscosity_structures.c:1203:                                    + VV[1][i] * E->N.ppt[GNPINDEX(i, j)]
Viscosity_structures.c:1205:                                   + VV[3][i] * E->N.ppt[GNPINDEX(i, j)])
Viscosity_structures.c:1210:                                    - VV[2][i] * E->N.ppt[GNPINDEX(i, j)]
Viscosity_structures.c:1216:                                       - VV[1][i] * E->N.ppt[GNPINDEX(i, j)]);
Viscosity_structures.c:1221:                                       - VV[2][i] * E->N.ppt[GNPINDEX(i, j)]);
Viscosity_structures.c:1226:        if(E->control.inv_gruneisen != 0) {
Viscosity_structures.c:1265:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:1269:    if(E->control.tracer == 0) {
Viscosity_structures.c:1270:        if(E->parallel.me == 0) {
Viscosity_structures.c:1273:            fprintf(E->fp, "Error: low viscosity channel/wedge is turned on, "
Viscosity_structures.c:1275:            fflush(E->fp);
Viscosity_structures.c:1280:    F = (float *)malloc((E->lmesh.nel+1)*sizeof(float));
Viscosity_structures.c:1281:    for(i=1 ; i<=E->lmesh.nel ; i++)
Viscosity_structures.c:1285:    if(E->viscosity.channel)
Viscosity_structures.c:1289:    if(E->viscosity.wedge)
Viscosity_structures.c:1293:    for(i=1 ; i<=E->lmesh.nel ; i++) {
Viscosity_structures.c:1310:    for(e=1; e<=E->lmesh.elz; e++) {
Viscosity_structures.c:1311:        rad_mean = 0.5 * (E->sx[3][E->ien[e].node[1]] +
Viscosity_structures.c:1312:                          E->sx[3][E->ien[e].node[8]]);
Viscosity_structures.c:1313:        if(rad_mean >= E->viscosity.lv_min_radius) break;
Viscosity_structures.c:1318:    for(e=E->lmesh.elz; e>=1; e--) {
Viscosity_structures.c:1319:        rad_mean = 0.5 * (E->sx[3][E->ien[e].node[1]] +
Viscosity_structures.c:1320:                          E->sx[3][E->ien[e].node[8]]);
Viscosity_structures.c:1321:        if(rad_mean <= E->viscosity.lv_max_radius) break;
Viscosity_structures.c:1325:    for(k=1; k<=E->lmesh.elx*E->lmesh.ely; k++) {
Viscosity_structures.c:1327:            e = (k-1)*E->lmesh.elz + i;
Viscosity_structures.c:1329:            rad_mean = 0.5 * (E->sx[3][E->ien[e].node[1]] +
Viscosity_structures.c:1330:                              E->sx[3][E->ien[e].node[8]]);
Viscosity_structures.c:1334:                ee = (k-1)*E->lmesh.elz + ii;
Viscosity_structures.c:1336:                rr = 0.5 * (E->sx[3][E->ien[ee].node[1]] +
Viscosity_structures.c:1337:                            E->sx[3][E->ien[ee].node[8]]);
Viscosity_structures.c:1340:                if((E->trace.ntracer_flavor[flavor][ee] > 0) &&
Viscosity_structures.c:1341:                   (rad_mean <= rr + E->viscosity.lv_channel_thickness)) {
Viscosity_structures.c:1342:                       F[e] = E->viscosity.lv_reduction;
Viscosity_structures.c:1358:    for(e=1; e<=E->lmesh.elz; e++) {
Viscosity_structures.c:1359:        rad_mean = 0.5 * (E->sx[3][E->ien[e].node[1]] +
Viscosity_structures.c:1360:                          E->sx[3][E->ien[e].node[8]]);
Viscosity_structures.c:1361:        if(rad_mean >= E->viscosity.lv_min_radius) break;
Viscosity_structures.c:1366:    for(e=E->lmesh.elz; e>=1; e--) {
Viscosity_structures.c:1367:        rad_mean = 0.5 * (E->sx[3][E->ien[e].node[1]] +
Viscosity_structures.c:1368:                          E->sx[3][E->ien[e].node[8]]);
Viscosity_structures.c:1369:        if(rad_mean <= E->viscosity.lv_max_radius) break;
Viscosity_structures.c:1373:    for(k=1; k<=E->lmesh.elx*E->lmesh.ely; k++) {
Viscosity_structures.c:1375:            e = (k-1)*E->lmesh.elz + i;
Viscosity_structures.c:1377:            rad_mean = 0.5 * (E->sx[3][E->ien[e].node[1]] +
Viscosity_structures.c:1378:                              E->sx[3][E->ien[e].node[8]]);
Viscosity_structures.c:1382:                ee = (k-1)*E->lmesh.elz + ii;
Viscosity_structures.c:1385:                if(E->trace.ntracer_flavor[flavor][ee] > 0) {
Viscosity_structures.c:1386:                    F[e] = E->viscosity.lv_reduction;
